  {"paragraph_no_1": {"text": "=== page 116 ===\nz\nchapter i", "entities": []}, "paragraph_no_2": {"text": "basic sql", "entities": ["sql"]}, "paragraph_no_3": {"text": "\u2018ti sql language may be considered one of the\nmajor reasons for the commercial success of rela-\ntional databases. because it became a standard for relational databases, users were\nless concerned about migrating their database applications from other types of\ndatabase systems\u2014for example, network or hierarchical systems\u2014to relational sys-\ntems. this is because even if the users became dissatisfied with the particular rela-\ntional dbms product they were using, converting to another relational dbms\nproduct was not expected to be too expensive and time-consuming because both\nsystems followed the same language standards. in practice, of course, there are many\ndifferences between various commercial relational dbms packages. however, if the\nuser is diligent in using only those features that are part of the standard, and if both\nrelational systems faithfully support the standard, then conversion between the two\nsystems should be much simplified. another advantage of having such a standard is\nthat users may write statements in a database application program that can access\ndata stored in two or more relational dbmss without having to change the database\nsublanguage (sql) if both relational dbmss support standard sql.", "entities": ["sql"]}, "paragraph_no_4": {"text": "this chapter presents the main features of the sql standard for commercial rela-\ntional dbmss, whereas chapter 3 presented the most important concepts underly-\ning the formal relational data model. in chapter 6 (sections 6.1 through 6.5) we\nshall discuss the relational algebra operations, which are very important for under-\nstanding the types of requests that may be specified on a relational database. they\nare also important for query processing and optimization in a relational dbms, as\nwe shall see in chapter 19. however, the relational algebra operations are consid-\nered to be too technical for most commercial dbms users because a query in rela-\ntional algebra is written as a sequence of operations that, when executed, produces\nthe required result. hence, the user must specify how\u2014that is, in what order\u2014to\nexecute the query operations. on the other hand, the sql language provides a", "entities": ["sql"]}, "paragraph_no_5": {"text": "87\n\f\n=== page 117 ===\n88", "entities": []}, "paragraph_no_6": {"text": "chapter 4 basic sol", "entities": []}, "paragraph_no_7": {"text": "higher-level declarative language interface, so the user only specifies what the result\nis to be, leaving the actual optimization and decisions on how to execute the query\nto the dbms. although sql includes some features from relational algebra, it is\nbased to a greater extent on the tuple relational calculus, which we describe in\nsection 6.6. however, the sql syntax is more user-friendly than either of the two\nformal languages.", "entities": ["sql"]}, "paragraph_no_8": {"text": "the name sql is presently expanded as structured query language. originally,\nsql was called sequel (structured english query language) and was designed\nand implemented at ibm research as the interface for an experimental relational\ndatabase system called system r. sql is now the standard language for commer-\ncial relational dbmss. a joint effort by the american national standards institute\n(ansi) and the international standards organization (iso) has led to a standard\nversion of sql (ansi 1986), called sql-86 or sql1. a revised and much expanded\nstandard called sql-92 (also referred to as sql2) was subsequently developed. the\nnext standard that is well-recognized is sql:1999, which started out as sql3. two\nlater updates to the standard are sql:2003 and sql:2006, which added xml fea-\ntures (see chapter 12) among other updates to the language. another update in\n2008 incorporated more object database features in sql (see chapter 11). we will\ntry to cover the latest version of sql as much as possible.", "entities": ["sql", "update", "join"]}, "paragraph_no_9": {"text": "sql is a comprehensive database language: it has statements for data definitions,\nqueries, and updates. hence, it is both a ddl and a dml. in addition, it has facili-\nties for defining views on the database, for specifying security and authorization, for\ndefining integrity constraints, and for specifying transaction controls. it also has\nrules for embedding sql statements into a general-purpose programming language\nsuch as java, cobol, or c/c++.!", "entities": ["sql", "update"]}, "paragraph_no_10": {"text": "the later sql standards (starting with sql:1999) are divided into a core specifica-\ntion plus specialized extensions. the core is supposed to be implemented by all\nrdbms vendors that are sql compliant. the extensions can be implemented as\noptional modules to be purchased independently for specific database applications\nsuch as data mining, spatial data, temporal data, data warehousing, online analytical\nprocessing (olap), multimedia data, and so on.", "entities": ["sql"]}, "paragraph_no_11": {"text": "because sql is very important (and quite large), we devote two chapters to its fea-\ntures. in this chapter, section 4.1 describes the sql ddl commands for creating\nschemas and tables, and gives an overview of the basic data types in sql. section 4.2\npresents how basic constraints such as key and referential integrity are specified.\nsection 4.3 describes the basic sql constructs for specifying retrieval queries, and\nsection 4.4 describes the sql commands for insertion, deletion, and data updates.", "entities": ["sql", "insert", "update"]}, "paragraph_no_12": {"text": "in chapter 5, we will describe more complex sql retrieval queries, as well as the\nalter commands for changing the schema. we will also describe the create\nassertion statement, which allows the specification of more general constraints\non the database. we also introduce the concept of triggers, which is presented in", "entities": ["sql"]}, "paragraph_no_13": {"text": "", "entities": []}, "paragraph_no_14": {"text": "\u2018originally, sol had statements for creating and dropping indexes on the files that represent relations,\nbut these have been dropped from the sql standard for some time.\n\f\n=== page 118 ===\n4.1 sql data definition and data types", "entities": ["sql"]}, "paragraph_no_15": {"text": "more detail in chapter 26 and we will describe the sql facility for defining views on\nthe database in chapter 5. views are also called virtual or derived tables because they\npresent the user with what appear to be tables; however, the information in those\ntables is derived from previously defined tables.", "entities": ["sql"]}, "paragraph_no_16": {"text": "section 4.5 lists some sql features that are presented in other chapters of the book;\nthese include transaction control in chapter 21, security/authorization in chapter\n24, active databases (triggers) in chapter 26, object-oriented features in chapter 11,\nand online analytical processing (olap) features in chapter 29. section 4.6 sum-\nmarizes the chapter. chapters 13 and 14 discuss the various database programming\ntechniques for programming with sql.", "entities": ["sql"]}, "paragraph_no_17": {"text": "4.1 sql data definition and data types", "entities": ["sql"]}, "paragraph_no_18": {"text": "sql uses the terms table, row, and column for the formal relational model terms\nrelation, tuple, and attribute, respectively. we will use the corresponding terms inter-\nchangeably. the main sql command for data definition is the create statement,\nwhich can be used to create schemas, tables (relations), and domains (as well as\nother constructs such as views, assertions, and triggers). before we describe the rel-\nevant create statements, we discuss schema and catalog concepts in section 4.1.1\nto place our discussion in perspective. section 4.1.2 describes how tables are created,\nand section 4.1.3 describes the most important data types available for attribute\nspecification. because the sql specification is very large, we give a description of\nthe most important features. further details can be found in the various sql stan-\ndards documents (see end-of-chapter bibliographic notes).", "entities": ["sql"]}, "paragraph_no_19": {"text": "4.1.1 schema and catalog concepts in sql", "entities": ["sql"]}, "paragraph_no_20": {"text": "early versions of sql did not include the concept of a relational database schema; all\ntables (relations) were considered part of the same schema. the concept of an sql\nschema was incorporated starting with sql2 in order to group together tables and\nother constructs that belong to the same database application. an sql schema is\nidentified by a schema name, and includes an authorization identifier to indicate\nthe user or account who owns the schema, as well as descriptors for each element in\nthe schema. schema elements include tables, constraints, views, domains, and other\nconstructs (such as authorization grants) that describe the schema. a schema is cre-\nated via the create schema statement, which can include all the schema elements\u2019\ndefinitions. alternatively, the schema can be assigned a name and authorization\nidentifier, and the elements can be defined later. for example, the following state-\nment creates a schema called company, owned by the user with authorization iden-\ntifier \u2018smith. note that each statement in sql ends with a semicolon.", "entities": ["sql"]}, "paragraph_no_21": {"text": "create schema company authorization \u2018jsmith\u2019;", "entities": []}, "paragraph_no_22": {"text": "in general, not all users are authorized to create schemas and schema elements. the\nprivilege to create schemas, tables, and other constructs must be explicitly granted\nto the relevant user accounts by the system administrator or dba.", "entities": []}, "paragraph_no_23": {"text": "89\n\f", "entities": []}, "paragraph_no_24": {"text": "4.3 basic retrieval queries in sql", "entities": ["sql"]}, "paragraph_no_25": {"text": "sql has one basic statement for retrieving information from a database: the\nselect statement. the select statement is not the same as the select operation\nof relational algebra, which we discuss in chapter 6. there are many options and\nflavors to the select statement in sql, so we will introduce its features gradually.\nwe will use sample queries specified on the schema of figure 3.5 and will refer to\nthe sample database state shown in figure 3.6 to show the results of some of the\nsample queries. in this section, we present the features of sql for simple retrieval\nqueries. features of sql for specifying more complex retrieval queries are presented\nin section 5.1.", "entities": ["sql", "select"]}, "paragraph_no_26": {"text": "before proceeding, we must point out an important distinction between sql and the\nformal relational model discussed in chapter 3: sql allows a table (relation) to\nhave two or more tuples that are identical in all their attribute values. hence, in gen-\neral, an sql table is not a set of tuples, because a set does not allow two identical\nmembers; rather, it is a multiset (sometimes called a bag) of tuples. some sql rela-\ntions are constrained to be sets because a key constraint has been declared or because\nthe distinct option has been used with the select statement (described later in\nthis section). we should be aware of this distinction as we discuss the examples.", "entities": ["sql", "select"]}, "paragraph_no_27": {"text": "4.3.1 the select-from-where structure\nof basic sol queries\nqueries in sql can be very complex. we will start with simple queries, and then", "entities": ["sql", "select"]}, "paragraph_no_28": {"text": "progress to more complex ones in a step-by-step manner. the basic form of the\nselect statement, sometimes called a mapping or a select-from-where block, is", "entities": ["select"]}, "paragraph_no_29": {"text": "97\n\f\n=== page 127 ===\n98", "entities": []}, "paragraph_no_30": {"text": "chapter 4 basic sql", "entities": ["sql"]}, "paragraph_no_31": {"text": "formed of the three clauses select, from, and where and has the following\nform:?", "entities": ["select"]}, "paragraph_no_32": {"text": "select <attribute list>\nfrom <table list>\nwhere <condition>;", "entities": ["select"]}, "paragraph_no_33": {"text": "where", "entities": []}, "paragraph_no_34": {"text": "m <attribute list> is a list of attribute names whose values are to be retrieved by\nthe query.\nm <table list> is a list of the relation names required to process the query.", "entities": []}, "paragraph_no_35": {"text": "= <condition> is a conditional (boolean) expression that identifies the tuples\nto be retrieved by the query.", "entities": []}, "paragraph_no_36": {"text": "in sql, the basic logical comparison operators for comparing attribute values with\none another and with literal constants are =, <, <=, >, >=, and <>. these corre-\nspond to the relational algebra operators =, <, <, >, 2, and 4, respectively, and to the\nc/c++ programming language operators =, <, <=, >, >=, and !=. the main syntac-\ntic difference is the not equal operator. sql has additional comparison operators\nthat we will present gradually.", "entities": ["sql"]}, "paragraph_no_37": {"text": "we illustrate the basic select statement in sql with some sample queries. the\nqueries are labeled here with the same query numbers used in chapter 6 for easy\ncross-reference.", "entities": ["sql", "select"]}, "paragraph_no_38": {"text": "query 0. retrieve the birth date and address of the employee(s) whose name\nis \u2018john b. smith\u2019.", "entities": []}, "paragraph_no_39": {"text": "qo: select bdate, address\nfrom employee\nwhere fname=john\u2019 and minit=\u201cb\u2019 and lname=\u2018smith\u2019;;", "entities": ["select"]}, "paragraph_no_40": {"text": "this query involves only the employee relation listed in the from clause. the\nquery selects the individual employee tuples that satisfy the condition of the\nwhere clause, then projects the result on the bdate and address attributes listed in\nthe select clause.", "entities": ["select"]}, "paragraph_no_41": {"text": "the select clause of sql specifies the attributes whose values are to be retrieved,\nwhich are called the projection attributes, and the where clause specifies the\nboolean condition that must be true for any retrieved tuple, which is known as the\nselection condition. figure 4.3(a) shows the result of query qo on the database of\nfigure 3.6.", "entities": ["sql", "select"]}}