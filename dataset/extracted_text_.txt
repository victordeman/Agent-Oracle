
=== Page 116 ===
Z
chapter I

Basic SQL

‘Ti SQL language may be considered one of the
major reasons for the commercial success of rela-
tional databases. Because it became a standard for relational databases, users were
less concerned about migrating their database applications from other types of
database systems—for example, network or hierarchical systems—to relational sys-
tems. This is because even if the users became dissatisfied with the particular rela-
tional DBMS product they were using, converting to another relational DBMS
product was not expected to be too expensive and time-consuming because both
systems followed the same language standards. In practice, of course, there are many
differences between various commercial relational DBMS packages. However, if the
user is diligent in using only those features that are part of the standard, and if both
relational systems faithfully support the standard, then conversion between the two
systems should be much simplified. Another advantage of having such a standard is
that users may write statements in a database application program that can access
data stored in two or more relational DBMSs without having to change the database
sublanguage (SQL) if both relational DBMSs support standard SQL.

This chapter presents the main features of the SQL standard for commercial rela-
tional DBMSs, whereas Chapter 3 presented the most important concepts underly-
ing the formal relational data model. In Chapter 6 (Sections 6.1 through 6.5) we
shall discuss the relational algebra operations, which are very important for under-
standing the types of requests that may be specified on a relational database. They
are also important for query processing and optimization in a relational DBMS, as
we shall see in Chapter 19. However, the relational algebra operations are consid-
ered to be too technical for most commercial DBMS users because a query in rela-
tional algebra is written as a sequence of operations that, when executed, produces
the required result. Hence, the user must specify how—that is, in what order—to
execute the query operations. On the other hand, the SQL language provides a

87

=== Page 117 ===
88

Chapter 4 Basic SOL

higher-level declarative language interface, so the user only specifies what the result
is to be, leaving the actual optimization and decisions on how to execute the query
to the DBMS. Although SQL includes some features from relational algebra, it is
based to a greater extent on the tuple relational calculus, which we describe in
Section 6.6. However, the SQL syntax is more user-friendly than either of the two
formal languages.

The name SQL is presently expanded as Structured Query Language. Originally,
SQL was called SEQUEL (Structured English QUEry Language) and was designed
and implemented at IBM Research as the interface for an experimental relational
database system called SYSTEM R. SQL is now the standard language for commer-
cial relational DBMSs. A joint effort by the American National Standards Institute
(ANSI) and the International Standards Organization (ISO) has led to a standard
version of SQL (ANSI 1986), called SQL-86 or SQL1. A revised and much expanded
standard called SQL-92 (also referred to as SQL2) was subsequently developed. The
next standard that is well-recognized is SQL:1999, which started out as SQL3. Two
later updates to the standard are SQL:2003 and SQL:2006, which added XML fea-
tures (see Chapter 12) among other updates to the language. Another update in
2008 incorporated more object database features in SQL (see Chapter 11). We will
try to cover the latest version of SQL as much as possible.

SQL is a comprehensive database language: It has statements for data definitions,
queries, and updates. Hence, it is both a DDL and a DML. In addition, it has facili-
ties for defining views on the database, for specifying security and authorization, for
defining integrity constraints, and for specifying transaction controls. It also has
rules for embedding SQL statements into a general-purpose programming language
such as Java, COBOL, or C/C++.!

The later SQL standards (starting with SQL:1999) are divided into a core specifica-
tion plus specialized extensions. The core is supposed to be implemented by all
RDBMS vendors that are SQL compliant. The extensions can be implemented as
optional modules to be purchased independently for specific database applications
such as data mining, spatial data, temporal data, data warehousing, online analytical
processing (OLAP), multimedia data, and so on.

Because SQL is very important (and quite large), we devote two chapters to its fea-
tures. In this chapter, Section 4.1 describes the SQL DDL commands for creating
schemas and tables, and gives an overview of the basic data types in SQL. Section 4.2
presents how basic constraints such as key and referential integrity are specified.
Section 4.3 describes the basic SQL constructs for specifying retrieval queries, and
Section 4.4 describes the SQL commands for insertion, deletion, and data updates.

In Chapter 5, we will describe more complex SQL retrieval queries, as well as the
ALTER commands for changing the schema. We will also describe the CREATE
ASSERTION statement, which allows the specification of more general constraints
on the database. We also introduce the concept of triggers, which is presented in

 

‘Originally, SOL had statements for creating and dropping indexes on the files that represent relations,
but these have been dropped from the SQL standard for some time.

=== Page 118 ===
4.1 SQL Data Definition and Data Types

more detail in Chapter 26 and we will describe the SQL facility for defining views on
the database in Chapter 5. Views are also called virtual or derived tables because they
present the user with what appear to be tables; however, the information in those
tables is derived from previously defined tables.

Section 4.5 lists some SQL features that are presented in other chapters of the book;
these include transaction control in Chapter 21, security/authorization in Chapter
24, active databases (triggers) in Chapter 26, object-oriented features in Chapter 11,
and online analytical processing (OLAP) features in Chapter 29. Section 4.6 sum-
marizes the chapter. Chapters 13 and 14 discuss the various database programming
techniques for programming with SQL.

4.1 SQL Data Definition and Data Types

SQL uses the terms table, row, and column for the formal relational model terms
relation, tuple, and attribute, respectively. We will use the corresponding terms inter-
changeably. The main SQL command for data definition is the CREATE statement,
which can be used to create schemas, tables (relations), and domains (as well as
other constructs such as views, assertions, and triggers). Before we describe the rel-
evant CREATE statements, we discuss schema and catalog concepts in Section 4.1.1
to place our discussion in perspective. Section 4.1.2 describes how tables are created,
and Section 4.1.3 describes the most important data types available for attribute
specification. Because the SQL specification is very large, we give a description of
the most important features. Further details can be found in the various SQL stan-
dards documents (see end-of-chapter bibliographic notes).

4.1.1 Schema and Catalog Concepts in SQL

Early versions of SQL did not include the concept of a relational database schema; all
tables (relations) were considered part of the same schema. The concept of an SQL
schema was incorporated starting with SQL2 in order to group together tables and
other constructs that belong to the same database application. An SQL schema is
identified by a schema name, and includes an authorization identifier to indicate
the user or account who owns the schema, as well as descriptors for each element in
the schema. Schema elements include tables, constraints, views, domains, and other
constructs (such as authorization grants) that describe the schema. A schema is cre-
ated via the CREATE SCHEMA statement, which can include all the schema elements’
definitions. Alternatively, the schema can be assigned a name and authorization
identifier, and the elements can be defined later. For example, the following state-
ment creates a schema called COMPANY, owned by the user with authorization iden-
tifier ‘smith. Note that each statement in SQL ends with a semicolon.

CREATE SCHEMA COMPANY AUTHORIZATION ‘Jsmith’;

In general, not all users are authorized to create schemas and schema elements. The
privilege to create schemas, tables, and other constructs must be explicitly granted
to the relevant user accounts by the system administrator or DBA.

89

=== Page 119 ===
90

Chapter 4 Basic SOL

In addition to the concept of a schema, SQL uses the concept of a catalog—a named
collection of schemas in an SQL environment. An SQL environment is basically an
installation of an SQL-compliant RDBMS on a computer system.” A catalog always
contains a special schema called INFORMATION_SCHEMA, which provides informa-
tion on all the schemas in the catalog and all the element descriptors in these
schemas. Integrity constraints such as referential integrity can be defined between
relations only if they exist in schemas within the same catalog. Schemas within the
same catalog can also share certain elements, such as domain definitions.

4.1.2 The CREATE TABLE Command in SQL

The CREATE TABLE command is used to specify a new relation by giving it a name
and specifying its attributes and initial constraints. The attributes are specified first,
and each attribute is given a name, a data type to specify its domain of values, and
any attribute constraints, such as NOT NULL. The key, entity integrity, and referen-
tial integrity constraints can be specified within the CREATE TABLE statement after
the attributes are declared, or they can be added later using the ALTER TABLE com-
mand (see Chapter 5). Figure 4.1 shows sample data definition statements in SQL
for the COMPANY relational database schema shown in Figure 3.7.

Typically, the SQL schema in which the relations are declared is implicitly specified
in the environment in which the CREATE TABLE statements are executed.
Alternatively, we can explicitly attach the schema name to the relation name, sepa-
rated by a period. For example, by writing

CREATE TABLE COMPANY.EMPLOYEE ...
rather than
CREATE TABLE EMPLOYEE ...

as in Figure 4.1, we can explicitly (rather than implicitly) make the EMPLOYEE table
part of the COMPANY schema.

The relations declared through CREATE TABLE statements are called base tables (or
base relations); this means that the relation and its tuples are actually created and
stored as a file by the DBMS. Base relations are distinguished from virtual relations,
created through the CREATE VIEW statement (see Chapter 5), which may or may
not correspond to an actual physical file. In SQL, the attributes in a base table are
considered to be ordered in the sequence in which they are specified in the CREATE
TABLE statement. However, rows (tuples) are not considered to be ordered within a
relation.

It is important to note that in Figure 4.1, there are some foreign keys that may cause
errors because they are specified either via circular references or because they refer
to a table that has not yet been created. For example, the foreign key Super_ssn in
the EMPLOYEE table is a circular reference because it refers to the table itself. The
foreign key Dno in the EMPLOYEE table refers to the DEPARTMENT table, which has

 

2SQL also includes the concept of a cluster of catalogs within an environment.

=== Page 120 ===
4.1 SQL Data Definition and Data Types 91

 

CREATE TABLE EMPLOYEE

( Fname
Minit
Lname
Ssn
Bdate
Address
Sex
Salary
Super_ssn
Dno

VARCHAR(15)
CHAR,
VARCHAR(15)
CHAR(Q)

DATE,
VARCHAR(30),
CHAR,
DECIMAL(10,2),
CHAR(Q),

INT NOT NULL,

NOT NULL,

NOT NULL,
NOT NULL,

Figure 4.1

SQL CREATE TABLE
data definition state-
ments for defining the
COMPANY schema
from Figure 3.7.

PRIMARY KEY (Ssn),

FOREIGN KEY (Super_ssn) REFERENCES EMPLOYEE(Ssn),

FOREIGN KEY (Dno) REFERENCES DEPARTMENT(Dnumber) );
CREATE TABLE DEPARTMENT

( Dname VARCHAR(15) NOT NULL,
Dnumber INT NOT NULL,
Mgr_ssn CHAR(Q) NOT NULL,
Mgr_start_date DATE,

PRIMARY KEY (Dnumber),

UNIQUE (Dname),

FOREIGN KEY (Mgr_ssn) REFERENCES EMPLOYEE(Ssn) );
CREATE TABLE DEPT_LOCATIONS

( Dnumber INT

Dlocation VARCHAR(15)

PRIMARY KEY (Dnumber, Dlocation),

FOREIGN KEY (Dnumber) REFERENCES DEPARTMENT(Dnumber) );
CREATE TABLE PROJECT

NOT NULL,
NOT NULL,

( Pname VARCHAR(15) NOT NULL,
Pnumber INT NOT NULL,
Plocation VARCHAR(15),

Dnum INT NOT NULL,

PRIMARY KEY (Pnumber),

UNIQUE (Pname),

FOREIGN KEY (Dnum) REFERENCES DEPARTMENT(Dnumber) );
CREATE TABLE WORKS_ON

( Essn CHAR(Q) NOT NULL,
Pno INT NOT NULL,
Hours DECIMAL(3,1) NOT NULL,

PRIMARY KEY (Essn, Pno),

FOREIGN KEY (Essn) REFERENCES EMPLOYEE(Ssn),

FOREIGN KEY (Pno) REFERENCES PROJECT(Pnumber) );
CREATE TABLE DEPENDENT

( Essn CHAR(Q) NOT NULL,
Dependent_name VARCHAR(15) NOT NULL,
Sex CHAR,

Bdate DATE,
Relationship VARCHAR(8),

PRIMARY KEY (Essn, Dependent_name),
FOREIGN KEY (Essn) REFERENCES EMPLOYEE(Ssn) );

=== Page 121 ===
92

Chapter 4 Basic SOL

not been created yet. To deal with this type of problem, these constraints can be left
out of the initial CREATE TABLE statement, and then added later using the ALTER
TABLE statement (see Chapter 5). We displayed all the foreign keys in Figure 4.1 to
show the complete COMPANY schema in one place.

4.1.3 Attribute Data Types and Domains in SQL

The basic data types available for attributes include numeric, character string, bit
string, Boolean, date, and time.

m= Numeric data types include integer numbers of various sizes (INTEGER or
INT, and SMALLINT) and floating-point (real) numbers of various precision
(FLOAT or REAL, and DOUBLE PRECISION). Formatted numbers can be
declared by using DECIMAL (i,j) —or DEC(i,j) or NUMERIC(i,j)—-where i, the
precision, is the total number of decimal digits and j, the scale, is the number
of digits after the decimal point. The default for scale is zero, and the default
for precision is implementation-defined.

= Character-string data types are either fixed length—CHAR(n) or
CHARACTER(n), where n is the number of characters—or varying length—
VARCHAR(n) or CHAR VARYING(1) or CHARACTER VARYING(n), where 71 is
the maximum number of characters. When specifying a literal string value, it
is placed between single quotation marks (apostrophes), and it is case sensi-
tive (a distinction is made between uppercase and lowercase).* For fixed-
length strings, a shorter string is padded with blank characters to the right.
For example, if the value ‘Smith’ is for an attribute of type CHAR(10), it is
padded with five blank characters to become ‘Smith ” if needed. Padded
blanks are generally ignored when strings are compared. For comparison
purposes, strings are considered ordered in alphabetic (or lexicographic)
order; if a string str] appears before another string str2 in alphabetic order,
then str1 is considered to be less than str2.‘ There is also a concatenation
operator denoted by || (double vertical bar) that can concatenate two strings
in SQL. For example, ‘abc’ || “XYZ’ results in a single string ‘abcXYZ* Another
variable-length string data type called CHARACTER LARGE OBJECT or
CLOB is also available to specify columns that have large text values, such as
documents. The CLOB maximum length can be specified in kilobytes (K),
megabytes (M), or gigabytes (G). For example, CLOB(20M) specifies a max-
imum length of 20 megabytes.

 

 

= Bit-string data types are either of fixed length n—BIT(n)—or varying
length—BIT VARYING(7), where n is the maximum number of bits. The
default for n, the length of a character string or bit string, is 1. Literal bit
strings are placed between single quotes but preceded by a B to distinguish

 

SThis is not the case with SOL keywords, such as CREATE or CHAR. With keywords, SQL is case insen-
sitive, meaning that SQL treats uppercase and lowercase letters as equivalent in keywords.

“For nonalphabetic characters, there is a defined order.

=== Page 122 ===
4.1 SQL Data Definition and Data Types 93

them from character strings; for example, B‘10101”° Another variable-length
bitstring data type called BINARY LARGE OBJECT or BLOB is also available
to specify columns that have large binary values, such as images. As for
CLOB, the maximum length of a BLOB can be specified in kilobits (K),
megabits (M), or gigabits (G). For example, BLOB(30G) specifies a maxi-
mum length of 30 gigabits.

= A Boolean data type has the traditional values of TRUE or FALSE. In SQL,
because of the presence of NULL values, a three-valued logic is used, so a
third possible value for a Boolean data type is UNKNOWN. We discuss the
need for UNKNOWN and the three-valued logic in Chapter 5.

= The DATE data type has ten positions, and its components are YEAR,
MONTH, and DAY in the form YYYY-MM-DD. The TIME data type has at
least eight positions, with the components HOUR, MINUTE, and SECOND in
the form HH:MM:SS. Only valid dates and times should be allowed by the
SQL implementation. This implies that months should be between 1 and 12
and dates must be between 1 and 31; furthermore, a date should be a valid
date for the corresponding month. The < (less than) comparison can be used
with dates or times—an earlier date is considered to be smaller than a later
date, and similarly with time. Literal values are represented by single-quoted
strings preceded by the keyword DATE or TIME; for example, DATE ‘2008-09-
27 or TIME ‘09:12:47° In addition, a data type TIME(z), where 7 is called time
fractional seconds precision, specifies i + 1 additional positions for TIME—one
position for an additional period (.) separator character, and i positions for
specifying decimal fractions of a second. A TIME WITH TIME ZONE data type
includes an additional six positions for specifying the displacement from the
standard universal time zone, which is in the range +13:00 to —12:59 in units
of HOURS:MINUTES. If WITH TIME ZONE is not included, the default is the
local time zone for the SQL session.

Some additional data types are discussed below. The list of types discussed here is
not exhaustive; different implementations have added more data types to SQL.

= A timestamp data type (TIMESTAMP) includes the DATE and TIME fields,
plus a minimum of six positions for decimal fractions of seconds and an
optional WITH TIME ZONE qualifier. Literal values are represented by single-
quoted strings preceded by the keyword TIMESTAMP, with a blank space
between data and time; for example, TIMESTAMP ‘2008-09-27
09:12:47.648302’.

m Another data type related to DATE, TIME, and TIMESTAMP is the INTERVAL
data type. This specifies an interval—a relative value that can be used to
increment or decrement an absolute value of a date, time, or timestamp.
Intervals are qualified to be either YEAR/MONTH intervals or DAY/TIME
intervals.

 

5Bit strings whose length is a multiple of 4 can be specified in hexadecimal notation, where the literal
string is preceded by X and each hexadecimal character represents 4 bits.

=== Page 123 ===
94

Chapter 4 Basic SOL

The format of DATE, TIME, and TIMESTAMP can be considered as a special type of
string. Hence, they can generally be used in string comparisons by being cast (or
coerced or converted) into the equivalent strings.

It is possible to specify the data type of each attribute directly, as in Figure 4.1; alter-
natively, a domain can be declared, and the domain name used with the attribute
specification. This makes it easier to change the data type for a domain that is used
by numerous attributes in a schema, and improves schema readability. For example,
we can create a domain SSN_TYPE by the following statement:

CREATE DOMAIN SSN_TYPE AS CHAR(Q);

We can use SSN_TYPE in place of CHAR(9) in Figure 4.1 for the attributes Ssn and
Super_ssn of EMPLOYEE, Mgr_ssn of DEPARTMENT, Essn of WORKS_ON, and Essn
of DEPENDENT. A domain can also have an optional default specification via a
DEFAULT clause, as we discuss later for attributes. Notice that domains may not be
available in some implementations of SQL.

4.2 Specifying Constraints in SQL

This section describes the basic constraints that can be specified in SQL as part of
table creation. These include key and referential integrity constraints, restrictions
on attribute domains and NULLs, and constraints on individual tuples within a rela-
tion. We discuss the specification of more general constraints, called assertions, in
Chapter 5.

4.2.1 Specifying Attribute Constraints and Attribute Defaults

Because SQL allows NULLs as attribute values, a constraint NOT NULL may be speci-
fied if NULL is not permitted for a particular attribute. This is always implicitly spec-
ified for the attributes that are part of the primary key of each relation, but it can be
specified for any other attributes whose values are required not to be NULL, as
shown in Figure 4.1.

It is also possible to define a default value for an attribute by appending the clause
DEFAULT <value> to an attribute definition. The default value is included in any
new tuple if an explicit value is not provided for that attribute. Figure 4.2 illustrates
an example of specifying a default manager for a new department and a default
department for a new employee. If no default clause is specified, the default default
value is NULL for attributes that do not have the NOT NULL constraint.

Another type of constraint can restrict attribute or domain values using the CHECK
clause following an attribute or domain definition.® For example, suppose that
department numbers are restricted to integer numbers between | and 20; then, we
can change the attribute declaration of Dnumber in the DEPARTMENT table (see
Figure 4.1) to the following:

Dnumber INT NOT NULL CHECK (Dnumber > 0 AND Dnumber < 21);

 

6The CHECK clause can also be used for other purposes, as we shall see.

=== Page 124 ===
4.2 Specifying Constraints in SQL 95

CREATE TABLE EMPLOYEE
(oe,
Dno INT NOT NULL DEFAULT 1,
CONSTRAINT EMPPK
PRIMARY KEY (Ssn),
CONSTRAINT EMPSUPERFK
FOREIGN KEY (Super_ssn) REFERENCES EMPLOYEE(Ssn)
ON DELETE SET NULL ON UPDATE CASCADE,
CONSTRAINT EMPDEPTFK
FOREIGN KEY(Dno) REFERENCES DEPARTMENT(Dnumber)
ON DELETE SET DEFAULT ON UPDATE CASCADE);
CREATE TABLE DEPARTMENT
(oe,
Mgr_ssn CHAR(9) NOT NULL DEFAULT ‘888665555’,

CONSTRAINT DEPTPK
PRIMARY KEY(Dnumber),

CONSTRAINT DEPTSK
UNIQUE (Dname),

CONSTRAINT DEPTMGRFK

FOREIGN KEY (Mgr_ssn) REFERENCES EMPLOYEE(Ssn) Figure 4.2
ON DELETE SET DEFAULT ON UPDATE CASCADE); Example illustrating
CREATE TABLE DEPT_LOCATIONS how default attribute
(a values and referential
PRIMARY KEY (Dnumber, Dlocation), integrity triggered
FOREIGN KEY (Dnumber) REFERENCES DEPARTMENT(Dnumber) actions are specified
ON DELETE CASCADE ON UPDATE CASCADE); in SQL.

 

The CHECK clause can also be used in conjunction with the CREATE DOMAIN state-
ment. For example, we can write the following statement:

CREATE DOMAIN D_NUM AS INTEGER
CHECK (D_NUM > 0 AND D_NUM < 21);

We can then use the created domain D_NUM as the attribute type for all attributes
that refer to department numbers in Figure 4.1, such as Dnumber of DEPARTMENT,
Dnum of PROJECT, Dno of EMPLOYEE, and so on.

4.2.2 Specifying Key and Referential Integrity Constraints

Because keys and referential integrity constraints are very important, there are spe-
cial clauses within the CREATE TABLE statement to specify them. Some examples to
illustrate the specification of keys and referential integrity are shown in Figure 4.1.7
The PRIMARY KEY clause specifies one or more attributes that make up the primary
key of a relation. If a primary key has a single attribute, the clause can follow the
attribute directly. For example, the primary key of DEPARTMENT can be specified as
follows (instead of the way it is specified in Figure 4.1):

Dnumber INT PRIMARY KEY;

7Key and referential integrity constraints were not included in early versions of SQL. In some earlier
implementations, keys were specified implicitly at the internal level via the CREATE INDEX command.

=== Page 125 ===
96

Chapter 4 Basic SOL

The UNIQUE clause specifies alternate (secondary) keys, as illustrated in the
DEPARTMENT and PROJECT table declarations in Figure 4.1. The UNIQUE clause
can also be specified directly for a secondary key if the secondary key is a single
attribute, as in the following example:

Dname VARCHAR(15) UNIQUE;

Referential integrity is specified via the FOREIGN KEY clause, as shown in Figure
4.1. As we discussed in Section 3.2.4, a referential integrity constraint can be vio-
lated when tuples are inserted or deleted, or when a foreign key or primary key
attribute value is modified. The default action that SQL takes for an integrity viola-
tion is to reject the update operation that will cause a violation, which is known as
the RESTRICT option. However, the schema designer can specify an alternative
action to be taken by attaching a referential triggered action clause to any foreign
key constraint. The options include SET NULL, CASCADE, and SET DEFAULT. An
option must be qualified with either ON DELETE or ON UPDATE. We illustrate this
with the examples shown in Figure 4.2. Here, the database designer chooses ON
DELETE SET NULL and ON UPDATE CASCADE for the foreign key Super_ssn of
EMPLOYEE. This means that if the tuple for a supervising employee is deleted, the
value of Super_ssn is automatically set to NULL for all employee tuples that were ref-
erencing the deleted employee tuple. On the other hand, if the Ssn value for a super-
vising employee is updated (say, because it was entered incorrectly), the new value is
cascaded to Super_ssn for all employee tuples referencing the updated employee
tuple.®

In general, the action taken by the DBMS for SET NULL or SET DEFAULT is the same
for both ON DELETE and ON UPDATE: The value of the affected referencing attrib-
utes is changed to NULL for SET NULL and to the specified default value of the refer-
encing attribute for SET DEFAULT. The action for CASCADE ON DELETE is to delete
all the referencing tuples, whereas the action for CASCADE ON UPDATE is to change
the value of the referencing foreign key attribute(s) to the updated (new) primary
key value for all the referencing tuples. It is the responsibility of the database
designer to choose the appropriate action and to specify it in the database schema.
As a general rule, the CASCADE option is suitable for “relationship” relations (see
Section 9.1), such as WORKS_ON; for relations that represent multivalued attrib-
utes, such as DEPT_LOCATIONS; and for relations that represent weak entity types,
such as DEPENDENT.

4.2.3. Giving Names to Constraints

Figure 4.2 also illustrates how a constraint may be given a constraint name, follow-
ing the keyword CONSTRAINT. The names of all constraints within a particular
schema must be unique. A constraint name is used to identify a particular con-

 

8Notice that the foreign key Super_ssn in the EMPLOYEE table is a circular reference and hence may
have to be added later as a named constraint using the ALTER TABLE statement as we discussed at the
end of Section 4.1.2.

=== Page 126 ===
4.3 Basic Retrieval Queries in SQL

straint in case the constraint must be dropped later and replaced with another con-
straint, as we discuss in Chapter 5. Giving names to constraints is optional.

4.2.4 Specifying Constraints on Tuples Using CHECK

In addition to key and referential integrity constraints, which are specified by spe-
cial keywords, other table constraints can be specified through additional CHECK
clauses at the end of a CREATE TABLE statement. These can be called tuple-based
constraints because they apply to each tuple individually and are checked whenever
a tuple is inserted or modified. For example, suppose that the DEPARTMENT table in
Figure 4.1 had an additional attribute Dept_create_date, which stores the date when
the department was created. Then we could add the following CHECK clause at the
end of the CREATE TABLE statement for the DEPARTMENT table to make sure that a
manager’s start date is later than the department creation date.

CHECK (Dept_create_date <= Mgr_start_date);

The CHECK clause can also be used to specify more general constraints using the
CREATE ASSERTION statement of SQL. We discuss this in Chapter 5 because it
requires the full power of queries, which are discussed in Sections 4.3 and 5.1.

4.3 Basic Retrieval Queries in SQL

SQL has one basic statement for retrieving information from a database: the
SELECT statement. The SELECT statement is not the same as the SELECT operation
of relational algebra, which we discuss in Chapter 6. There are many options and
flavors to the SELECT statement in SQL, so we will introduce its features gradually.
We will use sample queries specified on the schema of Figure 3.5 and will refer to
the sample database state shown in Figure 3.6 to show the results of some of the
sample queries. In this section, we present the features of SQL for simple retrieval
queries. Features of SQL for specifying more complex retrieval queries are presented
in Section 5.1.

Before proceeding, we must point out an important distinction between SQL and the
formal relational model discussed in Chapter 3: SQL allows a table (relation) to
have two or more tuples that are identical in all their attribute values. Hence, in gen-
eral, an SQL table is not a set of tuples, because a set does not allow two identical
members; rather, it is a multiset (sometimes called a bag) of tuples. Some SQL rela-
tions are constrained to be sets because a key constraint has been declared or because
the DISTINCT option has been used with the SELECT statement (described later in
this section). We should be aware of this distinction as we discuss the examples.

4.3.1 The SELECT-FROM-WHERE Structure
of Basic SOL Queries
Queries in SQL can be very complex. We will start with simple queries, and then

progress to more complex ones in a step-by-step manner. The basic form of the
SELECT statement, sometimes called a mapping or a select-from-where block, is

97

=== Page 127 ===
98

Chapter 4 Basic SQL

formed of the three clauses SELECT, FROM, and WHERE and has the following
form:?

SELECT <attribute list>
FROM <table list>
WHERE <condition>;

where

m <attribute list> is a list of attribute names whose values are to be retrieved by
the query.
m <table list> is a list of the relation names required to process the query.

= <condition> is a conditional (Boolean) expression that identifies the tuples
to be retrieved by the query.

In SQL, the basic logical comparison operators for comparing attribute values with
one another and with literal constants are =, <, <=, >, >=, and <>. These corre-
spond to the relational algebra operators =, <, <, >, 2, and 4, respectively, and to the
C/C++ programming language operators =, <, <=, >, >=, and !=. The main syntac-
tic difference is the not equal operator. SQL has additional comparison operators
that we will present gradually.

We illustrate the basic SELECT statement in SQL with some sample queries. The
queries are labeled here with the same query numbers used in Chapter 6 for easy
cross-reference.

Query 0. Retrieve the birth date and address of the employee(s) whose name
is ‘John B. Smith’.

Qo: SELECT Bdate, Address
FROM EMPLOYEE
WHERE Fname=John’ AND Minit=“B’ AND Lname=‘Smith’;;

This query involves only the EMPLOYEE relation listed in the FROM clause. The
query selects the individual EMPLOYEE tuples that satisfy the condition of the
WHERE clause, then projects the result on the Bdate and Address attributes listed in
the SELECT clause.

The SELECT clause of SQL specifies the attributes whose values are to be retrieved,
which are called the projection attributes, and the WHERE clause specifies the
Boolean condition that must be true for any retrieved tuple, which is known as the
selection condition. Figure 4.3(a) shows the result of query QO on the database of
Figure 3.6.

We can think of an implicit tuple variable or iterator in the SQL query ranging or
looping over each individual tuple in the EMPLOYEE table and evaluating the condi-
tion in the WHERE clause. Only those tuples that satisfy the condition—that is,

 

°The SELECT and FROM clauses are required in all SQL queries. The WHERE is optional (see Section
4.3.3).

=== Page 128 ===
4.3 Basic Retrieval Queries in SQL 99

Figure 4.3
Results of SQL queries when applied to the COMPANY database state shown
in Figure 3.6. (a) QO. (b) Q1. (c) Q2. (d) AB. (e) AY. (f) Q10. (g) AIC.

 

 

(a) Bdate | Address (b) | Fname Lname Address
1965-01-09 | 731 Fondren, Houston, TX John Smith 731 Fondren, Houston, TX
Franklin Wong 638 Voss, Houston, TX
Ramesh | Narayan | 975 Fire Oak, Humble, TX
Joyce English | 5631 Rice, Houston, TX

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

(c) | Pnumber Dnum Lname Address Bdate (f) Ssn Dname
10 4 Wallace | 291Berry, Bellaire, TX | 1941-06-20 123456789 Research
30 4 Wallace | 291Berry, Bellaire, TX | 1941-06-20 333445555 Research
999887777 Research
987654321 Research
(d) | E.Fname E.Lname S.Fname S.Lname
666884444 Research
John Smith Franklin Wong
453453453 Research
Franklin Wong James Borg
987987987 Research
Alicia Zelaya Jennifer Wallace
- 888665555 Research
Jennifer Wallace James Borg Ss"
Ramesh Narayan Franklin Wong 123456789 Administration
333445555 + | Administrati
Joyce English Franklin Wong ministration
999887777 Administrati
Ahmad Jabbar Jennifer Wallace ministration
987654321 Administration
666884444 | Administration
(e) E.Fname 453453453 Administration
123456789 987987987 Administration
333445555 888665555 | Administration
999887777 123456789 Headquarters
987654321 333445555 | Headquarters
666884444 999887777 Headquarters
453453453 987654321 Headquarters
987987987 666884444 | Headquarters
888665555
453453453 Headquarters
987987987 Headquarters
888665555 Headquarters
(g)
Fname Minit | Lname Ssn Bdate Address Sex | Salary | Super_ssn |Dno
John B Smith 123456789 |1965-09-01 | 731 Fondren, Houston, TX | M |30000 |333445555 | 5
Franklin T Wong 333445555 |1955-12-08 | 638 Voss, Houston, TX M_ |40000 |}888665555 | 5
Ramesh | K Narayan | 666884444 |1962-09-15 | 975 Fire Oak, Humble, TX | M_ |38000 | 333445555 | 5
Joyce A English | 453453453 |1972-07-31 | 5631 Rice, Houston, TX F |25000 |333445555 | 5

 

 

 

 

 

 

 

 

 

 

 

 

=== Page 129 ===
100

Chapter 4 Basic SOL

those tuples for which the condition evaluates to TRUE after substituting their cor-
responding attribute values—are selected.

Query 1. Retrieve the name and address of all employees who work for the
‘Research’ department.

Qi: SELECT Fname, Lname, Address
FROM EMPLOYEE, DEPARTMENT
WHERE Dname=‘Research’ AND Dnumber=Dno;

In the WHERE clause of Q1, the condition Dname = ‘Research’ is a selection condi-
tion that chooses the particular tuple of interest in the DEPARTMENT table, because
Dname is an attribute of DEPARTMENT. The condition Dnumber = Dno is called a
join condition, because it combines two tuples: one from DEPARTMENT and one
from EMPLOYEE, whenever the value of Dnumber in DEPARTMENT is equal to the
value of Dno in EMPLOYEE. The result of query Q1 is shown in Figure 4.3(b). In
general, any number of selection and join conditions may be specified in a single
SQL query.

A query that involves only selection and join conditions plus projection attributes is
known as a select-project-join query. The next example is a select-project-join
query with two join conditions.

Query 2. For every project located in ‘Stafford’, list the project number, the
controlling department number, and the department manager’s last name,
address, and birth date.

Q2: SELECT Pnumber, Dnum, Lname, Address, Bdate
FROM PROJECT, DEPARTMENT, EMPLOYEE
WHERE Dnum=Dnumber AND Mgr_ssn=Ssn AND

Plocation= ‘Stafford’;

The join condition Dnum = Dnumber relates a project tuple to its controlling depart-
ment tuple, whereas the join condition Mgr_ssn = Ssn relates the controlling depart-
ment tuple to the employee tuple who manages that department. Each tuple in the
result will be a combination of one project, one department, and one employee that
satisfies the join conditions. The projection attributes are used to choose the attrib-
utes to be displayed from each combined tuple. The result of query Q2 is shown in
Figure 4.3(c).

4.3.2 Ambiguous Attribute Names, Aliasing,
Renaming, and Tuple Variables

In SQL, the same name can be used for two (or more) attributes as long as the attrib-
utes are in different relations. If this is the case, and a multitable query refers to two or
more attributes with the same name, we must qualify the attribute name with the
relation name to prevent ambiguity. This is done by prefixing the relation name to
the attribute name and separating the two by a period. To illustrate this, suppose that
in Figures 3.5 and 3.6 the Dno and Lname attributes of the EMPLOYEE relation were

=== Page 130 ===
4.3 Basic Retrieval Queries in SQL

called Dnumber and Name, and the Dname attribute of DEPARTMENT was also called
Name; then, to prevent ambiguity, query Q1 would be rephrased as shown in Q1A. We
must prefix the attributes Name and Dnumber in Q1A to specify which ones we are
referring to, because the same attribute names are used in both relations:

Q1A: SELECT Fname, EMPLOYEE.Name, Address
FROM EMPLOYEE, DEPARTMENT
WHERE DEPARTMENT.Name=‘Research’ AND
DEPARTMENT.Dnumber=EMPLOYEE.Dnumber;

Fully qualified attribute names can be used for clarity even if there is no ambiguity
in attribute names. Q1 is shown in this manner as is Q1’ below. We can also create
an alias for each table name to avoid repeated typing of long table names (see Q8
below).

Q1’: SELECT EMPLOYEE.Fname, EMPLOYEE.LName,
EMPLOYEE.Address
FROM EMPLOYEE, DEPARTMENT
WHERE DEPARTMENT.DName=‘Research’ AND
DEPARTMENT.Dnumber=EMPLOYEE.Dno;

The ambiguity of attribute names also arises in the case of queries that refer to the
same relation twice, as in the following example.

Query 8. For each employee, retrieve the employee’s first and last name and
the first and last name of his or her immediate supervisor.

Qs: SELECT E.Fname, E.Lname, S.Fname, S.Lname
FROM EMPLOYEE AS E, EMPLOYEE AS S
WHERE E.Super_ssn=S.Ssn;

In this case, we are required to declare alternative relation names E and §, called
aliases or tuple variables, for the EMPLOYEE relation. An alias can follow the key-
word AS, as shown in Q8, or it can directly follow the relation name—for example,
by writing EMPLOYEE E, EMPLOYEE S in the FROM clause of Q8. It is also possible
to rename the relation attributes within the query in SQL by giving them aliases.
For example, if we write

EMPLOYEE AS E(Fn, Mi, Ln, Ssn, Bd, Addr, Sex, Sal, Sssn, Dno)

in the FROM clause, Fn becomes an alias for Fname, Mi for Minit, Ln for Lname, and so
on.

In Q8, we can think of E and S as two different copies of the EMPLOYEE relation; the
first, E, represents employees in the role of supervisees or subordinates; the second,
S, represents employees in the role of supervisors. We can now join the two copies.
Of course, in reality there is only one EMPLOYEE relation, and the join condition is
meant to join the relation with itself by matching the tuples that satisfy the join con-
dition E.Super_ssn = S.Ssn. Notice that this is an example of a one-level recursive
query, as we will discuss in Section 6.4.2. In earlier versions of SQL, it was not pos-
sible to specify a general recursive query, with an unknown number of levels, in a

101

=== Page 131 ===
102

Chapter 4 Basic SOL

single SQL statement. A construct for specifying recursive queries has been incorpo-
rated into SQL:1999 (see Chapter 5).

The result of query Q8 is shown in Figure 4.3(d). Whenever one or more aliases are
given to a relation, we can use these names to represent different references to that
same relation. This permits multiple references to the same relation within a query.

We can use this alias-naming mechanism in any SQL query to specify tuple vari-
ables for every table in the WHERE clause, whether or not the same relation needs to
be referenced more than once. In fact, this practice is recommended since it results
in queries that are easier to comprehend. For example, we could specify query Q1 as
in Q1B:

Q1B: SELECT E.Fname, E.LName, E.Address
FROM EMPLOYEE E, DEPARTMENT D
WHERE D.DName=‘Research’ AND D.Dnumber=E.Dno;

4.3.3 Unspecified WHERE Clause
and Use of the Asterisk

We discuss two more features of SQL here. A missing WHERE clause indicates no
condition on tuple selection; hence, all tuples of the relation specified in the FROM
clause qualify and are selected for the query result. If more than one relation is spec-
ified in the FROM clause and there is no WHERE clause, then the CROSS
PRODUCT—all possible tuple combinations—of these relations is selected. For
example, Query 9 selects all EMPLOYEE Ssns (Figure 4.3(e)), and Query 10 selects
all combinations of an EMPLOYEE Ssn and a DEPARTMENT Dname, regardless of
whether the employee works for the department or not (Figure 4.3(f)).

Queries 9 and 10. Select all EMPLOYEE Ssns (QQ) and all combinations of
EMPLOYEE Ssn and DEPARTMENT Dname (Q10) in the database.

Qg: SELECT Ssn

FROM EMPLOYEE;
Q10: SELECT Ssn, Dname
FROM EMPLOYEE, DEPARTMENT;

It is extremely important to specify every selection and join condition in the
WHERE clause; if any such condition is overlooked, incorrect and very large rela-
tions may result. Notice that Q10 is similar to a CROSS PRODUCT operation fol-
lowed by a PROJECT operation in relational algebra (see Chapter 6). If we specify all
the attributes of EMPLOYEE and DEPARTMENT in Q10, we get the actual CROSS
PRODUCT (except for duplicate elimination, if any).

To retrieve all the attribute values of the selected tuples, we do not have to list the
attribute names explicitly in SQL; we just specify an asterisk (*), which stands for all
the attributes. For example, query Q1C retrieves all the attribute values of any
EMPLOYEE who works in DEPARTMENT number 5 (Figure 4.3(g)), query Q1D
retrieves all the attributes of an EMPLOYEE and the attributes of the DEPARTMENT in

=== Page 132 ===
4.3 Basic Retrieval Queries in SQL

which he or she works for every employee of the ‘Research’ department, and Q10A
specifies the CROSS PRODUCT of the EMPLOYEE and DEPARTMENT relations.

Qic: SELECT *
FROM EMPLOYEE
WHERE Dno=5;

Q1iD: SELECT *
FROM EMPLOYEE, DEPARTMENT
WHERE Dname=‘Research’ AND Dno=Dnumber;

Q10A: SELECT *
FROM EMPLOYEE, DEPARTMENT;

4.3.4 Tables as Sets in SQL

As we mentioned earlier, SQL usually treats a table not as a set but rather as a
multiset; duplicate tuples can appear more than once in a table, and in the result of a
query. SQL does not automatically eliminate duplicate tuples in the results of
queries, for the following reasons:

= Duplicate elimination is an expensive operation. One way to implement it is
to sort the tuples first and then eliminate duplicates.

m The user may want to see duplicate tuples in the result of a query.

m When an aggregate function (see Section 5.1.7) is applied to tuples, in most
cases we do not want to eliminate duplicates.

An SQL table with a key is restricted to being a set, since the key value must be dis-
tinct in each tuple.!° If we do want to eliminate duplicate tuples from the result of
an SQL query, we use the keyword DISTINCT in the SELECT clause, meaning that
only distinct tuples should remain in the result. In general, a query with SELECT
DISTINCT eliminates duplicates, whereas a query with SELECT ALL does not.
Specifying SELECT with neither ALL nor DISTINCT—as in our previous examples—
is equivalent to SELECT ALL. For example, Q11 retrieves the salary of every
employee; if several employees have the same salary, that salary value will appear as
many times in the result of the query, as shown in Figure 4.4(a). If we are interested
only in distinct salary values, we want each value to appear only once, regardless of
how many employees earn that salary. By using the keyword DISTINCT as in Q11A,
we accomplish this, as shown in Figure 4.4(b).

Query 11. Retrieve the salary of every employee (Q11) and all distinct salary
values (Q11A).

Qi1: SELECT ALL Salary
FROM EMPLOYEE;

Q11A: SELECT DISTINCT Salary
FROM EMPLOYEE;

 

'0In general, an SQL table is not required to have a key, although in most cases there will be one.

103

=== Page 133 ===
104 Chapter 4 Basic SQL

Figure 4.4

Results of additional
SQL queries when
applied to the COM-
PANY database state
shown in Figure 3.6.
(a) Q11. (b) Q1I1A.
(c) Q16. (d) Q18.

 

 

 

 

(a) | Salary (b) | Salary (c)
30000 30000
40000 40000
25000 25000
43000 43000
38000 38000 (d) | Fname
25000 55000 James

 

 

 

25000
55000

 

 

 

SQL has directly incorporated some of the set operations from mathematical set
theory, which are also part of relational algebra (see Chapter 6). There are set union
(UNION), set difference (EXCEPT),!! and set intersection (INTERSECT) operations.
The relations resulting from these set operations are sets of tuples; that is, duplicate
tuples are eliminated from the result. These set operations apply only to union-com-
patible relations, so we must make sure that the two relations on which we apply the
operation have the same attributes and that the attributes appear in the same order
in both relations. The next example illustrates the use of UNION.

Query 4. Make a list of all project numbers for projects that involve an
employee whose last name is ‘Smith, either as a worker or as a manager of the
department that controls the project.

Q4A: (SELECT DISTINCT Pnumber
FROM PROJECT, DEPARTMENT, EMPLOYEE
WHERE Dnum=Dnumber AND Mgr_ssn=Ssn
AND Lname=‘Smith’ )

UNION
( SELECT DISTINCT Pnumber
FROM PROJECT, WORKS_ON, EMPLOYEE

WHERE Pnumber=Pno AND Essn=Ssn
AND Lname=‘Smith’ );

The first SELECT query retrieves the projects that involve a ‘Smith’ as manager of
the department that controls the project, and the second retrieves the projects that
involve a ‘Smith’ as a worker on the project. Notice that if several employees have the
last name ‘Smith, the project names involving any of them will be retrieved.
Applying the UNION operation to the two SELECT queries gives the desired result.

SQL also has corresponding multiset operations, which are followed by the keyword
ALL (UNION ALL, EXCEPT ALL, INTERSECT ALL). Their results are multisets (dupli-
cates are not eliminated). The behavior of these operations is illustrated by the
examples in Figure 4.5. Basically, each tuple—whether it is a duplicate or not—is
considered as a different tuple when applying these operations.

 

‘ln some systems, the keyword MINUS is used for the set difference operation instead of EXCEPT.

=== Page 134 ===
4.3 Basic Retrieval Queries in SQL 105

 

 

 

 

 

 

 

 

 

 

 

(a) R S (b) (c) T
al al a2
a2 a2 a3
a2 a4
Figure 4.5
as a6 The results of SQL multiset
(d) qT operations. (a) Two tables,
R(A) and S(A). (b) R(A)
UNION ALL S(A). (c) R(A)
Fa | EXCEPT ALL S(A). (d) R(A)
a2 INTERSECT ALL S(A).

 

4.3.5 Substring Pattern Matching and Arithmetic Operators

In this section we discuss several more features of SQL. The first feature allows com-
parison conditions on only parts of a character string, using the LIKE comparison
operator. This can be used for string pattern matching. Partial strings are specified
using two reserved characters: % replaces an arbitrary number of zero or more
characters, and the underscore (_) replaces a single character. For example, consider
the following query.

Query 12. Retrieve all employees whose address is in Houston, Texas.

Q12: SELECT Fname, Lname
FROM EMPLOYEE
WHERE Address LIKE ‘%Houston,TX%’;

To retrieve all employees who were born during the 1950s, we can use Query Q12A.
Here, ‘5’ must be the third character of the string (according to our format for date),
so we use the value‘__ 5 , with each underscore serving as a placeholder

for an arbitrary character.
Query 12A. Find all employees who were born during the 1950s.

Q12: SELECT Fname, Lname
FROM EMPLOYEE
WHERE Bdate LIKE‘ _5 ;

If an underscore or % is needed as a literal character in the string, the character
should be preceded by an escape character, which is specified after the string using
the keyword ESCAPE. For example, ‘AB\_CD\%EF’ ESCAPE ‘\’ represents the literal
string ‘AB_CD%EF because \ is specified as the escape character. Any character not
used in the string can be chosen as the escape character. Also, we need a rule to
specify apostrophes or single quotation marks (‘ ’) if they are to be included in a
string because they are used to begin and end strings. If an apostrophe (’) is needed,
it is represented as two consecutive apostrophes (”) so that it will not be interpreted
as ending the string. Notice that substring comparison implies that attribute values

=== Page 135 ===
106

Chapter 4 Basic SOL

are not atomic (indivisible) values, as we had assumed in the formal relational
model (see Section 3.1).

Another feature allows the use of arithmetic in queries. The standard arithmetic
operators for addition (+), subtraction (—), multiplication (*), and division (/) can
be applied to numeric values or attributes with numeric domains. For example,
suppose that we want to see the effect of giving all employees who work on the
‘ProductX’ project a 10 percent raise; we can issue Query 13 to see what their
salaries would become. This example also shows how we can rename an attribute in
the query result using AS in the SELECT clause.

Query 13. Show the resulting salaries if every employee working on the
‘ProductX’ project is given a 10 percent raise.

Q13: SELECT E.Fname, E.Lname, 1.1 * E.Salary AS Increased_sal
FROM EMPLOYEE AS E, WORKS_ON AS W, PROJECT AS P
WHERE E.Ssn=W.Essn AND W.Pno=P.Pnumber AND
P.Pname=‘ProductX’;

For string data types, the concatenate operator || can be used in a query to append
two string values. For date, time, timestamp, and interval data types, operators
include incrementing (+) or decrementing (—) a date, time, or timestamp by an
interval. In addition, an interval value is the result of the difference between two
date, time, or timestamp values. Another comparison operator, which can be used
for convenience, is BETWEEN, which is illustrated in Query 14.

Query 14. Retrieve all employees in department 5 whose salary is between
$30,000 and $40,000.

Q14: SELECT *
FROM EMPLOYEE
WHERE (Salary BETWEEN 30000 AND 40000) AND Dno = 5;

The condition (Salary BETWEEN 30000 AND 40000) in Q14 is equivalent to the con-
dition ((Salary >= 30000) AND (Salary <= 40000)).

4.3.6 Ordering of Query Results

SQL allows the user to order the tuples in the result of a query by the values of one
or more of the attributes that appear in the query result, by using the ORDER BY
clause. This is illustrated by Query 15.

Query 15. Retrieve a list of employees and the projects they are working on,
ordered by department and, within each department, ordered alphabetically by
last name, then first name.

Q15: SELECT D.Dname, E.Lname, E.Fname, P.Pname
FROM DEPARTMENT D, EMPLOYEE E, WORKS_ON W,
PROJECT P
WHERE D.Dnumber= E.Dno AND E.Ssn= W.Essn AND
W.Pno= P.Pnumber
ORDER BY D.Dname, E.Lname, E.Fname;

=== Page 136 ===
4.4 INSERT, DELETE, and UPDATE Statements in SQL

The default order is in ascending order of values. We can specify the keyword DESC
if we want to see the result in a descending order of values. The keyword ASC can be
used to specify ascending order explicitly. For example, if we want descending
alphabetical order on Dname and ascending order on Lname, Fname, the ORDER BY
clause of Q15 can be written as

ORDER BY D.Dname DESC, E.Lname ASC, E.Fname ASC

4.3.7 Discussion and Summary
of Basic SQL Retrieval Queries

A simple retrieval query in SQL can consist of up to four clauses, but only the first
two—SELECT and FROM—are mandatory. The clauses are specified in the follow-
ing order, with the clauses between square brackets [ ... ] being optional:

SELECT <attribute list>
FROM <table list>
[WHERE- <condition> |

[| ORDER BY <attribute list> ];

The SELECT clause lists the attributes to be retrieved, and the FROM clause specifies
all relations (tables) needed in the simple query. The WHERE clause identifies the
conditions for selecting the tuples from these relations, including join conditions if
needed. ORDER BY specifies an order for displaying the results of a query. Two addi-
tional clauses GROUP BY and HAVING will be described in Section 5.1.8.

In Chapter 5, we will present more complex features of SQL retrieval queries. These
include the following: nested queries that allow one query to be included as part of
another query; aggregate functions that are used to provide summaries of the infor-
mation in the tables; two additional clauses (GROUP BY and HAVING) that can be
used to provide additional power to aggregate functions; and various types of joins
that can combine records from various tables in different ways.

4.4 INSERT, DELETE, and UPDATE
Statements in SQL

In SQL, three commands can be used to modify the database: INSERT, DELETE, and
UPDATE. We discuss each of these in turn.

4.4.1 The INSERT Command

In its simplest form, INSERT is used to add a single tuple to a relation. We must spec-
ify the relation name and a list of values for the tuple. The values should be listed in
the same order in which the corresponding attributes were specified in the CREATE
TABLE command. For example, to add a new tuple to the EMPLOYEE relation shown

107

=== Page 137 ===
108

Chapter 4 Basic SOL

in Figure 3.5 and specified in the CREATE TABLE EMPLOYEE ... command in Figure
4.1, we can use U1:

U1: INSERT INTO EMPLOYEE
VALUES ( ‘Richard’ ‘K;, ‘Marini’ “6532986537 ‘1962-12-307 “98
Oak Forest, Katy, TX’ ‘M’, 37000, “653298653’, 4 );

A second form of the INSERT statement allows the user to specify explicit attribute
names that correspond to the values provided in the INSERT command. This is use-
ful if a relation has many attributes but only a few of those attributes are assigned
values in the new tuple. However, the values must include all attributes with NOT
NULL specification and no default value. Attributes with NULL allowed or DEFAULT
values are the ones that can be left out. For example, to enter a tuple for a new
EMPLOYEE for whom we know only the Fname, Lname, Dno, and Ssn attributes, we
can use U1A:

U1A: INSERTINTO EMPLOYEE (Fname, Lname, Dno, Ssn)
VALUES (‘Richard’, ‘Marini’, 4, 653298653’);

Attributes not specified in U1A are set to their DEFAULT or to NULL, and the values
are listed in the same order as the attributes are listed in the INSERT command itself.
It is also possible to insert into a relation multiple tuples separated by commas in a
single INSERT command. The attribute values forming each tuple are enclosed in
parentheses.

A DBMS that fully implements SQL should support and enforce all the integrity
constraints that can be specified in the DDL. For example, if we issue the command
in U2 on the database shown in Figure 3.6, the DBMS should reject the operation
because no DEPARTMENT tuple exists in the database with Dnumber = 2. Similarly,
U2A would be rejected because no Ssn value is provided and it is the primary key,
which cannot be NULL.

U3: INSERT INTO EMPLOYEE (Fname, Lname, Ssn, Dno)
VALUES (‘Robert ‘Hatcher’, “9807605407 2);
(U2 is rejected if referential integrity checking is provided by DBMS.)

U2A: INSERT INTO EMPLOYEE (Fname, Lname, Dno)
VALUES (‘Robert ‘Hatcher’, 5);
(U2A is rejected if NOT NULL checking is provided by DBMS.)

A variation of the INSERT command inserts multiple tuples into a relation in con-
junction with creating the relation and loading it with the result of a query. For
example, to create a temporary table that has the employee last name, project name,
and hours per week for each employee working on a project, we can write the state-
ments in U3A and U3B:

U3A: CREATE TABLE WORKS_ON_INFO

( Emp_name VARCHAR(15),
Proj_name VARCHAR(15),
Hours_per_week DECIMAL(3,1) );

=== Page 138 ===
4.4 INSERT, DELETE, and UPDATE Statements in SQL

U3B: INSERTINTO WORKS_ON_INFO ( Emp_name, Proj_name,
Hours_per_week )

SELECT E.Lname, P.Pname, W.Hours
FROM PROJECT P, WORKS_ON W, EMPLOYEE E
WHERE P.Pnumber=W.Pno AND W.Essn=E.Ssn;

A table WORKS_ON_INFO is created by U3A and is loaded with the joined informa-
tion retrieved from the database by the query in U3B. We can now query
WORKS_ON_INFO as we would any other relation; when we do not need it any
more, we can remove it by using the DROP TABLE command (see Chapter 5). Notice
that the WORKS_ON_INFO table may not be up-to-date; that is, if we update any of
the PROJECT, WORKS_ON, or EMPLOYEE relations after issuing U3B, the informa-
tion in WORKS_ON_INFO may become outdated. We have to create a view (see
Chapter 5) to keep such a table up-to-date.

4.4.2 The DELETE Command

The DELETE command removes tuples from a relation. It includes a WHERE clause,
similar to that used in an SQL query, to select the tuples to be deleted. Tuples are
explicitly deleted from only one table at a time. However, the deletion may propa-
gate to tuples in other relations if referential triggered actions are specified in the ref-
erential integrity constraints of the DDL (see Section 4.2.2).!* Depending on the
number of tuples selected by the condition in the WHERE clause, zero, one, or sev-
eral tuples can be deleted by a single DELETE command. A missing WHERE clause
specifies that all tuples in the relation are to be deleted; however, the table remains
in the database as an empty table. We must use the DROP TABLE command to
remove the table definition (see Chapter 5). The DELETE commands in U4A to U4D,
if applied independently to the database in Figure 3.6, will delete zero, one, four, and
all tuples, respectively, from the EMPLOYEE relation:

U4A: DELETE FROM EMPLOYEE
WHERE Lname=‘Brown;;

U4B: DELETE FROM EMPLOYEE
WHERE Ssn=‘123456789’;

U4C: DELETE FROM EMPLOYEE
WHERE Dno=5;

U4D: DELETE FROM EMPLOYEE;

4.4.3 The UPDATE Command

The UPDATE command is used to modify attribute values of one or more selected
tuples. As in the DELETE command, a WHERE clause in the UPDATE command
selects the tuples to be modified from a single relation. However, updating a

'2Other actions can be automatically applied through triggers (see Section 26.1) and other mechanisms.

109

=== Page 139 ===
110

Chapter 4 Basic SOL

primary key value may propagate to the foreign key values of tuples in other rela-
tions if such a referential triggered action is specified in the referential integrity con-
straints of the DDL (see Section 4.2.2). An additional SET clause in the UPDATE
command specifies the attributes to be modified and their new values. For example,
to change the location and controlling department number of project number 10 to
‘Bellaire’ and 5, respectively, we use U5:

U5: UPDATE PROJECT
SET Plocation = ‘Bellaire, Dnum = 5
WHERE Pnumber=10;

Several tuples can be modified with a single UPDATE command. An example is to
give all employees in the ‘Research’ department a 10 percent raise in salary, as shown
in U6. In this request, the modified Salary value depends on the original Salary value
in each tuple, so two references to the Salary attribute are needed. In the SET clause,
the reference to the Salary attribute on the right refers to the old Salary value before
modification, and the one on the left refers to the new Salary value after modification:

U6: UPDATE EMPLOYEE
SET Salary = Salary * 1.1
WHERE Dno = 5;

It is also possible to specify NULL or DEFAULT as the new attribute value. Notice that
each UPDATE command explicitly refers to a single relation only. To modify multiple
relations, we must issue several UPDATE commands.

4.5 Additional Features of SQL

SQL has a number of additional features that we have not described in this chapter
but that we discuss elsewhere in the book. These are as follows:

= In Chapter 5, which is a continuation of this chapter, we will present the fol-
lowing SQL features: various techniques for specifying complex retrieval
queries, including nested queries, aggregate functions, grouping, joined
tables, outer joins, and recursive queries; SQL views, triggers, and assertions;
and commands for schema modification.

= SQL has various techniques for writing programs in various programming
languages that include SQL statements to access one or more databases.
These include embedded (and dynamic) SQL, SQL/CLI (Call Level
Interface) and its predecessor ODBC (Open Data Base Connectivity), and
SQL/PSM (Persistent Stored Modules). We discuss these techniques in
Chapter 13. We also discuss how to access SQL databases through the Java
programming language using JDBC and SQLJ.

m= Each commercial RDBMS will have, in addition to the SQL commands, a set
of commands for specifying physical database design parameters, file struc-
tures for relations, and access paths such as indexes. We called these com-
mands a storage definition language (SDL) in Chapter 2. Earlier versions of
SQL had commands for creating indexes, but these were removed from the

=== Page 140 ===
4.6 Summary

language because they were not at the conceptual schema level. Many sys-
tems still have the CREATE INDEX commands.

= SQL has transaction control commands. These are used to specify units of
database processing for concurrency control and recovery purposes. We dis-
cuss these commands in Chapter 21 after we discuss the concept of transac-
tions in more detail.

= SQL has language constructs for specifying the granting and revoking of priv-
ileges to users. Privileges typically correspond to the right to use certain SQL
commands to access certain relations. Each relation is assigned an owner,
and either the owner or the DBA staff can grant to selected users the privi-
lege to use an SQL statement—such as SELECT, INSERT, DELETE, or
UPDATE—to access the relation. In addition, the DBA staff can grant the
privileges to create schemas, tables, or views to certain users. These SQL
commands—called GRANT and REVOKE—are discussed in Chapter 24,
where we discuss database security and authorization.

= SQL has language constructs for creating triggers. These are generally
referred to as active database techniques, since they specify actions that are
automatically triggered by events such as database updates. We discuss these
features in Section 26.1, where we discuss active database concepts.

= SQL has incorporated many features from object-oriented models to have
more powerful capabilities, leading to enhanced relational systems known as
object-relational. Capabilities such as creating complex-structured attrib-
utes (also called nested relations), specifying abstract data types (called
UDTSs or user-defined types) for attributes and tables, creating object iden-
tifiers for referencing tuples, and specifying operations on types are dis-
cussed in Chapter 11.

= SQL and relational databases can interact with new technologies such as
XML (see Chapter 12) and OLAP (Chapter 29).

4.6 Summary

In this chapter we presented the SQL database language. This language and its vari-
ations have been implemented as interfaces to many commercial relational DBMSs,
including Oracle’s Oracle and Rdb!°; IBM’s DB2, Informix Dynamic Server, and
SQL/DS; Microsoft’s SQL Server and Access; and INGRES. Some open source sys-
tems also provide SQL, such as MySQL and PostgreSQL. The original version of
SQL was implemented in the experimental DBMS called SYSTEM R, which was
developed at IBM Research. SQL is designed to be a comprehensive language that
includes statements for data definition, queries, updates, constraint specification,
and view definition. We discussed the following features of SQL in this chapter: the
data definition commands for creating tables, commands for constraint specifica-
tion, simple retrieval queries, and database update commands. In the next chapter,

 

'3Rdb was originally produced by Digital Equipment Corporation. It was acquired by Oracle from Digital
in 1994 and is being supported and enhanced.

111

=== Page 141 ===
112 Chapter 4 Basic SQL

we will present the following features of SQL: complex retrieval queries; views; trig-
gers and assertions; and schema modification commands.

Review Questions

4.1.

4.2.
4.3.

4.4.

How do the relations (tables) in SQL differ from the relations defined for-
mally in Chapter 3? Discuss the other differences in terminology. Why does
SQL allow duplicate tuples in a table or in a query result?

List the data types that are allowed for SQL attributes.

How does SQL allow implementation of the entity integrity and referential
integrity constraints described in Chapter 3? What about referential trig-
gered actions?

Describe the four clauses in the syntax of a simple SQL retrieval query. Show
what type of constructs can be specified in each of the clauses. Which are
required and which are optional?

Exercises

4.5.

4.6.
4.7.

4.8.

4.9.

4.10.

Consider the database shown in Figure 1.2, whose schema is shown in Figure
2.1. What are the referential integrity constraints that should hold on the
schema? Write appropriate SQL DDL statements to define the database.

Repeat Exercise 4.5, but use the AIRLINE database schema of Figure 3.8.

Consider the LIBRARY relational database schema shown in Figure 4.6.
Choose the appropriate action (reject, cascade, set to NULL, set to default) for
each referential integrity constraint, both for the deletion of a referenced
tuple and for the update of a primary key attribute value in a referenced
tuple. Justify your choices.

Write appropriate SQL DDL statements for declaring the LIBRARY relational
database schema of Figure 4.6. Specify the keys and referential triggered
actions.

How can the key and foreign key constraints be enforced by the DBMS? Is
the enforcement technique you suggest difficult to implement? Can the con-
straint checks be executed efficiently when updates are applied to the data-
base?

Specify the following queries in SQL on the COMPANY relational database
schema shown in Figure 3.5. Show the result of each query if it is applied to
the COMPANY database in Figure 3.6.

a. Retrieve the names of all employees in department 5 who work more than
10 hours per week on the ProductX project.

b. List the names of all employees who have a dependent with the same first
name as themselves.

=== Page 142 ===
Exercises 113

BOOK

Book_id] Title | Publisher_name

fs
BOOK_AUTHORS
Book_id

 

 

 
 
  
 
  
  
   
 
 
 
 
   
 
 
 
    
 
  
  
 

   

 

 

 

Author_name |

 

PUBLISHER
Name | Address | Phone

A
BOOK_COPIES

Book_id| Branch_id No_of_copies

BOOK_LOANS

Book_id Branch_id] Card_no | Date_out | Due date

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

LIBRARY_BRANCH

Branch_id Branch_name | Address

 

 

 

 

 

BORROWER

Card_no} Name | Address | Phone

Figure 4.6

A relational database
schema for a
LIBRARY database.

 

 

c. Find the names of all employees who are directly supervised by ‘Franklin
Wong.

4.11. Specify the updates of Exercise 3.11 using the SQL update commands.

4.12. Specify the following queries in SQL on the database schema of Figure 1.2.

a. Retrieve the names of all senior students majoring in ‘CS’ (computer sci-
ence).

b. Retrieve the names of all courses taught by Professor King in 2007 and
2008.

c. For each section taught by Professor King, retrieve the course number,
semester, year, and number of students who took the section.

d. Retrieve the name and transcript of each senior student (Class = 4)
majoring in CS. A transcript includes course name, course number, credit
hours, semester, year, and grade for each course completed by the student.

=== Page 143 ===
114

Chapter 4 Basic SOL

4.13.

4.14.

4.15.

Write SQL update statements to do the following on the database schema
shown in Figure 1.2.

a. Insert a new student, <‘Johnson’, 25, 1, “Math’>, in the database.

b. Change the class of student ‘Smith’ to 2.

c. Insert a new course, <“Knowledge Engineering’, ‘CS4390; 3, “CS’>.

d. Delete the record for the student whose name is ‘Smith’ and whose stu-
dent number is 17.

Design a relational database schema for a database application of your

choice.

a. Declare your relations, using the SQL DDL.

b. Specify a number of queries in SQL that are needed by your database
application.

c. Based on your expected use of the database, choose some attributes that
should have indexes specified on them.

d. Implement your database, if you have a DBMS that supports SQL.

Consider the EMPLOYEE table’s constraint EMPSUPERFK as specified in
Figure 4.2 is changed to read as follows:

CONSTRAINT EMPSUPERFK
FOREIGN KEY (Super_ssn) REFERENCES EMPLOYEE(Ssn)
ON DELETE CASCADE ON UPDATE CASCADE,
Answer the following questions:
a. What happens when the following command is run on the database state
shown in Figure 3.6?
DELETE EMPLOYEE WHERE Lname = ‘Borg’

b. Is it better to CASCADE or SET NULL in case of EMPSUPERFK constraint
ON DELETE?

. Write SQL statements to create a table EMPLOYEE_BACKUP to back up the

EMPLOYEE table shown in Figure 3.6.

Selected Bibliography

The SQL language, originally named SEQUEL, was based on the language SQUARE
(Specifying Queries as Relational Expressions), described by Boyce et al. (1975). The
syntax of SQUARE was modified into SEQUEL (Chamberlin and Boyce, 1974) and
then into SEQUEL 2 (Chamberlin et al. 1976), on which SQL is based. The original
implementation of SEQUEL was done at IBM Research, San Jose, California. We
will give additional references to various aspects of SQL at the end of Chapter 5.

=== Page 144 ===
»
chapter ~)

More SQL: Complex Queries,
Triggers, Views, and
Schema Modification

‘TR chapter describes more advanced features of the
SQL language standard for relational databases. We
start in Section 5.1 by presenting more complex features of SQL retrieval queries,
such as nested queries, joined tables, outer joins, aggregate functions, and grouping.
In Section 5.2, we describe the CREATE ASSERTION statement, which allows the
specification of more general constraints on the database. We also introduce the
concept of triggers and the CREATE TRIGGER statement, which will be presented in
more detail in Section 26.1 when we present the principles of active databases.
Then, in Section 5.3, we describe the SQL facility for defining views on the database.
Views are also called virtual or derived tables because they present the user with
what appear to be tables; however, the information in those tables is derived from
previously defined tables. Section 5.4 introduces the SQL ALTER TABLE statement,
which is used for modifying the database tables and constraints. Section 5.5 is the
chapter summary.

This chapter is a continuation of Chapter 4. The instructor may skip parts of this
chapter if a less detailed introduction to SQL is intended.

5.1 More Complex SQL Retrieval Queries

In Section 4.3, we described some basic types of retrieval queries in SQL. Because of
the generality and expressive power of the language, there are many additional fea-
tures that allow users to specify more complex retrievals from the database. We dis-
cuss several of these features in this section.

115

=== Page 145 ===
116

Chapter 5 More SQL: Complex Queries, Triggers, Views, and Schema Modification

5.1.1 Comparisons Involving NULL
and Three-Valued Logic

SQL has various rules for dealing with NULL values. Recall from Section 3.1.2 that
NULL is used to represent a missing value, but that it usually has one of three different
interpretations—value unknown (exists but is not known), value not available (exists
but is purposely withheld), or value not applicable (the attribute is undefined for this
tuple). Consider the following examples to illustrate each of the meanings of NULL.

1. Unknown value. A person’s date of birth is not known, so it is represented
by NULL in the database.

2. Unavailable or withheld value. A person has a home phone but does not
want it to be listed, so it is withheld and represented as NULL in the database.

3. Not applicable attribute. An attribute LastCollegeDegree would be NULL for
a person who has no college degrees because it does not apply to that person.

It is often not possible to determine which of the meanings is intended; for example,
a NULL for the home phone of a person can have any of the three meanings. Hence,
SQL does not distinguish between the different meanings of NULL.

In general, each individual NULL value is considered to be different from every other
NULL value in the various database records. When a NULL is involved in a compari-
son operation, the result is considered to be UNKNOWN (it may be TRUE or it may
be FALSE). Hence, SQL uses a three-valued logic with values TRUE, FALSE, and
UNKNOWN instead of the standard two-valued (Boolean) logic with values TRUE or
FALSE. It is therefore necessary to define the results (or truth values) of three-valued
logical expressions when the logical connectives AND, OR, and NOT are used. Table
5.1 shows the resulting values.

 

 

 

 

Table 5.1. Logical Connectives in Three-Valued Logic
(a) AND TRUE FALSE UNKNOWN
TRUE TRUE FALSE UNKNOWN
FALSE FALSE FALSE FALSE
UNKNOWN UNKNOWN FALSE UNKNOWN
(b) OR TRUE FALSE UNKNOWN
TRUE TRUE TRUE TRUE
FALSE TRUE FALSE UNKNOWN
UNKNOWN TRUE UNKNOWN UNKNOWN
(c) NOT
TRUE FALSE
FALSE TRUE
UNKNOWN UNKNOWN

 

=== Page 146 ===
5.1 More Complex SQL Retrieval Queries

In Tables 5.1(a) and 5.1(b), the rows and columns represent the values of the results
of comparison conditions, which would typically appear in the WHERE clause of an
SQL query. Each expression result would have a value of TRUE, FALSE, or
UNKNOWN. The result of combining the two values using the AND logical connec-
tive is shown by the entries in Table 5.1(a). Table 5.1(b) shows the result of using the
OR logical connective. For example, the result of (FALSE AND UNKNOWN) is FALSE,
whereas the result of (FALSE OR UNKNOWN) is UNKNOWN. Table 5.1(c) shows the
result of the NOT logical operation. Notice that in standard Boolean logic, only
TRUE or FALSE values are permitted; there is no UNKNOWN value.

In select-project-join queries, the general rule is that only those combinations of
tuples that evaluate the logical expression in the WHERE clause of the query to
TRUE are selected. Tuple combinations that evaluate to FALSE or UNKNOWN are not
selected. However, there are exceptions to that rule for certain operations, such as
outer joins, as we shall see in Section 5.1.6.

SQL allows queries that check whether an attribute value is NULL. Rather than using
= or <> to compare an attribute value to NULL, SQL uses the comparison operators
IS or IS NOT. This is because SQL considers each NULL value as being distinct from
every other NULL value, so equality comparison is not appropriate. It follows that
when a join condition is specified, tuples with NULL values for the join attributes are
not included in the result (unless it is an OUTER JOIN; see Section 5.1.6). Query 18
illustrates this.

Query 18. Retrieve the names of all employees who do not have supervisors.

Q18: SELECT Fname, Lname
FROM EMPLOYEE
WHERE Super_ssn IS NULL;

5.1.2 Nested Queries, Tuples,
and Set/Multiset Comparisons

Some queries require that existing values in the database be fetched and then used
in a comparison condition. Such queries can be conveniently formulated by using
nested queries, which are complete select-from-where blocks within the WHERE
clause of another query. That other query is called the outer query. Query 4 is for-
mulated in Q4 without a nested query, but it can be rephrased to use nested queries
as shown in Q4A. Q4A introduces the comparison operator IN, which compares a
value v with a set (or multiset) of values V and evaluates to TRUE if v is one of the
elements in V.

The first nested query selects the project numbers of projects that have an employee
with last name “Smith’ involved as manager, while the second nested query selects
the project numbers of projects that have an employee with last name ‘Smith’
involved as worker. In the outer query, we use the OR logical connective to retrieve a
PROJECT tuple if the PNUMBER value of that tuple is in the result of either nested

query.

117

=== Page 147 ===
118

Chapter 5 More SQL: Complex Queries, Triggers, Views, and Schema Modification

Q4A: SELECT DISTINCT Pnumber

FROM PROJECT
WHERE Pnumber IN
( SELECT Pnumber
FROM PROJECT, DEPARTMENT, EMPLOYEE
WHERE Dnum=Dnumber AND
Mgr_ssn=Ssn AND Lname=‘Smith’ )
OR
Pnumber IN
( SELECT Pno
FROM WORKS_ON, EMPLOYEE
WHERE Essn=Ssn AND Lname=‘Smith’ );

If a nested query returns a single attribute and a single tuple, the query result will be
a single (scalar) value. In such cases, it is permissible to use = instead of IN for the
comparison operator. In general, the nested query will return a table (relation),
which is a set or multiset of tuples.

SQL allows the use of tuples of values in comparisons by placing them within
parentheses. To illustrate this, consider the following query:

SELECT DISTINCT Essn

FROM WORKS_ON

WHERE (Pno, Hours) IN ( SELECT Pno, Hours
FROM WORKS_ON
WHERE Essn=‘123456789’ );

This query will select the Essns of all employees who work the same (project, hours)
combination on some project that employee ‘John Smith’ (whose Ssn =
123456789’) works on. In this example, the IN operator compares the subtuple of
values in parentheses (Pno, Hours) within each tuple in WORKS_ON with the set of
type-compatible tuples produced by the nested query.

In addition to the IN operator, a number of other comparison operators can be used
to compare a single value v (typically an attribute name) to a set or multiset v (typ-
ically a nested query). The = ANY (or = SOME) operator returns TRUE if the value v
is equal to some value in the set V and is hence equivalent to IN. The two keywords
ANY and SOME have the same effect. Other operators that can be combined with
ANY (or SOME) include >, >=, <, <=, and <>. The keyword ALL can also be com-
bined with each of these operators. For example, the comparison condition (v > ALL
V) returns TRUE if the value v is greater than all the values in the set (or multiset) V.
An example is the following query, which returns the names of employees whose
salary is greater than the salary of all the employees in department 5:

SELECT Lname, Fname

FROM EMPLOYEE

WHERE Salary > ALL ( SELECT Salary
FROM EMPLOYEE
WHERE Dno=5 );

=== Page 148 ===
5.1 More Complex SQL Retrieval Queries

Notice that this query can also be specified using the MAX aggregate function (see
Section 5.1.7).

In general, we can have several levels of nested queries. We can once again be faced
with possible ambiguity among attribute names if attributes of the same name
exist—one in a relation in the FROM clause of the outer query, and another in a rela-
tion in the FROM clause of the nested query. The rule is that a reference to an
unqualified attribute refers to the relation declared in the innermost nested query.
For example, in the SELECT clause and WHERE clause of the first nested query of
Q4A, a reference to any unqualified attribute of the PROJECT relation refers to the
PROJECT relation specified in the FROM clause of the nested query. To refer to an
attribute of the PROJECT relation specified in the outer query, we specify and refer
to an alias (tuple variable) for that relation. These rules are similar to scope rules for
program variables in most programming languages that allow nested procedures
and functions. To illustrate the potential ambiguity of attribute names in nested
queries, consider Query 16.

Query 16. Retrieve the name of each employee who has a dependent with the
same first name and is the same sex as the employee.

Q16: SELECT E.Fname, E.Lname

FROM EMPLOYEE AS E
WHERE E.Ssn IN ( SELECT Essn
FROM DEPENDENT AS D

WHERE E.Fname=D.Dependent_name
AND E.Sex=D.Sex );

In the nested query of Q16, we must qualify E.Sex because it refers to the Sex attrib-
ute of EMPLOYEE from the outer query, and DEPENDENT also has an attribute
called Sex. If there were any unqualified references to Sex in the nested query, they
would refer to the Sex attribute of DEPENDENT. However, we would not have to
qualify the attributes Fname and Ssn of EMPLOYEE if they appeared in the nested
query because the DEPENDENT relation does not have attributes called Fname and
Ssn, so there is no ambiguity.

It is generally advisable to create tuple variables (aliases) for all the tables referenced
in an SQL query to avoid potential errors and ambiguities, as illustrated in Q16.

5.1.3 Correlated Nested Queries

Whenever a condition in the WHERE clause of a nested query references some attrib-
ute of a relation declared in the outer query, the two queries are said to be correlated.
We can understand a correlated query better by considering that the nested query is
evaluated once for each tuple (or combination of tuples) in the outer query. For exam-
ple, we can think of Q16 as follows: For each EMPLOYEE tuple, evaluate the nested
query, which retrieves the Essn values for all DEPENDENT tuples with the same sex
and name as that EMPLOYEE tuple; if the Ssn value of the EMPLOYEE tuple is in the
result of the nested query, then select that EMPLOYEE tuple.

119

=== Page 149 ===
120

Chapter 5 More SQL: Complex Queries, Triggers, Views, and Schema Modification

In general, a query written with nested select-from-where blocks and using the = or
IN comparison operators can always be expressed as a single block query. For exam-
ple, Q16 may be written as in Q16A:

Q16A: SELECT E.Fname, E.Lname
FROM EMPLOYEE AS E, DEPENDENT AS D
WHERE E.Ssn=D.Essn AND E.Sex=D.Sex
AND E.Fname=D.Dependent_name;

5.1.4 The EXISTS and UNIQUE Functions in SQL

The EXISTS function in SQL is used to check whether the result of a correlated
nested query is empty (contains no tuples) or not. The result of EXISTS is a Boolean
value TRUE if the nested query result contains at least one tuple, or FALSE if the
nested query result contains no tuples. We illustrate the use of EXISTS—and NOT
EXISTS—with some examples. First, we formulate Query 16 in an alternative form
that uses EXISTS as in Q16B:

Q16B: SELECT E.Fname, E.Lname
FROM EMPLOYEE AS E
WHERE EXISTS (SELECT *
FROM DEPENDENT AS D
WHERE E.Ssn=D.Essn AND E.Sex=D.Sex
AND E.Fname=D.Dependent_name);

EXISTS and NOT EXISTS are typically used in conjunction with a correlated nested
query. In Q16B, the nested query references the Ssn, Fname, and Sex attributes of the
EMPLOYEE relation from the outer query. We can think of Q16B as follows: For each
EMPLOYEE tuple, evaluate the nested query, which retrieves all DEPENDENT tuples
with the same Essn, Sex, and Dependent_name as the EMPLOYEE tuple; if at least one
tuple EXISTS in the result of the nested query, then select that EMPLOYEE tuple. In
general, EXISTS(Q) returns TRUE if there is at least one tuple in the result of the
nested query Q, and it returns FALSE otherwise. On the other hand, NOT EXISTS(Q)
returns TRUE if there are no tuples in the result of nested query Q, and it returns
FALSE otherwise. Next, we illustrate the use of NOT EXISTS.

Query 6. Retrieve the names of employees who have no dependents.

Qé6: SELECT Fname, Lname
FROM EMPLOYEE
WHERE NOT EXISTS ( SELECT *
FROM DEPENDENT
WHERE Ssn=Essn );

In Q6, the correlated nested query retrieves all DEPENDENT tuples related to a par-
ticular EMPLOYEE tuple. If none exist, the EMPLOYEE tuple is selected because the
WHERE-clause condition will evaluate to TRUE in this case. We can explain Q6 as
follows: For each EMPLOYEE tuple, the correlated nested query selects all
DEPENDENT tuples whose Essn value matches the EMPLOYEE Ssn; if the result is

=== Page 150 ===
5.1 More Complex SQL Retrieval Queries

empty, no dependents are related to the employee, so we select that EMPLOYEE
tuple and retrieve its Fname and Lname.

Query 7. List the names of managers who have at least one dependent.

Q7: SELECT Fname, Lname
FROM EMPLOYEE
WHERE EXISTS (SELECT *
FROM DEPENDENT
WHERE _ Ssn=Essn )
AND
EXISTS (SELECT *
FROM DEPARTMENT
WHERE _ Ssn=Mgr_ssn );

One way to write this query is shown in Q7, where we specify two nested correlated
queries; the first selects all DEPENDENT tuples related to an EMPLOYEE, and the sec-
ond selects all DEPARTMENT tuples managed by the EMPLOYEE. If at least one of the
first and at least one of the second exists, we select the EMPLOYEE tuple. Can you
rewrite this query using only a single nested query or no nested queries?

The query Q3: Retrieve the name of each employee who works on all the projects con-
trolled by department number 5 can be written using EXISTS and NOT EXISTS in SQL
systems. We show two ways of specifying this query Q3 in SQL as Q8A and Q3B.
This is an example of certain types of queries that require universal quantification, as
we will discuss in Section 6.6.7. One way to write this query is to use the construct
(S2 EXCEPT S1) as explained next, and checking whether the result is empty.! This
option is shown as Q3A.

Q3A: SELECT Fname, Lname
FROM EMPLOYEE
WHERE NOT EXISTS ( ( SELECT Pnumber
FROM PROJECT
WHERE Dnum=5)
EXCEPT ( SELECT Pno
FROM WORKS_ON
WHERE Ssn=Essn) );

In Q3A, the first subquery (which is not correlated with the outer query) selects all
projects controlled by department 5, and the second subquery (which is correlated)
selects all projects that the particular employee being considered works on. If the set
difference of the first subquery result MINUS (EXCEPT) the second subquery result is
empty, it means that the employee works on all the projects and is therefore selected.

The second option is shown as Q3B. Notice that we need two-level nesting in Q3B
and that this formulation is quite a bit more complex than Q3A, which uses NOT
EXISTS and EXCEPT.

 

‘Recall that EXCEPT is the set difference operator. The keyword MINUS is also sometimes used, for
example, in Oracle.

121

=== Page 151 ===
122 Chapter 5 More SQL: Complex Queries, Triggers, Views, and Schema Modification

Q3B: SELECT Lname, Fname
FROM EMPLOYEE
WHERE NOTEXISTS (SELECT *
FROM WORKS_ON B
WHERE (B.Pno IN (SELECT Pnumber
FROM PROJECT
WHERE Dnum=5 )
AND
NOT EXISTS ( SELECT *
FROM WORKS_ON C
WHERE C.Essn=Ssn
AND C.Pno=B.Pno )));

In Q3B, the outer nested query selects any WORKS_ON (B) tuples whose Pno is of a
project controlled by department 5, if there is not a WORKS_ON (C) tuple with the
same Pno and the same Ssn as that of the EMPLOYEE tuple under consideration in
the outer query. If no such tuple exists, we select the EMPLOYEE tuple. The form of
Q3B matches the following rephrasing of Query 3: Select each employee such that
there does not exist a project controlled by department 5 that the employee does not
work on. It corresponds to the way we will write this query in tuple relation calculus
(see Section 6.6.7).

There is another SQL function, UNIQUE(Q), which returns TRUE if there are no
duplicate tuples in the result of query Q; otherwise, it returns FALSE. This can be
used to test whether the result of a nested query is a set or a multiset.

5.1.5 Explicit Sets and Renaming of Attributes in SQL

We have seen several queries with a nested query in the WHERE clause. It is also pos-
sible to use an explicit set of values in the WHERE clause, rather than a nested
query. Such a set is enclosed in parentheses in SQL.

Query 17. Retrieve the Social Security numbers of all employees who work on
project numbers 1, 2, or 3.

Q17: SELECT DISTINCT Essn
FROM WORKS_ON
WHERE Pno IN (1, 2, 3);

In SQL, it is possible to rename any attribute that appears in the result of a query by
adding the qualifier AS followed by the desired new name. Hence, the AS construct
can be used to alias both attribute and relation names, and it can be used in both the
SELECT and FROM clauses. For example, Q8A shows how query Q8 from Section
4.3.2 can be slightly changed to retrieve the last name of each employee and his or
her supervisor, while renaming the resulting attribute names as Employee_name and
Supervisor_name. The new names will appear as column headers in the query result.

Q8A: SELECT E.Lname AS Employee_name, S.Lname AS Supervisor_name
FROM EMPLOYEE AS E, EMPLOYEE AS S
WHERE E.Super_ssn=S.Ssn;

=== Page 152 ===
5.1 More Complex SQL Retrieval Queries

5.1.6 Joined Tables in SQL and Outer Joins

The concept of a joined table (or joined relation) was incorporated into SQL to
permit users to specify a table resulting from a join operation in the FROM clause of
a query. This construct may be easier to comprehend than mixing together all the
select and join conditions in the WHERE clause. For example, consider query Q1,
which retrieves the name and address of every employee who works for the
‘Research’ department. It may be easier to specify the join of the EMPLOYEE and
DEPARTMENT relations first, and then to select the desired tuples and attributes.
This can be written in SQL as in Q1A:

Q1A: SELECT Fname, Lname, Address
FROM (EMPLOYEE JOIN DEPARTMENT ON Dno=Dnumber)
WHERE Dname=‘Research’?;

The FROM clause in Q1A contains a single joined table. The attributes of such a table
are all the attributes of the first table, EMPLOYEE, followed by all the attributes of
the second table, DEPARTMENT. The concept of a joined table also allows the user to
specify different types of join, such as NATURAL JOIN and various types of OUTER
JOIN. In a NATURAL JOIN on two relations R and S, no join condition is specified; an
implicit EQUUOIN condition for each pair of attributes with the same name from R
and S is created. Each such pair of attributes is included only once in the resulting
relation (see Section 6.3.2 and 6.4.4 for more details on the various types of join
operations in relational algebra).

If the names of the join attributes are not the same in the base relations, it is possi-
ble to rename the attributes so that they match, and then to apply NATURAL JOIN. In
this case, the AS construct can be used to rename a relation and all its attributes in
the FROM clause. This is illustrated in Q1B, where the DEPARTMENT relation is
renamed as DEPT and its attributes are renamed as Dname, Dno (to match the name
of the desired join attribute Dno in the EMPLOYEE table), Mssn, and Msdate. The
implied join condition for this NATURAL JOIN is EMPLOYEE.Dno=DEPT.Dno,
because this is the only pair of attributes with the same name after renaming:

QiB: SELECT Fname, Lname, Address
FROM (EMPLOYEE NATURAL JOIN
(DEPARTMENT AS DEPT (Dname, Dno, Mssn, Msdate)))
WHERE Dname=‘Research’;

The default type of join in a joined table is called an inner join, where a tuple is
included in the result only if a matching tuple exists in the other relation. For exam-
ple, in query Q8A, only employees who have a supervisor are included in the result;
an EMPLOYEE tuple whose value for Super_ssn is NULL is excluded. If the user
requires that all employees be included, an OUTER JOIN must be used explicitly (see
Section 6.4.4 for the definition of OUTER JOIN). In SQL, this is handled by explicitly
specifying the keyword OUTER JOIN in a joined table, as illustrated in Q8B:
Q8B: SELECT E.Lname AS Employee_name,
S.Lname AS Supervisor_name
FROM (EMPLOYEE AS E LEFT OUTER JOIN EMPLOYEE AS S
ON E.Super_ssn=S.Ssn);

123

=== Page 153 ===
124 Chapter 5 More SQL: Complex Queries, Triggers, Views, and Schema Modification

There are a variety of outer join operations, which we shall discuss in more detail in
Section 6.4.4. In SQL, the options available for specifying joined tables include
INNER JOIN (only pairs of tuples that match the join condition are retrieved, same
as JOIN), LEFT OUTER JOIN (every tuple in the left table must appear in the result; if
it does not have a matching tuple, it is padded with NULL values for the attributes of
the right table), RIGHT OUTER JOIN (every tuple in the right table must appear in
the result; if it does not have a matching tuple, it is padded with NULL values for the
attributes of the left table), and FULL OUTER JOIN. In the latter three options, the
keyword OUTER may be omitted. If the join attributes have the same name, one can
also specify the natural join variation of outer joins by using the keyword NATURAL
before the operation (for example, NATURAL LEFT OUTER JOIN). The keyword
CROSS JOIN is used to specify the CARTESIAN PRODUCT operation (see Section
6.2.2), although this should be used only with the utmost care because it generates
all possible tuple combinations.

It is also possible to nest join specifications; that is, one of the tables in a join may
itself be a joined table. This allows the specification of the join of three or more
tables as a single joined table, which is called a multiway join. For example, Q2A is a
different way of specifying query Q2 from Section 4.3.1 using the concept of a
joined table:

Q2A: SELECT Pnumber, Dnum, Lname, Address, Bdate
FROM ((PROJECT JOIN DEPARTMENT ON Dnum=Dnumber)
JOIN EMPLOYEE ON Mgr_ssn=Ssn)
WHERE Plocation=‘Stafford’;

Not all SQL implementations have implemented the new syntax of joined tables. In
some systems, a different syntax was used to specify outer joins by using the com-
parison operators +=, =+, and +=+ for left, right, and full outer join, respectively,
when specifying the join condition. For example, this syntax is available in Oracle.
To specify the left outer join in Q8B using this syntax, we could write the query Q8C
as follows:

asc: SELECT E.Lname, S.Lname
FROM EMPLOYEE E, EMPLOYEE S
WHERE E.Super_ssn += S.Ssn;

5.1.7 Aggregate Functions in SQL

In Section 6.4.2, we will introduce the concept of an aggregate function as a rela-
tional algebra operation. Aggregate functions are used to summarize information
from multiple tuples into a single-tuple summary. Grouping is used to create sub-
groups of tuples before summarization. Grouping and aggregation are required in
many database applications, and we will introduce their use in SQL through exam-
ples. A number of built-in aggregate functions exist: COUNT, SUM, MAX, MIN, and
AVG.2 The COUNT function returns the number of tuples or values as specified in a

 

Additional aggregate functions for more advanced statistical calculation were added in SQL-99.

=== Page 154 ===
5.1 More Complex SQL Retrieval Queries

query. The functions SUM, MAX, MIN, and AVG can be applied to a set or multiset of
numeric values and return, respectively, the sum, maximum value, minimum value,
and average (mean) of those values. These functions can be used in the SELECT
clause or in a HAVING clause (which we introduce later). The functions MAX and
MIN can also be used with attributes that have nonnumeric domains if the domain
values have a total ordering among one another.’ We illustrate the use of these func-
tions with sample queries.

Query 19. Find the sum of the salaries of all employees, the maximum salary,
the minimum salary, and the average salary.

Q19: SELECT SUM (Salary), MAX (Salary), MIN (Salary), AVG (Salary)
FROM EMPLOYEE;

If we want to get the preceding function values for employees of a specific depart-
ment—say, the ‘Research’ department—we can write Query 20, where the
EMPLOYEE tuples are restricted by the WHERE clause to those employees who work
for the ‘Research department.

Query 20. Find the sum of the salaries of all employees of the ‘Research’
department, as well as the maximum salary, the minimum salary, and the aver-
age salary in this department.

Q20: SELECT SUM (Salary), MAX (Salary), MIN (Salary), AVG (Salary)
FROM (EMPLOYEE JOIN DEPARTMENT ON Dno=Dnumber)
WHERE Dname=‘Research’?;

Queries 21 and 22. Retrieve the total number of employees in the company
(Q21) and the number of employees in the ‘Research’ department (Q22).

Q21: SELECT COUNT (*)
FROM EMPLOYEE;

Q22: SELECT COUNT (*)
FROM EMPLOYEE, DEPARTMENT
WHERE DNO=DNUMBER AND DNAME= ‘Research’;

Here the asterisk (*) refers to the rows (tuples), so COUNT (*) returns the number of
rows in the result of the query. We may also use the COUNT function to count values
in a column rather than tuples, as in the next example.

Query 23. Count the number of distinct salary values in the database.

Q23: SELECT COUNT (DISTINCT Salary)
FROM EMPLOYEE;

If we write COUNT(SALARY) instead of COUNT(DISTINCT SALARY) in Q23, then
duplicate values will not be eliminated. However, any tuples with NULL for SALARY

 

Total order means that for any two values in the domain, it can be determined that one appears before
the other in the defined order; for example, DATE, TIME, and TIMESTAMP domains have total orderings
on their values, as do alphabetic strings.

125

=== Page 155 ===
126 Chapter 5 More SQL: Complex Queries, Triggers, Views, and Schema Modification

will not be counted. In general, NULL values are discarded when aggregate func-
tions are applied to a particular column (attribute).

The preceding examples summarize a whole relation (Q19, Q21, Q23) or a selected
subset of tuples (Q20, Q22), and hence all produce single tuples or single values.
They illustrate how functions are applied to retrieve a summary value or summary
tuple from the database. These functions can also be used in selection conditions
involving nested queries. We can specify a correlated nested query with an aggregate
function, and then use the nested query in the WHERE clause of an outer query. For
example, to retrieve the names of all employees who have two or more dependents
(Query 5), we can write the following:

Q5: SELECT Lname, Fname
FROM EMPLOYEE
WHERE (SELECT COUNT (*)
FROM DEPENDENT
WHERE _ Ssn=Essn ) >= 2;

The correlated nested query counts the number of dependents that each employee
has; if this is greater than or equal to two, the employee tuple is selected.

5.1.8 Grouping: The GROUP BY and HAVING Clauses

In many cases we want to apply the aggregate functions to subgroups of tuples in a
relation, where the subgroups are based on some attribute values. For example, we
may want to find the average salary of employees in each department or the number
of employees who work on each project. In these cases we need to partition the rela-
tion into nonoverlapping subsets (or groups) of tuples. Each group (partition) will
consist of the tuples that have the same value of some attribute(s), called the
grouping attribute(s). We can then apply the function to each such group inde-
pendently to produce summary information about each group. SQL has a GROUP
BY clause for this purpose. The GROUP BY clause specifies the grouping attributes,
which should also appear in the SELECT clause, so that the value resulting from
applying each aggregate function to a group of tuples appears along with the value
of the grouping attribute(s).

Query 24. For each department, retrieve the department number, the number
of employees in the department, and their average salary.

Q24: SELECT Dno, COUNT (*), AVG (Salary)
FROM EMPLOYEE
GROUP BY Dno;

In Q24, the EMPLOYEE tuples are partitioned into groups—each group having
the same value for the grouping attribute Dno. Hence, each group contains the
employees who work in the same department. The COUNT and AVG functions are
applied to each such group of tuples. Notice that the SELECT clause includes only the
grouping attribute and the aggregate functions to be applied on each group of tuples.
Figure 5.1(a) illustrates how grouping works on Q24; it also shows the result of Q24.

=== Page 156 ===
5.1 More Complex SQL Retrieval Queries

127

 

Figure 5.1

 

(a)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

(b)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Results of GROUP BY and HAVING. (a) Q24. (b) 26.
Fname_ | Minit | Lname Ssn | Salary | Super_ssn Dno Dno | Count (*) | Avg (Salary)
John B Smith 123456789 30000 | 333445555 5 pr 8 4 33250
Franklin T Wong 333445555 40000 | 888665555 5 pe 4 3 31000
Ramesh | K Narayan | 666884444 38000 | 333445555 5 1 1 55000
Joyce A English | 453453453 25000 | 333445555 5 || Result of Q24
Alicia J Zelaya | 999887777 25000 | 987654321 4 |]
Jennifer Ss Wallace | 987654321 43000 | 888665555 4 —
Ahmad Vv Jabbar | 987987987 25000 | 987654321 4
James | E | Bong | 688665555 55000 | NULL 1 |]
Grouping EMPLOYEE tuples by the value of Dno
Pname Pnumber Essn Pno Hours -— These groups are not selected by
ProductX 1 193456789 1 325 the HAVING condition of Q26.
ProductX 1 453453453 1 20.0 ~
ProductY 2 123456789 | 2 75 | |
ProductY 2 453453453 2 20.0
ProductY 2 333445555 2 10.0 |_|
ProductZ 3 666884444| 3 40.0 \.
ProductZ 3 333445555 3 10.0 | |
Computerization 10 333445555 | 10 10.0
Computerization 10 999887777 | 10 10.0
Computerization 10 987987987 | 10 35.0 |_|
Reorganization 20 333445555 | 20 10.0 | |
Reorganization 20 987654321 | 20 15.0
Reorganization 20 888665555 | 20 NULL |_|
Newbenefits 30 987987987 | 30 5.0 | |
Newbenefits 30 987654321 | 30 20.0
Newbenefits 30 999887777 | 30 30.0
After applying the WHERE clause but before applying HAVING
Pname Pnumber Essn Pno | Hours Pname Count (*)
ProductY 2 123456789 | 2 75 | | -—®| ProductY 3
ProductY 2 453453453 2 20.0 =) Computerization 3
ProductY 2 333445555 2 10.0 |_| Reorganization 3
Computerization 10 333445555 | 10 10.0 |] Newbenefits 3
Computerization 10 999887777 | 10 10.0 4 Result of Q26
Computerization 10 987987987 | 10 | 35.0 | | (Prumber not shown)
Reorganization 20 333445555 | 20 10.0 |]
Reorganization 20 987654321 | 20 15.0
Reorganization 20 888665555 |} 20 NULL |_|
Newbenefits 30 987987987 | 30 5.0 |]
Newbenefits 30 987654321 | 30 20.0
Newbenefits 30 999887777 | 30 30.0

 

 

 

 

 

 

 

 

 

After applying the HAVING clause condition

=== Page 157 ===
128 Chapter 5 More SQL: Complex Queries, Triggers, Views, and Schema Modification

If NULLs exist in the grouping attribute, then a separate group is created for all
tuples with a NULL value in the grouping attribute. For example, if the EMPLOYEE
table had some tuples that had NULL for the grouping attribute Dno, there would be
a separate group for those tuples in the result of Q24.

Query 25. For each project, retrieve the project number, the project name, and
the number of employees who work on that project.

Q25: SELECT Pnumber, Pname, COUNT (*)
FROM PROJECT, WORKS_ON
WHERE Pnumber=Pno
GROUP BY Pnumber, Pname;

Q25 shows how we can use a join condition in conjunction with GROUP BY. In this
case, the grouping and functions are applied after the joining of the two relations.
Sometimes we want to retrieve the values of these functions only for groups that sat-
isfy certain conditions. For example, suppose that we want to modify Query 25 so
that only projects with more than two employees appear in the result. SQL provides
a HAVING clause, which can appear in conjunction with a GROUP BY clause, for this
purpose. HAVING provides a condition on the summary information regarding the
group of tuples associated with each value of the grouping attributes. Only the
groups that satisfy the condition are retrieved in the result of the query. This is illus-
trated by Query 26.

Query 26. For each project on which more than two employees work, retrieve
the project number, the project name, and the number of employees who work
on the project.

Q26: SELECT Pnumber, Pname, COUNT (*)
FROM PROJECT, WORKS_ON
WHERE Pnumber=Pno
GROUP BY Pnumber, Pname
HAVING COUNT (*) > 2;

Notice that while selection conditions in the WHERE clause limit the tuples to which
functions are applied, the HAVING clause serves to choose whole groups. Figure
5.1(b) illustrates the use of HAVING and displays the result of Q26.

Query 27. For each project, retrieve the project number, the project name, and
the number of employees from department 5 who work on the project.

Q27: SELECT Pnumber, Pname, COUNT (*)
FROM PROJECT, WORKS_ON, EMPLOYEE
WHERE Pnumber=Pno AND Ssn=Essn AND Dno=5
GROUP BY Pnumber, Pname;

Here we restrict the tuples in the relation (and hence the tuples in each group) to
those that satisfy the condition specified in the WHERE clause—namely, that they
work in department number 5. Notice that we must be extra careful when two dif-
ferent conditions apply (one to the aggregate function in the SELECT clause and
another to the function in the HAVING clause). For example, suppose that we want

=== Page 158 ===
5.1 More Complex SQL Retrieval Queries

to count the total number of employees whose salaries exceed $40,000 in each
department, but only for departments where more than five employees work. Here,
the condition (SALARY > 40000) applies only to the COUNT function in the SELECT
clause. Suppose that we write the following incorrect query:

SELECT Dname, COUNT (*)

FROM DEPARTMENT, EMPLOYEE
WHERE Dnumber=Dno AND Salary>40000
GROUP BY Dname

HAVING COUNT (*) > 5;

This is incorrect because it will select only departments that have more than five
employees who each earn more than $40,000. The rule is that the WHERE clause is
executed first, to select individual tuples or joined tuples; the HAVING clause is
applied later, to select individual groups of tuples. Hence, the tuples are already
restricted to employees who earn more than $40,000 before the function in the
HAVING clause is applied. One way to write this query correctly is to use a nested
query, as shown in Query 28.

Query 28. For each department that has more than five employees, retrieve
the department number and the number of its employees who are making
more than $40,000.

Q28: SELECT Dnumber, COUNT (*)
FROM DEPARTMENT, EMPLOYEE
WHERE Dnumber=Dno AND Salary>40000 AND
( SELECT Dno
FROM EMPLOYEE
GROUP BY Dno
HAVING COUNT (*) > 5)

5.1.9 Discussion and Summary of SQL Queries

A retrieval query in SQL can consist of up to six clauses, but only the first two—
SELECT and FROM—are mandatory. The query can span several lines, and is ended
by a semicolon. Query terms are separated by spaces, and parentheses can be used to
group relevant parts of a query in the standard way. The clauses are specified in the
following order, with the clauses between square brackets [ ... ] being optional:

SELECT <attribute and function list>
FROM <table list>

[ WHERE <condition> ]

[ GROUP BY <grouping attribute(s)> ]
[ HAVING <group condition> ]

[ ORDER BY <attribute list> ];

The SELECT clause lists the attributes or functions to be retrieved. The FROM clause
specifies all relations (tables) needed in the query, including joined relations, but
not those in nested queries. The WHERE clause specifies the conditions for selecting
the tuples from these relations, including join conditions if needed. GROUP BY

129

=== Page 159 ===
130 Chapter 5 More SQL: Complex Queries, Triggers, Views, and Schema Modification

specifies grouping attributes, whereas HAVING specifies a condition on the groups
being selected rather than on the individual tuples. The built-in aggregate functions
COUNT, SUM, MIN, MAX, and AVG are used in conjunction with grouping, but they
can also be applied to all the selected tuples in a query without a GROUP BY clause.
Finally, ORDER BY specifies an order for displaying the result of a query.

In order to formulate queries correctly, it is useful to consider the steps that define
the meaning or semantics of each query. A query is evaluated conceptually‘ by first
applying the FROM clause (to identify all tables involved in the query or to material-
ize any joined tables), followed by the WHERE clause to select and join tuples, and
then by GROUP BY and HAVING. Conceptually, ORDER BY is applied at the end to
sort the query result. If none of the last three clauses (GROUP BY, HAVING, and
ORDER BY) are specified, we can think conceptually of a query as being executed as
follows: For each combination of tuples—one from each of the relations specified in
the FROM clause—evaluate the WHERE clause; if it evaluates to TRUE, place the val-
ues of the attributes specified in the SELECT clause from this tuple combination in
the result of the query. Of course, this is not an efficient way to implement the query
in a real system, and each DBMS has special query optimization routines to decide
on an execution plan that is efficient to execute. We discuss query processing and
optimization in Chapter 19.

In general, there are numerous ways to specify the same query in SQL. This flexibil-
ity in specifying queries has advantages and disadvantages. The main advantage is
that users can choose the technique with which they are most comfortable when
specifying a query. For example, many queries may be specified with join conditions
in the WHERE clause, or by using joined relations in the FROM clause, or with some
form of nested queries and the IN comparison operator. Some users may be more
comfortable with one approach, whereas others may be more comfortable with
another. From the programmer’s and the system’s point of view regarding query
optimization, it is generally preferable to write a query with as little nesting and
implied ordering as possible.

The disadvantage of having numerous ways of specifying the same query is that this
may confuse the user, who may not know which technique to use to specify particu-
lar types of queries. Another problem is that it may be more efficient to execute a
query specified in one way than the same query specified in an alternative way.
Ideally, this should not be the case: The DBMS should process the same query in the
same way regardless of how the query is specified. But this is quite difficult in prac-
tice, since each DBMS has different methods for processing queries specified in dif-
ferent ways. Thus, an additional burden on the user is to determine which of the
alternative specifications is the most efficient to execute. Ideally, the user should
worry only about specifying the query correctly, whereas the DBMS would deter-
mine how to execute the query efficiently. In practice, however, it helps if the user is
aware of which types of constructs in a query are more expensive to process than
others (see Chapter 20).

 

The actual order of query evaluation is implementation dependent; this is just a way to conceptually
view a query in order to correctly formulate it.

=== Page 160 ===
5.2 Specifying Constraints as Assertions and Actions as Triggers

5.2 Specifying Constraints as Assertions
and Actions as Triggers

In this section, we introduce two additional features of SQL: the CREATE ASSER-
TION statement and the CREATE TRIGGER statement. Section 5.2.1 discusses
CREATE ASSERTION, which can be used to specify additional types of constraints
that are outside the scope of the built-in relational model constraints (primary and
unique keys, entity integrity, and referential integrity) that we presented in Section
3.2. These built-in constraints can be specified within the CREATE TABLE statement
of SQL (see Sections 4.1 and 4.2).

Then in Section 5.2.2 we introduce CREATE TRIGGER, which can be used to specify
automatic actions that the database system will perform when certain events and
conditions occur. This type of functionality is generally referred to as active data-
bases. We only introduce the basics of triggers in this chapter, and present a more
complete discussion of active databases in Section 26.1.

5.2.1 Specifying General Constraints as Assertions in SQL

In SQL, users can specify general constraints—those that do not fall into any of the
categories described in Sections 4.1 and 4.2—via declarative assertions, using the
CREATE ASSERTION statement of the DDL. Each assertion is given a constraint
name and is specified via a condition similar to the WHERE clause of an SQL query.
For example, to specify the constraint that the salary of an employee must not be
greater than the salary of the manager of the department that the employee works for in
SQL, we can write the following assertion:

CREATE ASSERTION SALARY_CONSTRAINT
CHECK ( NOT EXISTS ( SELECT *
FROM EMPLOYEE E, EMPLOYEE M,
DEPARTMENT D
WHERE E.Salary>M.Salary
AND E.Dno=D.Dnumber
AND D.Mgr_ssn=M.Ssn ) );

The constraint name SALARY_CONSTRAINT is followed by the keyword CHECK,
which is followed by a condition in parentheses that must hold true on every data-
base state for the assertion to be satisfied. The constraint name can be used later to
refer to the constraint or to modify or drop it. The DBMS is responsible for ensur-
ing that the condition is not violated. Any WHERE clause condition can be used, but
many constraints can be specified using the EXISTS and NOT EXISTS style of SQL
conditions. Whenever some tuples in the database cause the condition of an
ASSERTION statement to evaluate to FALSE, the constraint is violated. The con-
straint is satisfied by a database state if no combination of tuples in that database
state violates the constraint.

The basic technique for writing such assertions is to specify a query that selects any
tuples that violate the desired condition. By including this query inside a NOT EXISTS

131

=== Page 161 ===
132 Chapter 5 More SQL: Complex Queries, Triggers, Views, and Schema Modification

clause, the assertion will specify that the result of this query must be empty so that
the condition will always be TRUE. Thus, the assertion is violated if the result of the
query is not empty. In the preceding example, the query selects all employees whose
salaries are greater than the salary of the manager of their department. If the result
of the query is not empty, the assertion is violated.

Note that the CHECK clause and constraint condition can also be used to specify
constraints on individual attributes and domains (see Section 4.2.1) and on
individual tuples (see Section 4.2.4). A major difference between CREATE ASSER-
TION and the individual domain constraints and tuple constraints is that the
CHECK clauses on individual attributes, domains, and tuples are checked in SQL
only when tuples are inserted or updated. Hence, constraint checking can be imple-
mented more efficiently by the DBMS in these cases. The schema designer should
use CHECK on attributes, domains, and tuples only when he or she is sure that the
constraint can only be violated by insertion or updating of tuples. On the other hand,
the schema designer should use CREATE ASSERTION only in cases where it is not
possible to use CHECK on attributes, domains, or tuples, so that simple checks are
implemented more efficiently by the DBMS.

5.2.2 Introduction to Triggers in SQL

Another important statement in SQL is CREATE TRIGGER. In many cases it is con-
venient to specify the type of action to be taken when certain events occur and when
certain conditions are satisfied. For example, it may be useful to specify a condition
that, if violated, causes some user to be informed of the violation. A manager may
want to be informed if an employee’s travel expenses exceed a certain limit by
receiving a message whenever this occurs. The action that the DBMS must take in
this case is to send an appropriate message to that user. The condition is thus used to
monitor the database. Other actions may be specified, such as executing a specific
stored procedure or triggering other updates. The CREATE TRIGGER statement is
used to implement such actions in SQL. We discuss triggers in detail in Section 26.1
when we describe active databases. Here we just give a simple example of how trig-
gers may be used.

Suppose we want to check whenever an employee’s salary is greater than the salary
of his or her direct supervisor in the COMPANY database (see Figures 3.5 and 3.6).
Several events can trigger this rule: inserting a new employee record, changing an
employee’s salary, or changing an employee’s supervisor. Suppose that the action to
take would be to call an external stored procedure SALARY_VIOLATION,” which will
notify the supervisor. The trigger could then be written as in R5 below. Here we are
using the syntax of the Oracle database system.

R5: CREATE TRIGGER SALARY_VIOLATION
BEFORE INSERT OR UPDATE OF SALARY, SUPERVISOR_SSN
ON EMPLOYEE

5Assuming that an appropriate external procedure has been declared. We discuss stored procedures in
Chapter 13.

=== Page 162 ===
5.3 Views (Virtual Tables) in SQL

FOR EACH ROW
WHEN ( NEW.SALARY > ( SELECT SALARY FROM EMPLOYEE
WHERE SSN = NEW.SUPERVISOR_SSN ) )
INFORM_SUPERVISOR(NEW.Supervisor_ssn,
NEW.Ssn );

The trigger is given the name SALARY_VIOLATION, which can be used to remove or
deactivate the trigger later. A typical trigger has three components:

1. The event(s): These are usually database update operations that are explicitly
applied to the database. In this example the events are: inserting a new
employee record, changing an employee’s salary, or changing an employee’s
supervisor. The person who writes the trigger must make sure that all possi-
ble events are accounted for. In some cases, it may be necessary to write more
than one trigger to cover all possible cases. These events are specified after
the keyword BEFORE in our example, which means that the trigger should
be executed before the triggering operation is executed. An alternative is to
use the keyword AFTER, which specifies that the trigger should be executed
after the operation specified in the event is completed.

2. The condition that determines whether the rule action should be executed:
Once the triggering event has occurred, an optional condition may be evalu-
ated. If no condition is specified, the action will be executed once the event
occurs. If a condition is specified, it is first evaluated, and only if it evaluates
to true will the rule action be executed. The condition is specified in the
WHEN clause of the trigger.

3. The action to be taken: The action is usually a sequence of SQL statements,
but it could also be a database transaction or an external program that will
be automatically executed. In this example, the action is to execute the stored
procedure INFORM_SUPERVISOR.

Triggers can be used in various applications, such as maintaining database consis-
tency, monitoring database updates, and updating derived data automatically. A
more complete discussion is given in Section 26.1.

5.3 Views (Virtual Tables) in SQL

In this section we introduce the concept of a view in SQL. We show how views are
specified, and then we discuss the problem of updating views and how views can be
implemented by the DBMS.

5.3.1 Concept of a View in SQL

A view in SQL terminology is a single table that is derived from other tables.° These
other tables can be base tables or previously defined views. A view does not necessarily

 

SAs used in SQL, the term view is more limited than the term user view discussed in Chapters 1 and 2,
since a user view would possibly include many relations.

133

=== Page 163 ===
134 Chapter 5 More SQL: Complex Queries, Triggers, Views, and Schema Modification

exist in physical form; it is considered to be a virtual table, in contrast to base tables,
whose tuples are always physically stored in the database. This limits the possible
update operations that can be applied to views, but it does not provide any limitations
on querying a view.

We can think of a view as a way of specifying a table that we need to reference fre-
quently, even though it may not exist physically. For example, referring to the
COMPANY database in Figure 3.5 we may frequently issue queries that retrieve the
employee name and the project names that the employee works on. Rather than
having to specify the join of the three tables EMPLOYEE, WORKS_ON, and PROJECT
every time we issue this query, we can define a view that is specified as the result of
these joins. Then we can issue queries on the view, which are specified as single-
table retrievals rather than as retrievals involving two joins on three tables. We call
the EMPLOYEE, WORKS_ON, and PROJECT tables the defining tables of the view.

5.3.2 Specification of Views in SQL

In SQL, the command to specify a view is CREATE VIEW. The view is given a (vir-
tual) table name (or view name), a list of attribute names, and a query to specify the
contents of the view. If none of the view attributes results from applying functions
or arithmetic operations, we do not have to specify new attribute names for the
view, since they would be the same as the names of the attributes of the defining
tables in the default case. The views in V1 and V2 create virtual tables whose schemas
are illustrated in Figure 5.2 when applied to the database schema of Figure 3.5.

V1: CREATE VIEW WORKS_ON1
AS SELECT Fname, Lname, Pname, Hours
FROM EMPLOYEE, PROJECT, WORKS_ON
WHERE Ssn=Essn AND Pno=Pnumber;
V2: CREATE VIEW DEPT_INFO(Dept_name, No_of_emps, Total_sal)
AS SELECT Dname, COUNT (*), SUM (Salary)
FROM DEPARTMENT, EMPLOYEE

WHERE Dnumber=Dno
GROUP BY Dname;

In V1, we did not specify any new attribute names for the view WORKS_ON1
(although we could have); in this case, WORKS_ON1 inherits the names of the view
attributes from the defining tables EMPLOYEE, PROJECT, and WORKS_ON. View V2

 

 

 

 

 

 

 

Figure 5.2 WORKS_ON1
Two views specified on Fname Lname Pname Hours
the database schema of
Figure 3.5.
DEPT_INFO

 

 

 

 

 

Dept_name No_of_emps Total_sal

 

=== Page 164 ===
5.3 Views (Virtual Tables) in SQL

explicitly specifies new attribute names for the view DEPT_INFO, using a one-to-one
correspondence between the attributes specified in the CREATE VIEW clause and
those specified in the SELECT clause of the query that defines the view.

We can now specify SQL queries on a view—or virtual table—in the same way we
specify queries involving base tables. For example, to retrieve the last name and first
name of all employees who work on the ‘ProductX’ project, we can utilize the
WORKS_ON1 view and specify the query as in QV1:

QV1: SELECT Fname, Lname
FROM WORKS_ON1
WHERE Pname=‘ProductX’;

The same query would require the specification of two joins if specified on the base
relations directly; one of the main advantages of a view is to simplify the specifica-
tion of certain queries. Views are also used as a security and authorization mecha-
nism (see Chapter 24).

A view is supposed to be always up-to-date; if we modify the tuples in the base tables
on which the view is defined, the view must automatically reflect these changes.
Hence, the view is not realized or materialized at the time of view definition but
rather at the time when we specify a query on the view. It is the responsibility of the
DBMS and not the user to make sure that the view is kept up-to-date. We will discuss
various ways the DBMS can apply to keep a view up-to-date in the next subsection.

If we do not need a view any more, we can use the DROP VIEW command to dispose
of it. For example, to get rid of the view V1, we can use the SQL statement in V1A:

VIA: DROP VIEW WORKS_ON1;

5.3.3 View Implementation, View Update,
and Inline Views

The problem of efficiently implementing a view for querying is complex. Two main
approaches have been suggested. One strategy, called query modification, involves
modifying or transforming the view query (submitted by the user) into a query on
the underlying base tables. For example, the query QV1 would be automatically
modified to the following query by the DBMS:

SELECT Fname, Lname
FROM EMPLOYEE, PROJECT, WORKS_ON
WHERE Ssn=Essn AND Pno=Pnumber

AND Pname=‘ProductX’;

The disadvantage of this approach is that it is inefficient for views defined via com-
plex queries that are time-consuming to execute, especially if multiple queries are
going to be applied to the same view within a short period of time. The second
strategy, called view materialization, involves physically creating a temporary view
table when the view is first queried and keeping that table on the assumption that

135

=== Page 165 ===
136 Chapter 5 More SQL: Complex Queries, Triggers, Views, and Schema Modification

other queries on the view will follow. In this case, an efficient strategy for automati-
cally updating the view table when the base tables are updated must be developed in
order to keep the view up-to-date. Techniques using the concept of incremental
update have been developed for this purpose, where the DBMS can determine what
new tuples must be inserted, deleted, or modified in a materialized view table when
a database update is applied to one of the defining base tables. The view is generally
kept as a materialized (physically stored) table as long as it is being queried. If the
view is not queried for a certain period of time, the system may then automatically
remove the physical table and recompute it from scratch when future queries refer-
ence the view.

Updating of views is complicated and can be ambiguous. In general, an update on a
view defined on a single table without any aggregate functions can be mapped to an
update on the underlying base table under certain conditions. For a view involving
joins, an update operation may be mapped to update operations on the underlying
base relations in multiple ways. Hence, it is often not possible for the DBMS to
determine which of the updates is intended. To illustrate potential problems with
updating a view defined on multiple tables, consider the WORKS_ON1 view, and
suppose that we issue the command to update the PNAME attribute of ‘John Smith’
from ‘ProductX to ‘ProductY. This view update is shown in UV1:

UV1: UPDATE WORKS_ON1
SET Pname = ‘ProductY’
WHERE Lname=‘Smith’ AND Fname=‘John’
AND Pname=‘ProductX’;

This query can be mapped into several updates on the base relations to give the
desired update effect on the view. In addition, some of these updates will create
additional side effects that affect the result of other queries. For example, here are
two possible updates, (a) and (b), on the base relations corresponding to the view
update operation in UV1:

(a): UPDATE WORKS_ON
SET Pno= (SELECT Pnumber
FROM PROJECT
WHERE  Pname=‘ProductY’ )
WHERE Essn IN (SELECT Ssn
FROM EMPLOYEE
WHERE ~ Lname=‘Smith’ AND Fname=‘John’ )
AND
Pno= (SELECT Pnumber
FROM PROJECT
WHERE = Pname=‘ProductX’ );

(b): UPDATEPROJECT SET Pname = ‘ProductY’
WHERE Pname = ‘ProductX’;

Update (a) relates ‘John Smith’ to the “ProductY’ PROJECT tuple instead of the
“ProductX’ PROJECT tuple and is the most likely desired update. However, (b)

=== Page 166 ===
5.4 Schema Change Statements in SQL

would also give the desired update effect on the view, but it accomplishes this by
changing the name of the “ProductX’ tuple in the PROJECT relation to ‘ProductY’ It
is quite unlikely that the user who specified the view update UV1 wants the update
to be interpreted as in (b), since it also has the side effect of changing all the view
tuples with Pname = ‘ProductX’.

Some view updates may not make much sense; for example, modifying the Total_sal
attribute of the DEPT_INFO view does not make sense because Total_sal is defined to
be the sum of the individual employee salaries. This request is shown as UV2:

UV2: UPDATE DEPT_INFO
SET Total_sal=100000
WHERE Dname=‘Research’;

A large number of updates on the underlying base relations can satisfy this view
update.

Generally, a view update is feasible when only one possible update on the base rela-
tions can accomplish the desired update effect on the view. Whenever an update on
the view can be mapped to more than one update on the underlying base relations,
we must have a certain procedure for choosing one of the possible updates as the
most likely one. Some researchers have developed methods for choosing the most
likely update, while other researchers prefer to have the user choose the desired
update mapping during view definition.

In summary, we can make the following observations:

m A view with a single defining table is updatable if the view attributes contain
the primary key of the base relation, as well as all attributes with the NOT
NULL constraint that do not have default values specified.

= Views defined on multiple tables using joins are generally not updatable.
= Views defined using grouping and aggregate functions are not updatable.

In SQL, the clause WITH CHECK OPTION must be added at the end of the view defi-
nition if a view is to be updated. This allows the system to check for view updatabil-
ity and to plan an execution strategy for view updates.

It is also possible to define a view table in the FROM clause of an SQL query. This is
known as an in-line view. In this case, the view is defined within the query itself.

5.4 Schema Change Statements in SQL

In this section, we give an overview of the schema evolution commands available in
SQL, which can be used to alter a schema by adding or dropping tables, attributes,
constraints, and other schema elements. This can be done while the database is
operational and does not require recompilation of the database schema. Certain
checks must be done by the DBMS to ensure that the changes do not affect the rest
of the database and make it inconsistent.

137

=== Page 167 ===
138 Chapter 5 More SQL: Complex Queries, Triggers, Views, and Schema Modification

5.4.1 The DROP Command

The DROP command can be used to drop named schema elements, such as tables,
domains, or constraints. One can also drop a schema. For example, if a whole
schema is no longer needed, the DROP SCHEMA command can be used. There are
two drop behavior options: CASCADE and RESTRICT. For example, to remove the
COMPANY database schema and all its tables, domains, and other elements, the
CASCADE option is used as follows:

DROP SCHEMA COMPANY CASCADE;

If the RESTRICT option is chosen in place of CASCADE, the schema is dropped only
if it has no elements in it; otherwise, the DROP command will not be executed. To
use the RESTRICT option, the user must first individually drop each element in the
schema, then drop the schema itself.

If a base relation within a schema is no longer needed, the relation and its definition
can be deleted by using the DROP TABLE command. For example, if we no longer
wish to keep track of dependents of employees in the COMPANY database of Figure
4.1, we can get rid of the DEPENDENT relation by issuing the following command:

DROP TABLE DEPENDENT CASCADE;

If the RESTRICT option is chosen instead of CASCADE, a table is dropped only if it
is not referenced in any constraints (for example, by foreign key definitions in
another relation) or views (see Section 5.3) or by any other elements. With the
CASCADE option, all such constraints, views, and other elements that reference the
table being dropped are also dropped automatically from the schema, along with
the table itself.

Notice that the DROP TABLE command not only deletes all the records in the table if
successful, but also removes the table definition from the catalog. If it is desired to
delete only the records but to leave the table definition for future use, then the
DELETE command (see Section 4.4.2) should be used instead of DROP TABLE.

The DROP command can also be used to drop other types of named schema ele-
ments, such as constraints or domains.

5.4.2 The ALTER Command

The definition of a base table or of other named schema elements can be changed by
using the ALTER command. For base tables, the possible alter table actions include
adding or dropping a column (attribute), changing a column definition, and adding
or dropping table constraints. For example, to add an attribute for keeping track of
jobs of employees to the EMPLOYEE base relation in the COMPANY schema (see
Figure 4.1), we can use the command

ALTER TABLE COMPANY.EMPLOYEE ADD COLUMN Job VARCHAR(1 2);

We must still enter a value for the new attribute Job for each individual EMPLOYEE
tuple. This can be done either by specifying a default clause or by using the UPDATE

=== Page 168 ===
5.5 Summary

command individually on each tuple (see Section 4.4.3). If no default clause is spec-
ified, the new attribute will have NULLs in all the tuples of the relation immediately
after the command is executed; hence, the NOT NULL constraint is not allowed in this
case.

To drop a column, we must choose either CASCADE or RESTRICT for drop behav-
ior. If CASCADE is chosen, all constraints and views that reference the column are
dropped automatically from the schema, along with the column. If RESTRICT is
chosen, the command is successful only if no views or constraints (or other schema
elements) reference the column. For example, the following command removes the
attribute Address from the EMPLOYEE base table:

ALTER TABLE COMPANY.EMPLOYEE DROP COLUMN Address CASCADE;

It is also possible to alter a column definition by dropping an existing default clause
or by defining a new default clause. The following examples illustrate this clause:

ALTER TABLE COMPANY.DEPARTMENT ALTER COLUMN Mgr_ssn
DROP DEFAULT;

ALTER TABLE COMPANY.DEPARTMENT ALTER COLUMN Mgr_ssn
SET DEFAULT ‘333445555’;

One can also change the constraints specified on a table by adding or dropping a
named constraint. To be dropped, a constraint must have been given a name when
it was specified. For example, to drop the constraint named EMPSUPERFK in Figure
4.2 from the EMPLOYEE relation, we write:

ALTER TABLE COMPANY.EMPLOYEE
DROP CONSTRAINT EMPSUPERFK CASCADE;

Once this is done, we can redefine a replacement constraint by adding a new con-
straint to the relation, if needed. This is specified by using the ADD keyword in the
ALTER TABLE statement followed by the new constraint, which can be named or
unnamed and can be of any of the table constraint types discussed.

The preceding subsections gave an overview of the schema evolution commands of
SQL. It is also possible to create new tables and views within a database schema
using the appropriate commands. There are many other details and options; we
refer the interested reader to the SQL documents listed in the Selected Bibliography
at the end of this chapter.

5.5 Summary

In this chapter we presented additional features of the SQL database language. We
started in Section 5.1 by presenting more complex features of SQL retrieval queries,
including nested queries, joined tables, outer joins, aggregate functions, and group-
ing. In Section 5.2, we described the CREATE ASSERTION statement, which allows
the specification of more general constraints on the database, and introduced the
concept of triggers and the CREATE TRIGGER statement. Then, in Section 5.3, we
described the SQL facility for defining views on the database. Views are also called

139

=== Page 169 ===
140 Chapter 5 More SQL: Complex Queries, Triggers, Views, and Schema Modification

virtual or derived tables because they present the user with what appear to be tables;
however, the information in those tables is derived from previously defined tables.
Section 5.4 introduced the SQL ALTER TABLE statement, which is used for modify-
ing the database tables and constraints.

Table 5.2 summarizes the syntax (or structure) of various SQL statements. This sum-
mary is not meant to be comprehensive or to describe every possible SQL construct;
rather, it is meant to serve as a quick reference to the major types of constructs avail-
able in SQL. We use BNF notation, where nonterminal symbols are shown in angled
brackets <...>, optional parts are shown in square brackets [...], repetitions are shown
in braces {...}, and alternatives are shown in parentheses (...| ... | ...).”

Table 5.2. Summary of SQL Syntax

 

CREATE TABLE <table name> ( <column name> <column type> [ <attribute constraint> ]
{ , <column name> <column type> [ <attribute constraint> ] }
[ <table constraint> { , <table constraint> } ] )

 

DROP TABLE <table name>
ALTER TABLE <table name> ADD <column name> <column type>

SELECT [ DISTINCT ] <attribute list>

FROM ( <table name> { <alias> } | <joined table> ) { , ( <table name> { <alias> } | <joined table> ) }
[WHERE <condition> ]

[ GROUP BY <grouping attributes> [ HAVING <group selection condition> ] ]

[ ORDER BY <column name> [ <order> ] { , <column name> [ <order> ] } ]

 

 

<attribute list> ::= ( * | (<column name> | <function> ( ( [ DISTINCT ] <column name> | * ) ) )
{ , (<column name> | <function> ( ( [ DISTINCT] <column name> | * ) ) } ) )

 

<grouping attributes> ::= <column name> { , <column name> }
<order> ::= (ASC | DESC )

INSERT INTO <table name> [ ( <column name> { , <column name> } ) ]
( VALUES ( <constant value> , { <constant value> } ) { , (<constant value> { , <constant value> } ) }
| <select statement> )

DELETE FROM <table name>
[ WHERE <selection condition> ]

UPDATE <table name>
SET <column name> = <value expression> { , <column name> = <value expression> }
[ WHERE <selection condition> ]

CREATE [ UNIQUE] INDEX <index name>
ON <table name> ( <column name> [ <order> ] { , <column name> [ <order> ] } )
[ CLUSTER ]

DROP INDEX <index name>

 

 

 

 

 

CREATE VIEW <view name> [ ( <column name> { , <column name> } ) ]
AS <select statement>

DROP VIEW <view name>
NOTE: The commands for creating and dropping indexes are not part of standard SQL.

 

‘The full syntax of SQL is described in many voluminous documents of hundreds of pages.

=== Page 170 ===
Review Questions

5.1.

5.2.

5.3.

5.4.

Describe the six clauses in the syntax of an SQL retrieval query. Show what
type of constructs can be specified in each of the six clauses. Which of the six
clauses are required and which are optional?

Describe conceptually how an SQL retrieval query will be executed by speci-
fying the conceptual order of executing each of the six clauses.

Discuss how NULLs are treated in comparison operators in SQL. How are
NULLs treated when aggregate functions are applied in an SQL query? How
are NULLs treated if they exist in grouping attributes?

Discuss how each of the following constructs is used in SQL, and discuss the
various options for each construct. Specify what each construct is useful for.
. Nested queries.
. Joined tables and outer joins.

a
b
c. Aggregate functions and grouping.
d. Triggers.

e. Assertions and how they differ from triggers.
f. Views and their updatability.

g. Schema change commands.

Exercises

5.5.

5.6.

5.7.

Specify the following queries on the database in Figure 3.5 in SQL. Show the

query results if each query is applied to the database in Figure 3.6.

a. For each department whose average employee salary is more than
$30,000, retrieve the department name and the number of employees
working for that department.

b. Suppose that we want the number of male employees in each department
making more than $30,000, rather than all employees (as in Exercise
5.4a). Can we specify this query in SQL? Why or why not?

Specify the following queries in SQL on the database schema in Figure 1.2.
a. Retrieve the names and major departments of all straight-A students
(students who have a grade of A in all their courses).

b. Retrieve the names and major departments of all students who do not
have a grade of A in any of their courses.

In SQL, specify the following queries on the database in Figure 3.5 using the
concept of nested queries and concepts described in this chapter.

a. Retrieve the names of all employees who work in the department that has
the employee with the highest salary among all employees.

b. Retrieve the names of all employees whose supervisor’s supervisor has
888665555’ for Ssn.

Exercises

141

=== Page 171 ===
142

Chapter 5 More SQL: Complex Queries, Triggers, Views, and Schema Modification

5.8.

5.9.

Cc.

Retrieve the names of employees who make at least $10,000 more than
the employee who is paid the least in the company.

Specify the following views in SQL on the COMPANY database schema
shown in Figure 3.5.

a.

A view that has the department name, manager name, and manager
salary for every department.

. A view that has the employee name, supervisor name, and employee

salary for each employee who works in the ‘Research’ department.

. A view that has the project name, controlling department name, number

of employees, and total hours worked per week on the project for each
project.

. A view that has the project name, controlling department name, number

of employees, and total hours worked per week on the project for each
project with more than one employee working on it.

Consider the following view, DEPT_SUMMARY, defined on the COMPANY
database in Figure 3.6:

CREATE VIEW DEPT_SUMMARY (D, C, Total_s, Average_s)
AS SELECT Dno, COUNT (*), SUM (Salary), AVG (Salary)
FROM EMPLOYEE

GROUP BY Dno;

State which of the following queries and updates would be allowed on the
view. If a query or update would be allowed, show what the corresponding
query or update on the base relations would look like, and give its result
when applied to the database in Figure 3.6.

a.

oO

SELECT *
FROM DEPT_SUMMARY;
. SELECT D,C

FROM DEPT_SUMMARY
WHERE _TOTAL_S > 100000;

. SELECT D,AVERAGE_S

FROM DEPT_SUMMARY
WHERE’ C> (SELECT C FROM DEPT_SUMMARY WHERE D=4);

. UPDATE DEPT_SUMMARY

SET D=3
WHERE D=4;

. DELETE FROM DEPT_SUMMARY

WHERE C>4;

=== Page 172 ===
Selected Bibliography

Selected Bibliography

Reisner (1977) describes a human factors evaluation of SEQUEL, a precursor of
SQL, in which she found that users have some difficulty with specifying join condi-
tions and grouping correctly. Date (1984) contains a critique of the SQL language
that points out its strengths and shortcomings. Date and Darwen (1993) describes
SQL2. ANSI (1986) outlines the original SQL standard. Various vendor manuals
describe the characteristics of SQL as implemented on DB2, SQL/DS, Oracle,
INGRES, Informix, and other commercial DBMS products. Melton and Simon
(1993) give a comprehensive treatment of the ANSI 1992 standard called SQL2.
Horowitz (1992) discusses some of the problems related to referential integrity and
propagation of updates in SQL2.

The question of view updates is addressed by Dayal and Bernstein (1978), Keller
(1982), and Langerak (1990), among others. View implementation is discussed in
Blakeley et al. (1989). Negri et al. (1991) describes formal semantics of SQL queries.

There are many books that describe various aspects of SQL. For example, two refer-
ences that describe SQL-99 are Melton and Simon (2002) and Melton (2003).
Further SQL standards—SQL 2006 and SQL 2008—are described in a variety of
technical reports; but no standard references exist.

143

=== Page 173 ===
This page intentionally left blank

=== Page 174 ===
px
chapter c)

The Relational Algebra and
Relational Calculus

n this chapter we discuss the two formal languages for

the relational model: the relational algebra and the
relational calculus. In contrast, Chapters 4 and 5 described the practical language for
the relational model, namely the SQL standard. Historically, the relational algebra
and calculus were developed before the SQL language. In fact, in some ways, SQL is
based on concepts from both the algebra and the calculus, as we shall see. Because
most relational DBMSs use SQL as their language, we presented the SQL language
first.

Recall from Chapter 2 that a data model must include a set of operations to manip-
ulate the database, in addition to the data model’s concepts for defining the data-
base’s structure and constraints. We presented the structures and constraints of the
formal relational model in Chapter 3. The basic set of operations for the relational
model is the relational algebra. These operations enable a user to specify basic
retrieval requests as relational algebra expressions. The result of a retrieval is a new
relation, which may have been formed from one or more relations. The algebra
operations thus produce new relations, which can be further manipulated using
operations of the same algebra. A sequence of relational algebra operations forms a
relational algebra expression, whose result will also be a relation that represents
the result of a database query (or retrieval request).

The relational algebra is very important for several reasons. First, it provides a for-
mal foundation for relational model operations. Second, and perhaps more impor-
tant, it is used as a basis for implementing and optimizing queries in the query
processing and optimization modules that are integral parts of relational database
management systems (RDBMSs), as we shall discuss in Chapter 19. Third, some of
its concepts are incorporated into the SQL standard query language for RDBMSs.

145

=== Page 175 ===
146

Chapter 6 The Relational Algebra and Relational Calculus

Although most commercial RDBMSs in use today do not provide user interfaces for
relational algebra queries, the core operations and functions in the internal modules
of most relational systems are based on relational algebra operations. We will define
these operations in detail in Sections 6.1 through 6.4 of this chapter.

Whereas the algebra defines a set of operations for the relational model, the
relational calculus provides a higher-level declarative language for specifying rela-
tional queries. A relational calculus expression creates a new relation. In a relational
calculus expression, there is no order of operations to specify how to retrieve the
query result—only what information the result should contain. This is the main
distinguishing feature between relational algebra and relational calculus. The rela-
tional calculus is important because it has a firm basis in mathematical logic and
because the standard query language (SQL) for RDBMSs has some of its founda-
tions in a variation of relational calculus known as the tuple relational calculus.!

The relational algebra is often considered to be an integral part of the relational data
model. Its operations can be divided into two groups. One group includes set oper-
ations from mathematical set theory; these are applicable because each relation is
defined to be a set of tuples in the formal relational model (see Section 3.1). Set
operations include UNION, INTERSECTION, SET DIFFERENCE, and CARTESIAN
PRODUCT (also known as CROSS PRODUCT). The other group consists of opera-
tions developed specifically for relational databases—these include SELECT,
PROJECT, and JOIN, among others. First, we describe the SELECT and PROJECT
operations in Section 6.1 because they are unary operations that operate on single
relations. Then we discuss set operations in Section 6.2. In Section 6.3, we discuss
JOIN and other complex binary operations, which operate on two tables by com-
bining related tuples (records) based on join conditions. The COMPANY relational
database shown in Figure 3.6 is used for our examples.

Some common database requests cannot be performed with the original relational
algebra operations, so additional operations were created to express these requests.
These include aggregate functions, which are operations that can summarize data
from the tables, as well as additional types of JOIN and UNION operations, known as
OUTER JOINs and OUTER UNIONs. These operations, which were added to the orig-
inal relational algebra because of their importance to many database applications,
are described in Section 6.4. We give examples of specifying queries that use rela-
tional operations in Section 6.5. Some of these same queries were used in Chapters
4 and 5. By using the same query numbers in this chapter, the reader can contrast
how the same queries are written in the various query languages.

In Sections 6.6 and 6.7 we describe the other main formal language for relational
databases, the relational calculus. There are two variations of relational calculus.
The tuple relational calculus is described in Section 6.6 and the domain relational
calculus is described in Section 6.7. Some of the SQL constructs discussed in
Chapters 4 and 5 are based on the tuple relational calculus. The relational calculus is
a formal language, based on the branch of mathematical logic called predicate cal-

 

'SQL is based on tuple relational calculus, but also incorporates some of the operations from the rela-
tional algebra and its extensions, as illustrated in Chapters 4, 5, and 9.

=== Page 176 ===
6.1 Unary Relational Operations: SELECT and PROJECT

culus.” In tuple relational calculus, variables range over tuples, whereas in domain
relational calculus, variables range over the domains (values) of attributes. In
Appendix C we give an overview of the Query-By-Example (QBE) language, which
is a graphical user-friendly relational language based on domain relational calculus.
Section 6.8 summarizes the chapter.

For the reader who is interested in a less detailed introduction to formal relational
languages, Sections 6.4, 6.6, and 6.7 may be skipped.

6.1 Unary Relational Operations:
SELECT and PROJECT

6.1.1 The SELECT Operation

The SELECT operation is used to choose a subset of the tuples from a relation that
satisfies a selection condition.* One can consider the SELECT operation to be a
filter that keeps only those tuples that satisfy a qualifying condition. Alternatively,
we can consider the SELECT operation to restrict the tuples in a relation to only
those tuples that satisfy the condition. The SELECT operation can also be visualized
as a horizontal partition of the relation into two sets of tuples—those tuples that sat-
isfy the condition and are selected, and those tuples that do not satisfy the condition
and are discarded. For example, to select the EMPLOYEE tuples whose department is
4, or those whose salary is greater than $30,000, we can individually specify each of
these two conditions with a SELECT operation as follows:

Spno_4(EMPLOYEE)

Sgalary>30000( EM PLOYEE)

In general, the SELECT operation is denoted by

© selection condition> (R)

where the symbol o (sigma) is used to denote the SELECT operator and the selec-
tion condition is a Boolean expression (condition) specified on the attributes of
relation R. Notice that R is generally a relational algebra expression whose result is a
relation—the simplest such expression is just the name of a database relation. The
relation resulting from the SELECT operation has the same attributes as R.

The Boolean expression specified in <selection condition> is made up of a number
of clauses of the form

<attribute name> <comparison op> <constant value>
or

<attribute name> <comparison op> <attribute name>

 

2In this chapter no familiarity with first-order predicate calculus—which deals with quantified variables
and values—is assumed.

3The SELECT operation is different from the SELECT clause of SQL. The SELECT operation chooses
tuples from a table, and is sometimes called a RESTRICT or FILTER operation.

147

=== Page 177 ===
148 Chapter 6 The Relational Algebra and Relational Calculus

where <attribute name> is the name of an attribute of R, <comparison op> is nor-
mally one of the operators {=, <, S, >, 2, #}, and <constant value> is a constant value
from the attribute domain. Clauses can be connected by the standard Boolean oper-
ators and, or, and not to form a general selection condition. For example, to select
the tuples for all employees who either work in department 4 and make over
$25,000 per year, or work in department 5 and make over $30,000, we can specify
the following SELECT operation:

S(Dno=4 AND Salary>25000) OR (Dno=5 AND Salary>30000)(EM PLOYEE)

The result is shown in Figure 6.1(a).

Notice that all the comparison operators in the set {=, <, <, >, 2, #} can apply to
attributes whose domains are ordered values, such as numeric or date domains.
Domains of strings of characters are also considered to be ordered based on the col-
lating sequence of the characters. If the domain of an attribute is a set of unordered
values, then only the comparison operators in the set {=, 4} can be used. An exam-
ple of an unordered domain is the domain Color = { ‘red’, ‘blue’, ‘green’, ‘white’, ‘yel-
low’, ...}, where no order is specified among the various colors. Some domains allow
additional types of comparison operators; for example, a domain of character
strings may allow the comparison operator SUBSTRING_OF.

In general, the result of a SELECT operation can be determined as follows. The
<selection condition> is applied independently to each individual tuple t in R. This
is done by substituting each occurrence of an attribute A; in the selection condition
with its value in the tuple t[A,]. If the condition evaluates to TRUE, then tuple t is

 

Figure 6.1

Results of SELECT and PROJECT operations. (a) ©(Dno=4 AND Salary>25000) OR (Dno=5 AND Salary>30000) (EMPLOYEE).
(b) T name, Fname, Salary(E MPLOYEE). (c) TSex, Salary(EMPLOYEE).

 

 

 

 

 

 

 

 

 

(a)
Fname | Minit | Lname Ssn Bdate Address Sex | Salary | Super_ssn |Dno
Franklin T Wong 333445555 | 1955-12-08 | 638 Voss, Houston, TX M_ | 40000 |888665555] 5
Jennifer Ss Wallace | 987654321 | 1941-06-20 | 291 Berry, Bellaire, TX F 43000 |888665555] 4
Ramesh K Narayan | 666884444 | 1962-09-15 | 975 Fire Oak, Humble, TX} M_ | 38000 | 333445555 5

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

(b) (c)

Lname Fname Salary Sex | Salary
Smith John 30000 M | 30000
Wong Franklin | 40000 M | 40000
Zelaya Alicia 25000 F 25000
Wallace | Jennifer | 43000 F 43000
Narayan | Ramesh | 38000 M | 38000
English | Joyce 25000 M | 25000
Jabbar Ahmad 25000 M | 55000
Borg James 55000

 

=== Page 178 ===
6.1 Unary Relational Operations: SELECT and PROJECT

selected. All the selected tuples appear in the result of the SELECT operation. The
Boolean conditions AND, OR, and NOT have their normal interpretation, as follows:

® (cond1 AND cond2) is TRUE if both (cond1) and (cond2) are TRUE; other-
wise, it is FALSE.

=m (condl OR cond2) is TRUE if either (cond1) or (cond2) or both are TRUE;
otherwise, it is FALSE.

m® (NOT cond) is TRUE if cond is FALSE; otherwise, it is FALSE.

The SELECT operator is unary; that is, it is applied to a single relation. Moreover,
the selection operation is applied to each tuple individually; hence, selection condi-
tions cannot involve more than one tuple. The degree of the relation resulting from
a SELECT operation—its number of attributes—is the same as the degree of R. The
number of tuples in the resulting relation is always less than or equal to the number
of tuples in R. That is, |o, (R)| < |R| for any condition C. The fraction of tuples
selected by a selection condition is referred to as the selectivity of the condition.

Notice that the SELECT operation is commutative; that is,

© <condi>(F<cond2>(R)) = 5 <cond2>(F ccondi>(R))

Hence, a sequence of SELECTs can be applied in any order. In addition, we can
always combine a cascade (or sequence) of SELECT operations into a single
SELECT operation with a conjunctive (AND) condition; that is,

6 ccondt>(Fccond2>(- (.econan>(R)) )) = 9 econd1> AND<cond2> AND...AND <condn>(R)

In SQL, the SELECT condition is typically specified in the WHERE clause of a query.
For example, the following operation:

SDno=4 AND Salary>25000 (EMPLOYEE)
would correspond to the following SQL query:

SELECT *
FROM EMPLOYEE
WHERE Dno=4 AND Salary>25000;

6.1.2 The PROJECT Operation

If we think of a relation as a table, the SELECT operation chooses some of the rows
from the table while discarding other rows. The PROJECT operation, on the other
hand, selects certain columns from the table and discards the other columns. If we are
interested in only certain attributes of a relation, we use the PROJECT operation to
project the relation over these attributes only. Therefore, the result of the PROJECT
operation can be visualized as a vertical partition of the relation into two relations:
one has the needed columns (attributes) and contains the result of the operation,
and the other contains the discarded columns. For example, to list each employee’s
first and last name and salary, we can use the PROJECT operation as follows:

(EMPLOYEE)

T name, Fname, Salary

149

=== Page 179 ===
150

Chapter 6 The Relational Algebra and Relational Calculus

The resulting relation is shown in Figure 6.1(b). The general form of the PROJECT
operation is

T <attribute list> (R)

where 7 (pi) is the symbol used to represent the PROJECT operation, and <attribute
list> is the desired sublist of attributes from the attributes of relation R. Again,
notice that R is, in general, a relational algebra expression whose result is a relation,
which in the simplest case is just the name of a database relation. The result of the
PROJECT operation has only the attributes specified in <attribute list> in the same
order as they appear in the list. Hence, its degree is equal to the number of attributes
in <attribute list>.

If the attribute list includes only nonkey attributes of R, duplicate tuples are likely to
occur. The PROJECT operation removes any duplicate tuples, so the result of the
PROJECT operation is a set of distinct tuples, and hence a valid relation. This is
known as duplicate elimination. For example, consider the following PROJECT
operation:

TSex, Salary(EM PLOYEE)

The result is shown in Figure 6.1(c). Notice that the tuple <‘F, 25000> appears only
once in Figure 6.1(c), even though this combination of values appears twice in the
EMPLOYEE relation. Duplicate elimination involves sorting or some other tech-
nique to detect duplicates and thus adds more processing. If duplicates are not elim-
inated, the result would be a multiset or bag of tuples rather than a set. This was not
permitted in the formal relational model, but is allowed in SQL (see Section 4.3).

The number of tuples in a relation resulting from a PROJECT operation is always
less than or equal to the number of tuples in R. If the projection list is a superkey of
R—that is, it includes some key of R—the resulting relation has the same number of
tuples as R. Moreover,

Taristrs Metistrs(R)) = Raistrs(R)

as long as <list2> contains the attributes in <listl>; otherwise, the left-hand side is
an incorrect expression. It is also noteworthy that commutativity does not hold on
PROJECT.

In SQL, the PROJECT attribute list is specified in the SELECT clause of a query. For
example, the following operation:

Tesex, Salary(EMPLOYEE)
would correspond to the following SQL query:

SELECT DISTINCT Sex, Salary
FROM EMPLOYEE

Notice that if we remove the keyword DISTINCT from this SQL query, then dupli-
cates will not be eliminated. This option is not available in the formal relational
algebra.

=== Page 180 ===
6.1 Unary Relational Operations: SELECT and PROJECT 151

6.1.3 Sequences of Operations and the RENAME Operation

The relations shown in Figure 6.1 that depict operation results do not have any
names. In general, for most queries, we need to apply several relational algebra
operations one after the other. Either we can write the operations as a single
relational algebra expression by nesting the operations, or we can apply one oper-
ation at a time and create intermediate result relations. In the latter case, we must
give names to the relations that hold the intermediate results. For example, to
retrieve the first name, last name, and salary of all employees who work in depart-
ment number 5, we must apply a SELECT and a PROJECT operation. We can write a
single relational algebra expression, also known as an in-line expression, as follows:

(Gpno—s(EMPLOYEE))

TEname, Lname, Salary

Figure 6.2(a) shows the result of this in-line relational algebra expression.
Alternatively, we can explicitly show the sequence of operations, giving a name to
each intermediate relation, as follows:

DEP5_EMPS < 65,,_.(EMPLOYEE)
RESULT < Tiename, Lname, Salary(DEP5_EMPS)

It is sometimes simpler to break down a complex sequence of operations by specify-
ing intermediate result relations than to write a single relational algebra expression.
We can also use this technique to rename the attributes in the intermediate and

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

(a) Figure 6.2
Results of a sequence of operations. (a) TFname, Lname, Salary
(Oppo=5(EMPLOYEE)). (b) Using intermediate relations
and renaming of attributes.
(b)
TEMP
Fname Dno
John Smith 123456789 | 1965-01-09 | 731 Fondren, Houston,TX | M 333445555 | 5
Franklin T Wong 333445555 | 1955-12-08 | 638 Voss, Houston, TX 888665555 | 5
Ramesh K Narayan | 666884444 | 1962-09-15 | 975 Fire Oak, Humble, TX 333445555 | 5
Joyce A English | 453453453 | 1972-07-31 | 5631 Rice, Houston, TX F 25000 | 333445555 | 5
R
First_name | Last_name | Salary
John Smith 30000
Franklin Wong 40000
Ramesh Narayan 38000
Joyce English 25000

 

 

 

=== Page 181 ===
152 Chapter 6 The Relational Algebra and Relational Calculus

result relations. This can be useful in connection with more complex operations
such as UNION and JOIN, as we shall see. To rename the attributes in a relation, we
simply list the new attribute names in parentheses, as in the following example:

TEMP < Gppo-s(EMPLOYEE)
R(First_name, Last_name, Salary) — Tename, Lname, Salary( TEMP)

These two operations are illustrated in Figure 6.2(b).

If no renaming is applied, the names of the attributes in the resulting relation of a
SELECT operation are the same as those in the original relation and in the same
order. For a PROJECT operation with no renaming, the resulting relation has the
same attribute names as those in the projection list and in the same order in which
they appear in the list.

We can also define a formal RENAME operation—which can rename either the rela-
tion name or the attribute names, or both—as a unary operator. The general
RENAME operation when applied to a relation R of degree n is denoted by any of the
following three forms:

Psp, 2, .... Bn) (R) or Ps(R) or Pai, B2, ..., Bn) (R)

where the symbol p (rho) is used to denote the RENAME operator, S is the new rela-
tion name, and B,, B,, ..., B, are the new attribute names. The first expression
renames both the relation and its attributes, the second renames the relation only,
and the third renames the attributes only. If the attributes of R are (A,, A,, ..., A,,) in
that order, then each A, is renamed as B,.

In SQL, a single query typically represents a complex relational algebra expression.
Renaming in SQL is accomplished by aliasing using AS, as in the following example:

SELECT E.Fname AS First_name, E.Lname AS Last_name, E.Salary AS Salary
FROM EMPLOYEE AS E
WHERE E.Dno=5,

6.2 Relational Algebra Operations
from Set Theory

6.2.1 The UNION, INTERSECTION, and MINUS Operations

The next group of relational algebra operations are the standard mathematical
operations on sets. For example, to retrieve the Social Security numbers of all
employees who either work in department 5 or directly supervise an employee who
works in department 5, we can use the UNION operation as follows:*

 

“As a single relational algebra expression, this becomes Result <— Tesgn (Spnoes (EMPLOYEE) ) U

Tsuper_ssn (Spno=s (EMPLOYEE))

=== Page 182 ===
6.2 Relational Algebra Operations from Set Theory

DEP5_EMPS < 65,,_.(EMPLOYEE)
RESULT1 < 1,,(DEP5_EMPS)
RESULT2(Ssn) < Mguper_ ggn(DEP5_EMPS)
RESULT < RESULT1 U RESULT2

The relation RESULT1 has the Ssn of all employees who work in department 5,
whereas RESULT2 has the Ssn of all employees who directly supervise an employee
who works in department 5. The UNION operation produces the tuples that are in
either RESULT1 or RESULT2 or both (see Figure 6.3), while eliminating any dupli-
cates. Thus, the Ssn value 333445555’ appears only once in the result.

Several set theoretic operations are used to merge the elements of two sets in vari-
ous ways, including UNION, INTERSECTION, and SET DIFFERENCE (also called
MINUS or EXCEPT). These are binary operations; that is, each is applied to two sets
(of tuples). When these operations are adapted to relational databases, the two rela-
tions on which any of these three operations are applied must have the same type of
tuples; this condition has been called union compatibility or type compatibility. Two
relations R(A,, A,, ..., A,,) and S(B,, B,, ..., B,,) are said to be union compatible (or
type compatible) if they have the same degree n and if dom(A;) = dom(B;) for 1 <i
<n. This means that the two relations have the same number of attributes and each
corresponding pair of attributes has the same domain.

We can define the three operations UNION, INTERSECTION, and SET DIFFERENCE
on two union-compatible relations R and S as follows:

= UNION: The result of this operation, denoted by R U S, is a relation that
includes all tuples that are either in R or in S or in both R and S. Duplicate
tuples are eliminated.

m INTERSECTION: The result of this operation, denoted by R17 S, is a relation
that includes all tuples that are in both R and S.

= SET DIFFERENCE (or MINUS): The result of this operation, denoted by
R-S, is a relation that includes all tuples that are in R but not in S.

We will adopt the convention that the resulting relation has the same attribute
names as the first relation R. It is always possible to rename the attributes in the
result using the rename operator.

153

 

RESULT1 RESULT2 RESULT Figure 6.3

Sea oon oon Result of the UNION operation
RESULT < RESULT1 U

 

 

 

 

 

123456789 333445555 123456789
333445555 888665555 333445555
666884444 666884444
453453453 453453453
888665555

RESULT2.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

=== Page 183 ===
154 Chapter 6 The Relational Algebra and Relational Calculus

Figure 6.4 illustrates the three operations. The relations STUDENT and
INSTRUCTOR in Figure 6.4(a) are union compatible and their tuples represent the
names of students and the names of instructors, respectively. The result of the
UNION operation in Figure 6.4(b) shows the names of all students and instructors.
Note that duplicate tuples appear only once in the result. The result of the
INTERSECTION operation (Figure 6.4(c)) includes only those who are both students
and instructors.

Notice that both UNION and INTERSECTION are commutative operations; that is,
RUS=SUR and RAS=SQOR

Both UNION and INTERSECTION can be treated as n-ary operations applicable to
any number of relations because both are also associative operations; that is,

RU(SUT)=(RUS)UT and (RNS)AT=RA(SOT)
The MINUS operation is not commutative; that is, in general,

R-S#S-R

 

Figure 6.4

The set operations UNION, INTERSECTION, and MINUS. (a) Two union-compatible relations.

(b) STUDENT U INSTRUCTOR. (c) STUDENT J INSTRUCTOR. (d) STUDENT — INSTRUCTOR.
(e) INSTRUCTOR — STUDENT.

(a) STUDENT INSTRUCTOR

 

()
Susan Yao
Ramesh
Johnny

Barbara

Amy

Tiny

Ernest Gilbert

Susan Yao John Smith

 

Ramesh | Shah Ricardo | Browne

 

  

Johnny Kohler Susan Yao

  
  
 

Johnson
Shah

Barbara Francis

 

   

Amy Ramesh

 

Jimmy

Joh
Ricardo
Francis

(e)

wang
Gilbert

Ricardo

y

Francis Johnson

 

 

 

=== Page 184 ===
6.2 Relational Algebra Operations from Set Theory

Figure 6.4(d) shows the names of students who are not instructors, and Figure
6.4(e) shows the names of instructors who are not students.

Note that INTERSECTION can be expressed in terms of union and set difference as
follows:

RAS=((RUS)-(R-S))-(S-R)

In SQL, there are three operations—UNION, INTERSECT, and EXCEPT—that corre-
spond to the set operations described here. In addition, there are multiset opera-
tions (UNION ALL, INTERSECT ALL, and EXCEPT ALL) that do not eliminate
duplicates (see Section 4.3.4).

6.2.2 The CARTESIAN PRODUCT (CROSS PRODUCT)
Operation

Next, we discuss the CARTESIAN PRODUCT operation—also known as CROSS
PRODUCT or CROSS JOIN-which is denoted by x. This is also a binary set opera-
tion, but the relations on which it is applied do not have to be union compatible. In
its binary form, this set operation produces a new element by combining every
member (tuple) from one relation (set) with every member (tuple) from the other
relation (set). In general, the result of R(A,, A,, ..., A,,) x S(B,, B,, ..., B,,) is a rela-
tion Q with degree n + m attributes Q(A), A,, ..., A, B,, B, ..., B,,), in that order.
The resulting relation Q has one tuple for each combination of tuples—one from R
and one from S. Hence, if R has np tuples (denoted as |R| = ng), and S has n, tuples,
then R x S will have np * ng tuples.

The n-ary CARTESIAN PRODUCT operation is an extension of the above concept,
which produces new tuples by concatenating all possible combinations of tuples
from n underlying relations.

In general, the CARTESIAN PRODUCT operation applied by itself is generally mean-
ingless. It is mostly useful when followed by a selection that matches values of
attributes coming from the component relations. For example, suppose that we
want to retrieve a list of names of each female employee’s dependents. We can do
this as follows:

FEMALE_EMPS < og,,_.»(EMPLOYEE)

EMPNAMES © Trrname, name, Ssn(FEMALE_EMPS)
EMP_DEPENDENTS < EMPNAMES x DEPENDENT
ACTUAL_DEPENDENTS < 06, ¢eo,(EMP_DEPENDENTS)
RESULT < Trrname, Lname, Dependent name( ACTUAL_DEPENDENTS)

The resulting relations from this sequence of operations are shown in Figure 6.5.
The EMP_DEPENDENTS relation is the result of applying the CARTESIAN PROD-
UCT operation to EMPNAMES from Figure 6.5 with DEPENDENT from Figure 3.6.
In EMP_DEPENDENTS, every tuple from EMPNAMES is combined with every tuple
from DEPENDENT, giving a result that is not very meaningful (every dependent is
combined with every female employee). We want to combine a female employee
tuple only with her particular dependents—namely, the DEPENDENT tuples whose

155

=== Page 185 ===
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

156 Chapter 6 The Relational Algebra and Relational Calculus

Figure 6.5

The Cartesian Product (Cross Product) operation.
FEMALE_EMPS
Fname |Minit | Lname Ssn Bdate Address Sex) Salary! Super_ssn |Dno
Alicia J Zelaya | 999887777 |1968-07-19 | 3321Castle, Spring, TX | F |25000|987654321
Jennifer} S | Wallace} 987654321 |1941-06-20 | 291Berry, Bellaire, TX 43000/888665555| 4
Joyce A_ | English | 453453453 |1972-07-31 | 5631 Rice, Houston, TX} F |25000|333445555] 5
EMPNAMES
Fname | Lname Ssn
Alicia | Zelaya | 999887777
Jennifer | Wallace | 987654321
Joyce | English | 453453453
EMP_DEPENDENTS
Fname | Lname Ssn Essn Dependent_name | Sex Bdate
Alicia | Zelaya | 999887777 | 333445555 Alice F | 1986-04-05
Alicia | Zelaya | 999887777 | 333445555 Theodore M | 1983-10-25
Alicia | Zelaya | 999887777 | 333445555 Joy F | 1958-05-03
Alicia | Zelaya | 999887777 | 987654321 Abner M | 1942-02-28
Alicia | Zelaya | 999887777 | 123456789 Michael M | 1988-01-04
Alicia | Zelaya | 999887777 | 123456789 Alice F | 1988-12-30
Alicia | Zelaya | 999887777 | 123456789 Elizabeth F | 1967-05-05
Jennifer | Wallace | 987654321 | 333445555 Alice F | 1986-04-05
Jennifer | Wallace | 987654321 | 333445555 Theodore M | 1983-10-25
Jennifer | Wallace | 987654321 | 333445555 Joy F | 1958-05-03
Jennifer | Wallace | 987654321 | 987654321 Abner M | 1942-02-28
Jennifer | Wallace | 987654321 | 123456789 Michael M | 1988-01-04
Jennifer | Wallace | 987654321 | 123456789 Alice F | 1988-12-30
Jennifer | Wallace | 987654321 | 123456789 Elizabeth F | 1967-05-05
Joyce | English | 453453453 | 333445555 Alice F | 1986-04-05
Joyce | English | 453453453 | 333445555 Theodore M | 1983-10-25
Joyce | English | 453453453 | 333445555 Joy F | 1958-05-03
Joyce | English | 453453453 | 987654321 Abner M | 1942-02-28
Joyce | English | 453453453 | 123456789 Michael M | 1988-01-04
Joyce | English | 453453453 | 123456789 Alice F | 1988-12-30
Joyce | English | 453453453 | 123456789 Elizabeth F | 1967-05-05
ACTUAL_DEPENDENTS
Fname | Lname Ssn Essn Dependent_name Sex Bdate
Jennifer | Wallace | 987654321 | 987654321 Abner M | 1942-02-28
RESULT
Fname | Lname | Dependent_name
Jennifer | Wallace Abner

 

 

 

 

=== Page 186 ===
6.3 Binary Relational Operations: JOIN and DIVISION

Essn value match the Ssn value of the EMPLOYEE tuple. The ACTUAL_DEPENDENTS
relation accomplishes this. The EMP_DEPENDENTS relation is a good example of
the case where relational algebra can be correctly applied to yield results that make
no sense at all. It is the responsibility of the user to make sure to apply only mean-
ingful operations to relations.

The CARTESIAN PRODUCT creates tuples with the combined attributes of two rela-
tions. We can SELECT related tuples only from the two relations by specifying an
appropriate selection condition after the Cartesian product, as we did in the preced-
ing example. Because this sequence of CARTESIAN PRODUCT followed by SELECT
is quite commonly used to combine related tuples from two relations, a special oper-
ation, called JOIN, was created to specify this sequence as a single operation. We dis-
cuss the JOIN operation next.

In SQL, CARTESIAN PRODUCT can be realized by using the CROSS JOIN option in
joined tables (see Section 5.1.6). Alternatively, if there are two tables in the WHERE
clause and there is no corresponding join condition in the query, the result will also
be the CARTESIAN PRODUCT of the two tables (see Q10 in Section 4.3.3).

6.3 Binary Relational Operations:
JOIN and DIVISION

6.3.1 The JOIN Operation

The JOIN operation, denoted by ™, is used to combine related tuples from two rela-
tions into single “longer” tuples. This operation is very important for any relational
database with more than a single relation because it allows us to process relation-
ships among relations. To illustrate JOIN, suppose that we want to retrieve the name
of the manager of each department. To get the manager’s name, we need to combine
each department tuple with the employee tuple whose Ssn value matches the
Mgr_ssn value in the department tuple. We do this by using the JOIN operation and
then projecting the result over the necessary attributes, as follows:

DEPT_MGR < DEPARTMENT 1 iyo, gon—Son EMPLOYEE
RESULT <— TDname, Lname, Fname(DEPT_MGR)

The first operation is illustrated in Figure 6.6. Note that Mgr_ssn is a foreign key of
the DEPARTMENT relation that references Ssn, the primary key of the EMPLOYEE
relation. This referential integrity constraint plays a role in having matching tuples
in the referenced relation EMPLOYEE.

The JOIN operation can be specified as a CARTESIAN PRODUCT operation followed
by a SELECT operation. However, JOIN is very important because it is used very fre-
quently when specifying database queries. Consider the earlier example illustrating
CARTESIAN PRODUCT, which included the following sequence of operations:

EMP_DEPENDENTS <— EMPNAMES x DEPENDENT
ACTUAL_DEPENDENTS < o6,,_¢¢¢,(EMP_DEPENDENTS)

157

=== Page 187 ===
158 Chapter 6 The Relational Algebra and Relational Calculus

 

 

 

 

 

 

 

 

 

 

 

 

 

DEPT_MGR
Dname Dnumber Mgr_ssn pee Fname | Minit Lname Ssn
Research 5 333445555 ut Franklin T Wong 333445555
Administration 4 987654321 “t+ | Jennifer Ss Wallace | 987654321
Headquarters 1 888665555 ut James E Borg 888665555
Figure 6.6

Result of the JOIN operation DEPT_MGR <— DEPARTMENT

 

Magr_ssn=Ssn=MPLOYEE.

 

These two operations can be replaced with a single JOIN operation as follows:

ACTUAL_DEPENDENTS < EMPNAMES DEPENDENT

Ssn=Essn

The general form of a JOIN operation on two relations” R(A,, A,, ..., A,,) and S(B,,
B,, ..., B,,) is

RW

<join condition>

The result of the JOIN is a relation Q with n + m attributes Q(A,, A), ..., A,» B,, B,,

..,B,,) in that order; Q has one tuple for each combination of tuples—one from R
and one from S—whenever the combination satisfies the join condition. This is the
main difference between CARTESIAN PRODUCT and JOIN. In JOIN, only combina-
tions of tuples satisfying the join condition appear in the result, whereas in the
CARTESIAN PRODUCT all combinations of tuples are included in the result. The
join condition is specified on attributes from the two relations R and S and is evalu-
ated for each combination of tuples. Each tuple combination for which the join
condition evaluates to TRUE is included in the resulting relation Q as a single com-
bined tuple.

A general join condition is of the form
<condition> AND <condition> AND...AND <condition>

where each <condition> is of the form A; 0 B,, A; is an attribute of R, B is an attrib-
ute of S, A; and B. have the same domain, and 0 (theta) is one of the comparison
operators {=, <, S, >, 2, #}. A JOIN operation with such a general join condition is
called a THETA JOIN. Tuples whose join attributes are NULL or for which the join
condition is FALSE do not appear in the result. In that sense, the JOIN operation does
not necessarily preserve all of the information in the participating relations, because
tuples that do not get combined with matching ones in the other relation do not
appear in the result.

 

5Again, notice that Rand Scan be any relations that result from general relational algebra expressions.

=== Page 188 ===
6.3 Binary Relational Operations: JOIN and DIVISION

6.3.2 Variations of JOIN: The EQUIJOIN
and NATURAL JOIN

The most common use of JOIN involves join conditions with equality comparisons
only. Such a JOIN, where the only comparison operator used is =, is called an
EQUUJOIN. Both previous examples were EQUUOINs. Notice that in the result of an
EQUUOIN we always have one or more pairs of attributes that have identical values
in every tuple. For example, in Figure 6.6, the values of the attributes Mgr_ssn and
Ssn are identical in every tuple of DEPT_MGR (the EQUUOIN result) because the
equality join condition specified on these two attributes requires the values to be
identical in every tuple in the result. Because one of each pair of attributes with
identical values is superfluous, a new operation called NATURAL JOIN—denoted by
+—-was created to get rid of the second (superfluous) attribute in an EQUIJOIN con-
dition.® The standard definition of NATURAL JOIN requires that the two join attrib-
utes (or each pair of join attributes) have the same name in both relations. If this is
not the case, a renaming operation is applied first.

Suppose we want to combine each PROJECT tuple with the DEPARTMENT tuple that
controls the project. In the following example, first we rename the Dnumber attribute
of DEPARTMENT to Dnum—so that it has the same name as the Dnum attribute in
PROJECT—and then we apply NATURAL JOIN:

PROJ_DEPT «PROJECT * Pipname, Dnum, Mgr_ssn, Mgr start date) (DEPARTMENT)

The same query can be done in two steps by creating an intermediate table DEPT as
follows:

DEPT <— P(Dname, Dnum, Mgr_ssn, Mgr_start_ date) (DEPARTMENT)
PROJ_DEPT <— PROJECT * DEPT

The attribute Dnum is called the join attribute for the NATURAL JOIN operation,
because it is the only attribute with the same name in both relations. The resulting
relation is illustrated in Figure 6.7(a). In the PROJ_DEPT relation, each tuple com-
bines a PROJECT tuple with the DEPARTMENT tuple for the department that con-
trols the project, but only one join attribute value is kept.

If the attributes on which the natural join is specified already have the same names in
both relations, renaming is unnecessary. For example, to apply a natural join on the
Dnumber attributes of DEPARTMENT and DEPT_LOCATIONS, it is sufficient to write

DEPT_LOCS « DEPARTMENT * DEPT_LOCATIONS

The resulting relation is shown in Figure 6.7(b), which combines each department
with its locations and has one tuple for each location. In general, the join condition
for NATURAL JOIN is constructed by equating each pair of join attributes that have
the same name in the two relations and combining these conditions with AND.
There can bea list of join attributes from each relation, and each corresponding pair
must have the same name.

 

SNATURAL JOIN is basically an EQUIJOIN followed by the removal of the superfluous attributes.

159

=== Page 189 ===
160 Chapter 6 The Relational Algebra and Relational Calculus

 

(a)
PROJ_DEPT

Pname Pnumber Mgr_ssn Mgr_start_date
ProductX 1 Bellaire 5 Research 333445555 1988-05-22
ProductY 2 Sugarland 333445555 1988-05-22
ProductZ 3 333445555 | 1988-05-22

Computerization

 

Reorganization

Newbenefits

 

(b)
DEPT_LOCS
Dname
Headquarters

 

5
10 Stafford 4 Administration | 987654321 1995-01-01
20 Houston 1 Headquarters | 888665555 1981-06-19

30 Stafford 987654321 | 1995-01-01

 

 

 

 

 

Administration

888665555 1981-06-19 Houston
987654321 1995-01-01 Stafford

 

 

4
5
5

Research

Research 333445555 1988-05-22 Sugarland

Research 333445555 1988-05-22 Houston
Figure 6.7

 

 

Results of two NATURAL JOIN operations. (a) PROJ_DEPT < PROJECT * DEPT.
(b) DEPT_LOCS + DEPARTMENT * DEPT_LOCATIONS.

 

A more general, but nonstandard definition for NATURAL JOIN is

Qe R* (cists), (<tist2>)9

In this case, <list1> specifies a list of i attributes from R, and <list2> specifies a list
of i attributes from S. The lists are used to form equality comparison conditions
between pairs of corresponding attributes, and the conditions are then ANDed
together. Only the list corresponding to attributes of the first relation R—<list1 >—
is kept in the result Q.

Notice that if no combination of tuples satisfies the join condition, the result of a
JOIN is an empty relation with zero tuples. In general, if R has np tuples and S has n,
tuples, the result of a JOIN operation R <join condition> 5 will have between zero and
Np * ng tuples. The expected size of the join result divided by the maximum size np *
ng leads to a ratio called join selectivity, which is a property of each join condition.
If there is no join condition, all combinations of tuples qualify and the JOIN degen-
erates into a CARTESIAN PRODUCT, also called CROSS PRODUCT or CROSS JOIN.

As we can see, a single JOIN operation is used to combine data from two relations so
that related information can be presented in a single table. These operations are also
known as inner joins, to distinguish them from a different join variation called

=== Page 190 ===
6.3 Binary Relational Operations: JOIN and DIVISION

outer joins (see Section 6.4.4). Informally, an inner join is a type of match and com-
bine operation defined formally as a combination of CARTESIAN PRODUCT and
SELECTION. Note that sometimes a join may be specified between a relation and
itself, as we will illustrate in Section 6.4.3. The NATURAL JOIN or EQUUOIN opera-
tion can also be specified among multiple tables, leading to an n-way join. For
example, consider the following three-way join:

((PROJECT DEPARTMENT) EMPLOYEE)

Dnum=Dnumber Mgr_ssn=Ssn

This combines each project tuple with its controlling department tuple into a single
tuple, and then combines that tuple with an employee tuple that is the department
manager. The net result is a consolidated relation in which each tuple contains this
project-department-manager combined information.

In SQL, JOIN can be realized in several different ways. The first method is to specify
the <join conditions> in the WHERE clause, along with any other selection condi-
tions. This is very common, and is illustrated by queries Q1, Q1A, Q1B, Q2, and Q8
in Sections 4.3.1 and 4.3.2, as well as by many other query examples in Chapters 4
and 5. The second way is to use a nested relation, as illustrated by queries Q4A and
Q16 in Section 5.1.2. Another way is to use the concept of joined tables, as illus-
trated by the queries Q1A, Q1B, Q8B, and Q2A in Section 5.1.6. The construct of
joined tables was added to SQL2 to allow the user to specify explicitly all the various
types of joins, because the other methods were more limited. It also allows the user
to clearly distinguish join conditions from the selection conditions in the WHERE
clause.

6.3.3 A Complete Set of Relational Algebra Operations

It has been shown that the set of relational algebra operations {6, 7, U, p, —, X} is a
complete set; that is, any of the other original relational algebra operations can be
expressed as a sequence of operations from this set. For example, the INTERSECTION
operation can be expressed by using UNION and MINUS as follows:

RAS=(RU S)-(R-S) U (S-R))

Although, strictly speaking, INTERSECTION is not required, it is inconvenient to
specify this complex expression every time we wish to specify an intersection. As
another example, a JOIN operation can be specified as a CARTESIAN PRODUCT fol-
lowed by a SELECT operation, as we discussed:

<condition> (R x S)

Similarly, a NATURAL JOIN can be specified as a CARTESIAN PRODUCT preceded by
RENAME and followed by SELECT and PROJECT operations. Hence, the various
JOIN operations are also not strictly necessary for the expressive power of the rela-
tional algebra. However, they are important to include as separate operations
because they are convenient to use and are very commonly applied in database
applications. Other operations have been included in the basic relational algebra for
convenience rather than necessity. We discuss one of these—the DIVISION opera-
tion—in the next section.

RW S= 6 <condition>

161

=== Page 191 ===
162 Chapter 6 The Relational Algebra and Relational Calculus

6.3.4 The DIVISION Operation

The DIVISION operation, denoted by +, is useful for a special kind of query that
sometimes occurs in database applications. An example is Retrieve the names of
employees who work on all the projects that John Smith’ works on. To express this
query using the DIVISION operation, proceed as follows. First, retrieve the list of
project numbers that ‘John Smith’ works on in the intermediate relation
SMITH_PNOS:

SMITH <— OFname=‘John’ AND Lname=‘smith’ (EM PLOYEE)
SMITH_PNOS © tp,,,(WORKS_ON SMITH)

Essn=Ssn

Next, create a relation that includes a tuple <Pno, Essn> whenever the employee
whose Ssn is Essn works on the project whose number is Pno in the intermediate
relation SSN_PNOS:

SSN_PNOS © Trego, pno(WORKS_ON)

Finally, apply the DIVISION operation to the two relations, which gives the desired
employees’ Social Security numbers:

SSNS(Ssn) < SSN_PNOS + SMITH_PNOS
RESULT © tigname. Lname(SSNS * EMPLOYEE)

The preceding operations are shown in Figure 6.8(a).

Figure 6.8
The DIVISION operation. (a) Dividing SSN_PNOS by SMITH_PNOS. (b) TH R+S.

(a)
SSN_PNOS SMITH_PNOS

 

Essn Pno Pno
123456789
123456789
666884444
453453453
453453453
333445555
333445555
333445555
333445555
999887777
999887777
987987987
987987987
987654321
987654321
888665555

 

 

 

 

 

SSNS
Ssn

+

 

 

123456789
453453453

 

 

 

 

 

 

 

 

 

=== Page 192 ===
6.3 Binary Relational Operations: JOIN and DIVISION

In general, the DIVISION operation is applied to two relations R(Z) + S(X), where
the attributes of R are a subset of the attributes of S; that is, X Cc Z. Let Y be the set
of attributes of R that are not attributes of S; that is, Y= Z—X (and hence Z= X U
Y). The result of DIVISION is a relation T(Y) that includes a tuple t if tuples tp appear
in R with tp [Y] = t, and with tp [X] = t, for every tuple t, in S. This means that, for
a tuple t to appear in the result T of the DIVISION, the values in tf must appear in R in
combination with every tuple in S. Note that in the formulation of the DIVISION
operation, the tuples in the denominator relation S restrict the numerator relation R
by selecting those tuples in the result that match all values present in the denomina-
tor. It is not necessary to know what those values are as they can be computed by
another operation, as illustrated in the SMITH_PNOS relation in the above example.

Figure 6.8(b) illustrates a DIVISION operation where X = {A}, Y = {B}, and Z = {A,
B}. Notice that the tuples (values) b, and b, appear in R in combination with all
three tuples in S; that is why they appear in the resulting relation T. All other values
of B in R do not appear with all the tuples in S and are not selected: b, does not
appear with a,, and b, does not appear with a,.

The DIVISION operation can be expressed as a sequence of 1, x, and — operations as
follows:

Tl — n,(R)
T2 — ny((S x T1) — R)
T<«T1-T2

The DIVISION operation is defined for convenience for dealing with queries that
involve universal quantification (see Section 6.6.7) or the all condition. Most
RDBMS implementations with SQL as the primary query language do not directly
implement division. SQL has a roundabout way of dealing with the type of query
illustrated above (see Section 5.1.4, queries Q3A and Q3B). Table 6.1 lists the various
basic relational algebra operations we have discussed.

6.3.5 Notation for Query Trees

In this section we describe a notation typically used in relational systems to repre-
sent queries internally. The notation is called a query tree or sometimes it is known
as a query evaluation tree or query execution tree. It includes the relational algebra
operations being executed and is used as a possible data structure for the internal
representation of the query in an RDBMS.

A query tree is a tree data structure that corresponds to a relational algebra expres-
sion. It represents the input relations of the query as leaf nodes of the tree, and rep-
resents the relational algebra operations as internal nodes. An execution of the
query tree consists of executing an internal node operation whenever its operands
(represented by its child nodes) are available, and then replacing that internal node
by the relation that results from executing the operation. The execution terminates
when the root node is executed and produces the result relation for the query.

163

=== Page 193 ===
164 Chapter 6 The Relational Algebra and Relational Calculus

Table 6.1 Operations of Relational Algebra

 

OPERATION
SELECT

PROJECT

THETA JOIN

EQUIJOIN

NATURAL JOIN

UNION

INTERSECTION

DIFFERENCE

CARTESIAN
PRODUCT

DIVISION

PURPOSE

Selects all tuples that satisfy the selection condition
from a relation R.

Produces a new relation with only some of the attrib-
utes of R, and removes duplicate tuples.

Produces all combinations of tuples from R, and R,
that satisfy the join condition.

Produces all the combinations of tuples from R, and
R, that satisfy a join condition with only equality
comparisons.

Same as EQUIUJOIN except that the join attributes of R,
are not included in the resulting relation; if the join
attributes have the same names, they do not have to
be specified at all.

Produces a relation that includes all the tuples in R,
or R, or both R, and R,; R, and R, must be union
compatible.

Produces a relation that includes all the tuples in both
R, and R,; R, and R, must be union compatible.

Produces a relation that includes all the tuples in R,
that are not in R,; R, and R, must be union compatible.

Produces a relation that has the attributes of R, and
R, and includes as tuples all possible combinations of
tuples from R, and R,.

Produces a relation R(X) that includes all tuples t[X]
in R,(Z) that appear in R, in combination with every
tuple from R,(Y), where Z= X U Y.

NOTATION

oO R)

<selection condition> (

Te attribute list> (R)

R,&

1° © <join condition>

R

2

R,&X

1° © <join condition>

R,, OR

1 (<join attributes 1>),

R

(<join attributes 2>) *‘2

R

(<join attributes 1>),

xo. cys
R, <join condition> ~*2?

OR R,*

(<join attributes 2>)

OR R, * R,
R, UR,

R

R(Z) =R,(¥)

R,

 

Figure 6.9 shows a query tree for Query 2 (see Section 4.3.1): For every project
located in ‘Stafford’ list the project number, the controlling department number, and
the department manager’s last name, address, and birth date. This query is specified
on the relational schema of Figure 3.5 and corresponds to the following relational
algebra expression:

Tpnumber, Dnum, Lname, Address, Bdate! ( (Spiccation="statford’ (PROJ ECT))
(DEPARTMENT)) >t (EMPLOYEE))

Dnum=Dnumber Mgr_ssn=Ssn

In Figure 6.9, the three leaf nodes P, D, and E represent the three relations PROJECT,
DEPARTMENT, and EMPLOYEE. The relational algebra operations in the expression

=== Page 194 ===
6.4 Additional Relational Operations

n P.Pnumber,P.Dnum,E.Lname,E.Address,E.Bdate

(3)
* D.Mgr_ssn=E.Ssn

(2)
* B Dnum=D.Dnumber EMPLOYEE

“) ZO
© P Plocation= ‘Stafford’ D DEPARTMENT

 

 

 

 

 

 

 

 

Figure 6.9

165

Query tree corresponding

 

 

 

 

to the relational algebra
PROJECT expression for Q2.

 

are represented by internal tree nodes. The query tree signifies an explicit order of
execution in the following sense. In order to execute Q2, the node marked (1) in
Figure 6.9 must begin execution before node (2) because some resulting tuples of
operation (1) must be available before we can begin to execute operation (2).
Similarly, node (2) must begin to execute and produce results before node (3) can
start execution, and so on. In general, a query tree gives a good visual representation
and understanding of the query in terms of the relational operations it uses and is
recommended as an additional means for expressing queries in relational algebra.
We will revisit query trees when we discuss query processing and optimization in
Chapter 19.

6.4 Additional Relational Operations

Some common database requests—which are needed in commercial applications
for RDBMSs—cannot be performed with the original relational algebra operations
described in Sections 6.1 through 6.3. In this section we define additional opera-
tions to express these requests. These operations enhance the expressive power of
the original relational algebra.

6.4.1 Generalized Projection

The generalized projection operation extends the projection operation by allowing
functions of attributes to be included in the projection list. The generalized form
can be expressed as:

Tr, £2, .., Fn (R)

=== Page 195 ===
166 Chapter 6 The Relational Algebra and Relational Calculus

where F,, F,, ..., F,, are functions over the attributes in relation R and may involve
arithmetic operations and constant values. This operation is helpful when develop-
ing reports where computed values have to be produced in the columns of a query
result.

As an example, consider the relation
EMPLOYEE (Ssn, Salary, Deduction, Years_service)
A report may be required to show

Net Salary = Salary — Deduction,
Bonus = 2000 * Years_service, and
Tax = 0.25 * Salary.

Then a generalized projection combined with renaming may be used as follows:

REPORT <— P(Ssn, Net_salary, Bonus, Tax) (Msn, Salary — Deduction, 2000 * Years_service,

0.25 * Salary(EM PLOYEE)).

6.4.2 Aggregate Functions and Grouping

Another type of request that cannot be expressed in the basic relational algebra is to
specify mathematical aggregate functions on collections of values from the data-
base. Examples of such functions include retrieving the average or total salary of all
employees or the total number of employee tuples. These functions are used in sim-
ple statistical queries that summarize information from the database tuples.
Common functions applied to collections of numeric values include SUM,
AVERAGE, MAXIMUM, and MINIMUM. The COUNT function is used for counting
tuples or values.

Another common type of request involves grouping the tuples in a relation by the
value of some of their attributes and then applying an aggregate function
independently to each group. An example would be to group EMPLOYEE tuples by
Dno, so that each group includes the tuples for employees working in the same
department. We can then list each Dno value along with, say, the average salary of
employees within the department, or the number of employees who work in the
department.

We can define an AGGREGATE FUNCTION operation, using the symbol 3 (pro-
nounced script F)’, to specify these types of requests as follows:

<grouping attributes> 8 <function list> (R)

where <grouping attributes> is a list of attributes of the relation specified in R, and
<function list> is a list of (<function> <attribute>) pairs. In each such pair,
<function> is one of the allowed functions—such as SUM, AVERAGE, MAXIMUM,
MINIMUM, COUNT—and <attribute> is an attribute of the relation specified by R. The

 

‘There is no single agreed-upon notation for specifying aggregate functions. In some cases a “script A’
is used.

=== Page 196 ===
6.4 Additional Relational Operations

resulting relation has the grouping attributes plus one attribute for each element in
the function list. For example, to retrieve each department number, the number of
employees in the department, and their average salary, while renaming the resulting
attributes as indicated below, we write:

Pr(Dno, No_of_employees, Average_sal)(Dno 3 COUNT Ssn, AVERAGE Salary (EMPLOYEE))

The result of this operation on the EMPLOYEE relation of Figure 3.6 is shown in
Figure 6.10(a).

In the above example, we specified a list of attribute names—between parentheses
in the RENAME operation—for the resulting relation R. If no renaming is applied,
then the attributes of the resulting relation that correspond to the function list will
each be the concatenation of the function name with the attribute name in the form
<function>_<attribute>.’ For example, Figure 6.10(b) shows the result of the fol-
lowing operation:

Dno S COUNT Ssn, AVERAGE Salary( EMPLOYEE)

If no grouping attributes are specified, the functions are applied to all the tuples in
the relation, so the resulting relation has a single tuple only. For example, Figure
6.10(c) shows the result of the following operation:

S CouNT Ssn, AVERAGE Salary(EMPLOYEE)

It is important to note that, in general, duplicates are not eliminated when an aggre-
gate function is applied; this way, the normal interpretation of functions such as

167

 

Figure 6.10
The aggregate function operation.

@ PR(Dno, No_of_employees, Average_sal) ‘Dno S couNT ssn, AVERAGE Salary(EMPLOYEE)).
b. bao 3 COUNT ssn, AVERAGE Salary(EMPLOYEE).
c. 3 CouNT ssn, AVERAGE Salary(=MPLOYEE).

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

R
(a) | Dno No_of_employees Average_sal (b) | Dno Count_ssn Average_salary
5 4 33250 5 4 33250
4 3 31000 3 31000
1 55000 1 1 55000
(c) | Count_ssn Average_salary
8 35125

 

 

 

 

 

8Note that this is an arbitrary notation we are suggesting. There is no standard notation.

=== Page 197 ===
168

Chapter 6 The Relational Algebra and Relational Calculus

SUM and AVERAGE is computed.? It is worth emphasizing that the result of apply-
ing an aggregate function is a relation, not a scalar number—even if it has a single
value. This makes the relational algebra a closed mathematical system.

6.4.3 Recursive Closure Operations

Another type of operation that, in general, cannot be specified in the basic original
relational algebra is recursive closure. This operation is applied to a recursive rela-
tionship between tuples of the same type, such as the relationship between an
employee and a supervisor. This relationship is described by the foreign key Super_ssn
of the EMPLOYEE relation in Figures 3.5 and 3.6, and it relates each employee tuple (in
the role of supervisee) to another employee tuple (in the role of supervisor). An
example of a recursive operation is to retrieve all supervisees of an employee e at all
levels—that is, all employees e’ directly supervised by e, all employees e’S directly
supervised by each employee e’, all employees e’”’ directly supervised by each
employee e”, and so on.

It is relatively straightforward in the relational algebra to specify all employees
supervised by e at a specific level by joining the table with itself one or more times.
However, it is difficult to specify all supervisees at all levels. For example, to specify
the Ssns of all employees e’ directly supervised—at level one—by the employee e
whose name is ‘James Borg’ (see Figure 3.6), we can apply the following operation:

BORG_SSN <— Tegon(OFname=James AND Lname=‘Borg(EMPLOYEE))
SUPERVISION(Ssn1, Ssn2) — Msgr, super. ssn( EMPLOYEE)
RESULT1(Ssn) < m,,;(SUPERVISION & ¢.5_5,,BORG_SSN)

To retrieve all employees supervised by Borg at level 2—that is, all employees e”’
supervised by some employee e’ who is directly supervised by Borg—we can apply
another JOIN to the result of the first query, as follows:

RESULT2(Ssn) < 1g,,;(SUPERVISION D4 ¢..5 g¢,RRESULT1 )

To get both sets of employees supervised at levels 1 and 2 by ‘James Borg’, we can
apply the UNION operation to the two results, as follows:

RESULT <— RESULT2 U RESULT1

The results of these queries are illustrated in Figure 6.11. Although it is possible to
retrieve employees at each level and then take their UNION, we cannot, in general,
specify a query such as “retrieve the supervisees of ‘James Borg’ at all levels” without
utilizing a looping mechanism unless we know the maximum number of levels.!°
An operation called the transitive closure of relations has been proposed to compute
the recursive relationship as far as the recursion proceeds.

 

9In SQL, the option of eliminating duplicates before applying the aggregate function is available by
including the keyword DISTINCT (see Section 4.4.4).

'0The SQLS standard includes syntax for recursive closure.

=== Page 198 ===
6.4 Additional Relational Operations

SUPERVISION
(Borg's Ssn is 888665555)
(Ssn) (Super_ssn)
Ssn1 Ssn2
123456789 | 333445555
333445555 | 888665555
999887777 | 987654321
987654321 | 888665555
666884444 | 333445555
453453453 | 333445555
987987987 | 987654321
888665555 | null

 

 

 

 

 

 

RESULT1 RESULT2 RESULT

123456789

999887777

333445555

 

987654321

(Supervised by Borg) 666884444
453453453
987987987

453453453
987987987
(Supervised by 333445555
Borg’s subordinates) 987654321

(RESULT1 U RESULT2)

  

169

A two-level recursive

 

6.4.4 OUTER JOIN Operations

Next, we discuss some additional extensions to the JOIN operation that are neces-
sary to specify certain types of queries. The JOIN operations described earlier match
tuples that satisfy the join condition. For example, for a NATURAL JOIN operation
R* S, only tuples from R that have matching tuples in S—and vice versa—appear in
the result. Hence, tuples without a matching (or related) tuple are eliminated from
the JOIN result. Tuples with NULL values in the join attributes are also eliminated.
This type of join, where tuples with no match are eliminated, is known as an inner
join. The join operations we described earlier in Section 6.3 are all inner joins. This
amounts to the loss of information if the user wants the result of the JOIN to include
all the tuples in one or more of the component relations.

A set of operations, called outer joins, were developed for the case where the user
wants to keep all the tuples in R, or all those in S, or all those in both relations in the
result of the JOIN, regardless of whether or not they have matching tuples in the
other relation. This satisfies the need of queries in which tuples from two tables are

=== Page 199 ===
170 Chapter 6 The Relational Algebra and Relational Calculus

to be combined by matching corresponding rows, but without losing any tuples for
lack of matching values. For example, suppose that we want a list of all employee
names as well as the name of the departments they manage if they happen to manage
a department; if they do not manage one, we can indicate it with a NULL value. We
can apply an operation LEFT OUTER JOIN, denoted by ), to retrieve the result as

follows:
TEMP < (EMPLOYEE DEPARTMENT)

RESULT <— TEname, Minit, Lname, Dname( EMP)

Ssn=Mgr_ssn

The LEFT OUTER JOIN operation keeps every tuple in the first, or left, relation Rin R
1 S; if no matching tuple is found in S, then the attributes of S in the join result are
filled or padded with NULL values. The result of these operations is shown in Figure
6.12.

A similar operation, RIGHT OUTER JOIN, denoted by ><, keeps every tuple in the
second, or right, relation S in the result of R >< S. A third operation, FULL OUTER
JOIN, denoted by 2X, keeps all tuples in both the left and the right relations when no
matching tuples are found, padding them with NULL values as needed. The three
outer join operations are part of the SQL2 standard (see Section 5.1.6). These oper-
ations were provided later as an extension of relational algebra in response to the
typical need in business applications to show related information from multiple
tables exhaustively. Sometimes a complete reporting of data from multiple tables is
required whether or not there are matching values.

6.4.5 The OUTER UNION Operation

The OUTER UNION operation was developed to take the union of tuples from two
relations that have some common attributes, but are not union (type) compatible.
This operation will take the UNION of tuples in two relations R(X, Y) and S(X, Z)
that are partially compatible, meaning that only some of their attributes, say X, are
union compatible. The attributes that are union compatible are represented only
once in the result, and those attributes that are not union compatible from either

 

Figure 6.12

The result of a LEFT
OUTER JOIN opera-
tion.

 

 

 

 

 

 

 

 

 

 

 

 

 

RESULT

Fname Minit Lname Dname
John B Smith NULL

Franklin T Wong Research
Alicia J Zelaya NULL

Jennifer S Wallace | Administration
Ramesh K Narayan | NULL

Joyce A English NULL

Ahmad Vv Jabbar NULL

James E Borg Headquarters

 

 

=== Page 200 ===
6.5 Examples of Queries in Relational Algebra

relation are also kept in the result relation T(X, Y, Z). It is therefore the same as a
FULL OUTER JOIN on the common attributes.

Two tuples t, in R and f, in S are said to match if t,[X]=t,[X]. These will be com-
bined (unioned) into a single tuple in t. Tuples in either relation that have no
matching tuple in the other relation are padded with NULL values. For example, an
OUTER UNION can be applied to two relations whose schemas are STUDENT(Name,
Ssn, Department, Advisor) and INSTRUCTOR(Name, Ssn, Department, Rank). Tuples
from the two relations are matched based on having the same combination of values
of the shared attributes—Name, Ssn, Department. The resulting relation,
STUDENT_OR_INSTRUCTOR, will have the following attributes:

STUDENT_OR_INSTRUCTOR(Name, Ssn, Department, Advisor, Rank)

All the tuples from both relations are included in the result, but tuples with the same
(Name, Ssn, Department) combination will appear only once in the result. Tuples
appearing only in STUDENT will have a NULL for the Rank attribute, whereas tuples
appearing only in INSTRUCTOR will have a NULL for the Advisor attribute. A tuple
that exists in both relations, which represent a student who is also an instructor, will
have values for all its attributes.'!

Notice that the same person may still appear twice in the result. For example, we
could have a graduate student in the Mathematics department who is an instructor
in the Computer Science department. Although the two tuples representing that
person in STUDENT and INSTRUCTOR will have the same (Name, Ssn) values, they
will not agree on the Department value, and so will not be matched. This is because
Department has two different meanings in STUDENT (the department where the per-
son studies) and INSTRUCTOR (the department where the person is employed as an
instructor). If we wanted to apply the OUTER UNION based on the same (Name, Ssn)
combination only, we should rename the Department attribute in each table to reflect
that they have different meanings and designate them as not being part of the
union-compatible attributes. For example, we could rename the attributes as
MajorDept in STUDENT and WorkDept in INSTRUCTOR.

6.5 Examples of Queries
in Relational Algebra

The following are additional examples to illustrate the use of the relational algebra
operations. All examples refer to the database in Figure 3.6. In general, the same
query can be stated in numerous ways using the various operations. We will state
each query in one way and leave it to the reader to come up with equivalent formu-
lations.

Query 1. Retrieve the name and address of all employees who work for the
‘Research’ department.

 

"Note that OUTER UNION is equivalent to a FULL OUTER JOIN if the join attributes are all the com-
mon attributes of the two relations.

171

=== Page 201 ===
172

Chapter 6 The Relational Algebra and Relational Calculus

RESEARCH_DEPT < Op pamo~‘Research( DEPARTMENT)
RESEARCH_EMPS <— (RESEARCH_DEPT ™ 5, hor-pno
RESULT < Trename, Lname, Address(RESEARCH_EMPS)

EMPLOYEE)

As a single in-line expression, this query becomes:
Tename, Lname, Address (Opname='Research' (DEPARTMENT bd Dnumber=Dno(EMPLOYEE))

This query could be specified in other ways; for example, the order of the JOIN and
SELECT operations could be reversed, or the JOIN could be replaced by a NATURAL
JOIN after renaming one of the join attributes to match the other join attribute
name.

Query 2. For every project located in ‘Stafford’, list the project number, the
controlling department number, and the department manager’s last name,
address, and birth date.

STAFFORD_PROJS < Opigcation=‘Statfora’( PROJECT)

CONTR_DEPTS < (STAFFORD_PROJS Mp, pmumberD EPARTMENT)
PROJ_DEPT_MGRS < (CONTR_DEPTS D4 iyo, gsnSsn= MPLOYEE)
RESULT <— TPnumber, Dnum, Lname, Address, Bdate( PROJ_DEPT_MGRS)

In this example, we first select the projects located in Stafford, then join them with
their controlling departments, and then join the result with the department man-
agers. Finally, we apply a project operation on the desired attributes.

Query 3. Find the names of employees who work on all the projects controlled
by department number 5.

DEPT5_PROJS < PPro) Tpaumber( Sonum=s(PROJECT)))
EMP_PROIJ — £(g6n, Pro) TEssn, Pno(WORKS_ON))
RESULT_EMP_SSNS — EMP_PROJ + DEPT5_PROJS
RESULT — Ti pame, Fname(RESULT_EMP_SSNS * EMPLOYEE)

In this query, we first create a table DEPT5_PROJS that contains the project numbers
of all projects controlled by department 5. Then we create a table EMP_PROJ that
holds (Ssn, Pno) tuples, and apply the division operation. Notice that we renamed
the attributes so that they will be correctly used in the division operation. Finally, we
join the result of the division, which holds only Ssn values, with the EMPLOYEE
table to retrieve the desired attributes from EMPLOYEE.

Query 4. Make a list of project numbers for projects that involve an employee
whose last name is ‘Smith’, either as a worker or as a manager of the department
that controls the project.

SMITHS(Essn) < tigg, (| pamo-smith’(EMPLOYEE))

SMITH_WORKER_PROJS < t15,,(WORKS_ON * SMITHS)

MGRS © Ti name, Dnumber(EMPLOYEE DX 5... gr ssn EPARTMENT)
SMITH_MANAGED_DEPTS(Dnum) — tp pumbor (SLname-‘smith(MGRS))
SMITH_MGR_PROJS(Pno) © tppumber(SMITH_MANAGED_DEPTS * PROJECT)
RESULT < (SMITH_WORKER_PROJS U SMITH_MGR_PROJS)

=== Page 202 ===
6.5 Examples of Queries in Relational Algebra 173

In this query, we retrieved the project numbers for projects that involve an
employee named Smith as a worker in SMITH_WORKER_PROJS. Then we retrieved
the project numbers for projects that involve an employee named Smith as manager
of the department that controls the project in SMITH_-MGR_PROJS. Finally, we
applied the UNION operation on SMITH_WORKER_PROJS and
SMITH_MGR_PROJS. As a single in-line expression, this query becomes:

Teno (WORKS_ON i Essn=Ssn (Een (S, pame=‘smith'(EMPLOYEE)) ) U TPno

( (Tp pumber (SL pame='smith’(™ name, Dnumber( EMPLOYE E) ) ) bX
DEPARTMENT)) > PROJECT)

Ssn=Mgr_ssn Dnumber=Dnum

Query 5. List the names of all employees with two or more dependents.

Strictly speaking, this query cannot be done in the basic (original) relational
algebra. We have to use the AGGREGATE FUNCTION operation with the COUNT
aggregate function. We assume that dependents of the same employee have
distinct Dependent_name values.

T1(Ssn, No_of_dependents)< ¢.., 3 Goynt Dependent_name( DEPENDENT)

T2<— ONo of dependents>2( 11)
RESULT < Ty ane Frame(!2 * EMPLOYEE)

Query 6. Retrieve the names of employees who have no dependents.

This is an example of the type of query that uses the MINUS (SET DIFFERENCE)
operation.

ALL_EMPS < mg, (EMPLOYEE)

EMPS_WITH_DEPS(Ssn) < ,,,,(DEPENDENT)
EMPS_WITHOUT_DEPS < (ALL_EMPS — EMPS_WITH_DEPS)
RESULT < m name, Fname(EMPS_WITHOUT_DEPS * EMPLOYEE)

We first retrieve a relation with all employee Ssns in ALL_LEMPS. Then we create a
table with the Ssns of employees who have at least one dependent in
EMPS_WITH_DEPS. Then we apply the SET DIFFERENCE operation to retrieve
employees Ssns with no dependents in EMPS_WITHOUT_DEPS, and finally join this
with EMPLOYEE to retrieve the desired attributes. As a single in-line expression, this
query becomes:

((tigg,(EMPLOYEE) — pig,,(teg,(DEPENDENT))) * EMPLOYEE)

T name, Fname

Query 7. List the names of managers who have at least one dependent.

MGRS(Ssn) < tig, ggn( DEPARTMENT)
EMPS_WITH_DEPS(Ssn) < ¢,,,(DEPENDENT)
MGRS_WITH_DEPS < (MGRS 7 EMPS_WITH_DEPS)
RESULT < m name, Fname(MGRS_WITH_DEPS * EMPLOYEE)

In this query, we retrieve the Ssns of managers in MGRS, and the Ssns of employees
with at least one dependent in EMPS_WITH_DEPS, then we apply the SET
INTERSECTION operation to get the Ssns of managers who have at least one
dependent.

=== Page 203 ===
174

Chapter 6 The Relational Algebra and Relational Calculus

As we mentioned earlier, the same query can be specified in many different ways in
relational algebra. In particular, the operations can often be applied in various
orders. In addition, some operations can be used to replace others; for example, the
INTERSECTION operation in Q7 can be replaced by a NATURAL JOIN. As an exercise,
try to do each of these sample queries using different operations.!* We showed how
to write queries as single relational algebra expressions for queries Q1, Q4, and Q6.
Try to write the remaining queries as single expressions. In Chapters 4 and 5 and in
Sections 6.6 and 6.7, we show how these queries are written in other relational
languages.

6.6 The Tuple Relational Calculus

In this and the next section, we introduce another formal query language for the
relational model called relational calculus. This section introduces the language
known as tuple relational calculus, and Section 6.7 introduces a variation called
domain relational calculus. In both variations of relational calculus, we write one
declarative expression to specify a retrieval request; hence, there is no description of
how, or in what order, to evaluate a query. A calculus expression specifies what is to
be retrieved rather than how to retrieve it. Therefore, the relational calculus is con-
sidered to be a nonprocedural language. This differs from relational algebra, where
we must write a sequence of operations to specify a retrieval request in a particular
order of applying the operations; thus, it can be considered as a procedural way of
stating a query. It is possible to nest algebra operations to form a single expression;
however, a certain order among the operations is always explicitly specified in a rela-
tional algebra expression. This order also influences the strategy for evaluating the
query. A calculus expression may be written in different ways, but the way it is writ-
ten has no bearing on how a query should be evaluated.

It has been shown that any retrieval that can be specified in the basic relational alge-
bra can also be specified in relational calculus, and vice versa; in other words, the
expressive power of the languages is identical. This led to the definition of the con-
cept of a relationally complete language. A relational query language L is considered
relationally complete if we can express in L any query that can be expressed in rela-
tional calculus. Relational completeness has become an important basis for compar-
ing the expressive power of high-level query languages. However, as we saw in
Section 6.4, certain frequently required queries in database applications cannot be
expressed in basic relational algebra or calculus. Most relational query languages are
relationally complete but have more expressive power than relational algebra or rela-
tional calculus because of additional operations such as aggregate functions, group-
ing, and ordering. As we mentioned in the introduction to this chapter, the
relational calculus is important for two reasons. First, it has a firm basis in mathe-
matical logic. Second, the standard query language (SQL) for RDBMSs has some of
its foundations in the tuple relational calculus.

 

'2When queries are optimized (see Chapter 19), the system will choose a particular sequence of opera-
tions that corresponds to an execution strategy that can be executed efficiently.

=== Page 204 ===
6.6 The Tuple Relational Calculus

Our examples refer to the database shown in Figures 3.6 and 3.7. We will use the
same queries that were used in Section 6.5. Sections 6.6.6, 6.6.7, and 6.6.8 discuss
dealing with universal quantifiers and safety of expression issues. (Students inter-
ested in a basic introduction to tuple relational calculus may skip these sections.)

6.6.1 Tuple Variables and Range Relations

The tuple relational calculus is based on specifying a number of tuple variables.
Each tuple variable usually ranges over a particular database relation, meaning that
the variable may take as its value any individual tuple from that relation. A simple
tuple relational calculus query is of the form:

{t | COND(t)}

where t is a tuple variable and COND(f) is a conditional (Boolean) expression
involving t that evaluates to either TRUE or FALSE for different assignments of
tuples to the variable t. The result of such a query is the set of all tuples ¢ that evalu-
ate COND(t) to TRUE. These tuples are said to satisfy COND(t). For example, to find
all employees whose salary is above $50,000, we can write the following tuple calcu-
lus expression:

{t | EMPLOYEE(t) AND t.Salary>50000}

The condition EMPLOYEE(t) specifies that the range relation of tuple variable t is
EMPLOYEE. Each EMPLOYEE tuple t that satisfies the condition t.Salary>50000 will
be retrieved. Notice that t.Salary references attribute Salary of tuple variable £; this
notation resembles how attribute names are qualified with relation names or aliases
in SQL, as we saw in Chapter 4. In the notation of Chapter 3, t.Salary is the same as
writing ¢[Salary].

The above query retrieves all attribute values for each selected EMPLOYEE tuple t. To
retrieve only some of the attributes—say, the first and last names—we write

{t.Fname, t.Lname | EMPLOYEE(t) AND t.Salary>50000}

Informally, we need to specify the following information in a tuple relational calcu-
lus expression:

= For each tuple variable t, the range relation R of t. This value is specified by
a condition of the form R(t). If we do not specify a range relation, then the
variable t will range over all possible tuples “in the universe” as it is not
restricted to any one relation.

= A condition to select particular combinations of tuples. As tuple variables
range over their respective range relations, the condition is evaluated for
every possible combination of tuples to identify the selected combinations
for which the condition evaluates to TRUE.

= A set of attributes to be retrieved, the requested attributes. The values of
these attributes are retrieved for each selected combination of tuples.

Before we discuss the formal syntax of tuple relational calculus, consider another
query.

175

=== Page 205 ===
176

Chapter 6 The Relational Algebra and Relational Calculus

Query 0. Retrieve the birth date and address of the employee (or employees)
whose name is John B. Smith.

QO: {t.Bdate, t.Address | EMPLOYEE(t) AND ¢.Fname=‘John’ AND t.Minit="B’
AND t.Lname=‘Smith’}

In tuple relational calculus, we first specify the requested attributes t.Bdate and
t.Address for each selected tuple t. Then we specify the condition for selecting a
tuple following the bar (|)—namely, that t be a tuple of the EMPLOYEE relation
whose Fname, Minit, and Lname attribute values are ‘John’ ‘B and ‘Smith’ respectively.

6.6.2 Expressions and Formulas
in Tuple Relational Calculus

A general expression of the tuple relational calculus is of the form
{ty Aj t-Apy oes byAyy | COND( ty, boy os bye tage

n+l? “n+2? °°"? thom}

where £1, ty) «+5 ts tg p> «++ Eng, are tuple variables, each A; is an attribute of the rela-
tion on which t, ranges, and COND is a condition or formula.!> of the tuple rela-
tional calculus. A formula is made up of predicate calculus atoms, which can be one

of the following:

1. An atom of the form R(t,), where R is a relation name and tf, is a tuple vari-
able. This atom identifies the range of the tuple variable ¢; as the relation
whose name is R. It evaluates to TRUE if tf; is a tuple in the relation R, and
evaluates to FALSE otherwise.

2. An atom of the form ¢.A op t,.B, where op is one of the comparison opera-
tors in the set {=,<, <>, 2, #}, t,and t, are tuple variables, A is an attribute of
the relation on which ¢, ranges, and Bis an attribute of the relation on which
t, ranges.

3. An atom of the form ¢;.A op c or c op t..B, where op is one of the compari-
son operators in the set {=, <, <, >, 2, zi, t, and t, are tuple variables, A is an
attribute of the relation on which f, ranges, B is an attribute of the relation
on which tf; ranges, and c is a constant value.

Each of the preceding atoms evaluates to either TRUE or FALSE for a specific combi-
nation of tuples; this is called the truth value of an atom. In general, a tuple variable
t ranges over all possible tuples in the universe. For atoms of the form R(t), if t is
assigned to a tuple that is a member of the specified relation R, the atom is TRUE; oth-
erwise, it is FALSE. In atoms of types 2 and 3, if the tuple variables are assigned to
tuples such that the values of the specified attributes of the tuples satisfy the condi-
tion, then the atom is TRUE.

A formula (Boolean condition) is made up of one or more atoms connected via the
logical operators AND, OR, and NOT and is defined recursively by Rules 1 and 2 as
follows:

= Rule 1: Every atom is a formula.

 

'8Also called a well-formed formula, or WFF, in mathematical logic.

=== Page 206 ===
6.6 The Tuple Relational Calculus 177

m Rule 2: If F, and F, are formulas, then so are (F, AND F,), (F, OR F,), NOT
(F,), and NOT (F,). The truth values of these formulas are derived from their
component formulas F, and F, as follows:

a. (F, AND F,) is TRUE if both F, and F, are TRUE; otherwise, it is FALSE.
. (F, OR F,) is FALSE if both F, and F, are FALSE; otherwise, it is TRUE.
NOT (F,) is TRUE if F, is FALSE; it is FALSE if F, is TRUE.

NOT (F,) is TRUE if F, is FALSE; it is FALSE if F, is TRUE.

295

6.6.3 The Existential and Universal Quantifiers

In addition, two special symbols called quantifiers can appear in formulas; these are
the universal quantifier (WV) and the existential quantifier (4). Truth values for
formulas with quantifiers are described in Rules 3 and 4 below; first, however, we
need to define the concepts of free and bound tuple variables in a formula.
Informally, a tuple variable t is bound if it is quantified, meaning that it appears in
an (At) or (V4) clause; otherwise, it is free. Formally, we define a tuple variable in a
formula as free or bound according to the following rules:

= An occurrence of a tuple variable in a formula F that is an atom is free in F.

m An occurrence of a tuple variable t is free or bound in a formula made up of
logical connectives—(F, AND F,), (F, OR F,), NOT(F,), and NOT(F,)—
depending on whether it is free or bound in F, or F, (if it occurs in either).
Notice that in a formula of the form F = (F, AND F,) or F= (F, OR F,), a
tuple variable may be free in F, and bound in F,, or vice versa; in this case,
one occurrence of the tuple variable is bound and the other is free in F.

m All free occurrences of a tuple variable t in F are bound in a formula F’ of the
form F’= (4t)(F) or F’ = (Wt)(F). The tuple variable is bound to the quanti-
fier specified in F’. For example, consider the following formulas:

F, : d.Dname=‘Research’
F, : (A t)(d.Dnumber=t.Dno)
F, : (Wd) (d.Mgr_ssn="333445555’)

The tuple variable d is free in both F, and F,, whereas it is bound to the (W) quan-
tifier in F,. Variable t is bound to the (4) quantifier in F,.

We can now give Rules 3 and 4 for the definition of a formula we started earlier:

= Rule 3: If F is a formula, then so is (4t)(F), where t is a tuple variable. The
formula (4t)(F) is TRUE if the formula F evaluates to TRUE for some (at least
one) tuple assigned to free occurrences of t in F; otherwise, (4t)(F) is FALSE.

= Rule 4: If F is a formula, then so is (Wt)(F), where tf is a tuple variable. The
formula (Wf)(F) is TRUE if the formula F evaluates to TRUE for every tuple
(in the universe) assigned to free occurrences of t in F; otherwise, (Wf)(F) is
FALSE.

The (4) quantifier is called an existential quantifier because a formula (St)(F) is
TRUE if there exists some tuple that makes F TRUE. For the universal quantifier,

=== Page 207 ===
178

Chapter 6 The Relational Algebra and Relational Calculus

(Wt)(F) is TRUE if every possible tuple that can be assigned to free occurrences of t
in Fis substituted for t, and F is TRUE for every such substitution. It is called the uni-
versal or for all quantifier because every tuple in the universe of tuples must make F
TRUE to make the quantified formula TRUE.

6.6.4 Sample Queries in Tuple Relational Calculus

We will use some of the same queries from Section 6.5 to give a flavor of how the
same queries are specified in relational algebra and in relational calculus. Notice
that some queries are easier to specify in the relational algebra than in the relational
calculus, and vice versa.

Query 1. List the name and address of all employees who work for the
‘Research’ department.

Q1: {t.Fname, t.Lname, t.Address | EMPLOYEE(t) AND (4d)(DEPARTMENT(d)
AND d.Dname=‘Research’ AND d.Dnumber=t.Dno)}

The only free tuple variables in a tuple relational calculus expression should be those
that appear to the left of the bar (|). In Q1, tis the only free variable; it is then bound
successively to each tuple. If a tuple satisfies the conditions specified after the bar in
Q1, the attributes Fname, Lname, and Address are retrieved for each such tuple. The
conditions EMPLOYEE(t) and DEPARTMENT(d) specify the range relations for t and
d. The condition d.Dname = ‘Research’ is a selection condition and corresponds to a
SELECT operation in the relational algebra, whereas the condition d.Dnumber =
t.Dno is a join condition and is similar in purpose to the (INNER) JOIN operation
(see Section 6.3).

Query 2. For every project located in ‘Stafford’, list the project number, the
controlling department number, and the department manager’s last name,
birth date, and address.

Q2: {p.Pnumber, p.Dnum, m.Lname, m.Bdate, m.Address | PROJECT(p) AND
EMPLOYEE(m) AND p.Plocation="Stafford’ AND ((4d)(DEPARTMENT(d)
AND p.Dnum=d.Dnumber AND d.Mgr_ssn=m.Ssn))}

In Q2 there are two free tuple variables, p and m. Tuple variable d is bound to the
existential quantifier. The query condition is evaluated for every combination of
tuples assigned to p and m, and out of all possible combinations of tuples to which
p and m are bound, only the combinations that satisfy the condition are selected.

Several tuple variables in a query can range over the same relation. For example, to
specify Q8—for each employee, retrieve the employee’s first and last name and the
first and last name of his or her immediate supervisor—we specify two tuple vari-
ables e and s that both range over the EMPLOYEE relation:

Qs: {e.Fname, e.Lname, s.Fname, s.Lname | EMPLOYEE(e) AND EMPLOYEE(s)
AND e.Super_ssn=s.Ssn}

Query 3’. List the name of each employee who works on some project con-
trolled by department number 5. This is a variation of Q3 in which all is

=== Page 208 ===
6.6 The Tuple Relational Calculus 179

changed to some. In this case we need two join conditions and two existential
quantifiers.

Q0’: {e.Lname, e.Fname | EMPLOYEE(e) AND ((4x)(4w)(PROJECT(x) AND
WORKS_ON(w) AND x.Dnum=5 AND w.Essn=e.Ssn AND
x.Pnumber=w.Pno) )}

Query 4. Make a list of project numbers for projects that involve an employee
whose last name is ‘Smith’ either as a worker or as manager of the controlling
department for the project.

Q4: { p.Phumber | PROJECT(p) AND (((de)(4w) (EMPLOYEE(e)
AND WORKS_ON(w) AND w.Pno=p.Pnumber
AND e.Lname=‘Smith’ AND e.Ssn=w.Essn) )
OR
((Am) (Ad) (EMPLOYEE(m) AND DEPARTMENT(d)
AND p.Dnum=d.Dnumber AND d.Mgr_ssn=m.Ssn
AND m.Lname=‘Smith’)))}

Compare this with the relational algebra version of this query in Section 6.5. The
UNION operation in relational algebra can usually be substituted with an OR con-
nective in relational calculus.

6.6.5 Notation for Query Graphs

In this section we describe a notation that has been proposed to represent relational
calculus queries that do not involve complex quantification in a graphical form.
These types of queries are known as select-project-join queries, because they only
involve these three relational algebra operations. The notation may be expanded to
more general queries, but we do not discuss these extensions here. This graphical
representation of a query is called a query graph. Figure 6.13 shows the query graph
for Q2. Relations in the query are represented by relation nodes, which are dis-
played as single circles. Constant values, typically from the query selection condi-
tions, are represented by constant nodes, which are displayed as double circles or
ovals. Selection and join conditions are represented by the graph edges (the lines
that connect the nodes), as shown in Figure 6.13. Finally, the attributes to be
retrieved from each relation are displayed in square brackets above each relation.

[P.Pnumber,P.Dnum] [E.Lname,E.address,E.Bdate]

   
  

 

P.Dnum=D.Dnumber D.Mgr_ssn=E.Ssn
(0_)}— )

P.Plocation='Stafford’

Figure 6.13
Query graph for Q2.

=== Page 209 ===
180

Chapter 6 The Relational Algebra and Relational Calculus

The query graph representation does not indicate a particular order to specify
which operations to perform first, and is hence a more neutral representation of a
select-project-join query than the query tree representation (see Section 6.3.5),
where the order of execution is implicitly specified. There is only a single query
graph corresponding to each query. Although some query optimization techniques
were based on query graphs, it is now generally accepted that query trees are prefer-
able because, in practice, the query optimizer needs to show the order of operations
for query execution, which is not possible in query graphs.

In the next section we discuss the relationship between the universal and existential
quantifiers and show how one can be transformed into the other.

6.6.6 Transforming the Universal and Existential Quantifiers

We now introduce some well-known transformations from mathematical logic that
relate the universal and existential quantifiers. It is possible to transform a universal
quantifier into an existential quantifier, and vice versa, to get an equivalent expres-
sion. One general transformation can be described informally as follows: Transform
one type of quantifier into the other with negation (preceded by NOT); AND and OR
replace one another; a negated formula becomes unnegated; and an unnegated for-
mula becomes negated. Some special cases of this transformation can be stated as
follows, where the = symbol stands for equivalent to:

(Wx) (P(x)) = NOT (Ax) (NOT (P(x)))
(Ax) (P(x)) = NOT (Wx) (NOT (P(x)))
(Wx) (P(x) AND Q(x)) = NOT (Ax) (NOT (P(x)) OR NOT (Q(x)))
(Wx) (P(x) OR Q(x)) = NOT (Ax) (NOT (P(x)) AND NOT (Q(x)))
(Ax) (P(x)) OR Q(x)) = NOT (Wx) (NOT (P(x)) AND NOT (Q(x)))
(Ax) (P(x) AND Q(x)) = NOT (Vx) (NOT (P(x)) OR NOT (Q(x)))

Notice also that the following is TRUE, where the = symbol stands for implies:

(Wx)(P(x)) => (Ax)(P(x))
NOT (4x) (P(x)) = NOT (Wx)(P(x))

6.6.7 Using the Universal Quantifier in Queries

Whenever we use a universal quantifier, it is quite judicious to follow a few rules to
ensure that our expression makes sense. We discuss these rules with respect to the
query Q3.

Query 3. List the names of employees who work on all the projects controlled
by department number 5. One way to specify this query is to use the universal
quantifier as shown:

Q3: {e.Lname, e.Fname | EMPLOYEE(e) AND ((Wx)(NOT(PROJECT(x)) OR NOT
(x.Dnum=5) OR ((Aw)(WORKS_ON(w) AND w.Essn=e.Ssn AND
x.Pnumber=w.Pno))))}

=== Page 210 ===
6.6 The Tuple Relational Calculus

We can break up Q3 into its basic components as follows:

Q3: {e.Lname, e.Fname | EMPLOYEE(e) AND F’}
F' = ((Vx)(NOT(PROJECT(x)) OR F,))
F, = NOT(x.Dnum=5) OR F,
F, = ((4w)(WORKS_ON(w) AND w.Essn=e.Ssn
AND x.Pnumber=w.Pno))

We want to make sure that a selected employee e works on all the projects controlled
by department 5, but the definition of universal quantifier says that to make the
quantified formula TRUE, the inner formula must be TRUE for all tuples in the uni-
verse. The trick is to exclude from the universal quantification all tuples that we are
not interested in by making the condition TRUE for all such tuples. This is necessary
because a universally quantified tuple variable, such as x in Q3, must evaluate to
TRUE for every possible tuple assigned to it to make the quantified formula TRUE.

The first tuples to exclude (by making them evaluate automatically to TRUE) are
those that are not in the relation R of interest. In Q3, using the expression
NOT(PROJECT(x)) inside the universally quantified formula evaluates to TRUE all
tuples x that are not in the PROJECT relation. Then we exclude the tuples we are not
interested in from R itself. In Q3, using the expression NOT(x.Dnum=5) evaluates to
TRUE all tuples x that are in the PROJECT relation but are not controlled by depart-
ment 5. Finally, we specify a condition F, that must hold on all the remaining tuples
in R. Hence, we can explain Q3 as follows:

1. For the formula F’ = (Wx)(F) to be TRUE, we must have the formula F be
TRUE for all tuples in the universe that can be assigned to x. However, in Q3 we
are only interested in F being TRUE for all tuples of the PROJECT relation
that are controlled by department 5. Hence, the formula F is of the form
(NOT(PROJECT(x)) OR F,). The ‘NOT (PROJECT(x)) OR ... condition is
TRUE for all tuples not in the PROJECT relation and has the effect of elimi-
nating these tuples from consideration in the truth value of F,. For every
tuple in the PROJECT relation, F, must be TRUE if F’ is to be TRUE.

. Using the same line of reasoning, we do not want to consider tuples in the
PROJECT relation that are not controlled by department number 5, since we
are only interested in PROJECT tuples whose Dnum=5. Therefore, we can
write:

IF (x.Dnum=5) THEN F,
which is equivalent to
(NOT (x.Dnum=5) OR F,)

. Formula F,, hence, is of the form NOT(x.Dnum=5) OR F,. In the context of
Q3, this means that, for a tuple x in the PROJECT relation, either its Dnum#5
or it must satisfy F,.

4. Finally, F, gives the condition that we want to hold for a selected EMPLOYEE

tuple: that the employee works on every PROJECT tuple that has not been
excluded yet Such employee tuples are selected by the query.

Nb

oa

181

=== Page 211 ===
182

Chapter 6 The Relational Algebra and Relational Calculus

In English, Q3 gives the following condition for selecting an EMPLOYEE tuple e: For
every tuple x in the PROJECT relation with x.Dnum=5, there must exist a tuple w in
WORKS_ON such that w.Essn=e.Ssn and w.Pno=x.Pnumber. This is equivalent to
saying that EMPLOYEE e works on every PROJECT x in DEPARTMENT number 5.
(Whew!)

Using the general transformation from universal to existential quantifiers given in
Section 6.6.6, we can rephrase the query in Q3 as shown in Q3A, which uses a
negated existential quantifier instead of the universal quantifier:

Q3A: {e.Lname, e.Fname | EMPLOYEE(e) AND (NOT (4x) (PROJECT(x) AND
(x.Dnum=5) AND (NOT (Aw)(WORKS_ON(w) AND w.Essn=e.Ssn
AND x.Pnumber=w.Pno))))}

We now give some additional examples of queries that use quantifiers.
Query 6. List the names of employees who have no dependents.

Qé6: {e.Fname, e.Lname | EMPLOYEE(e) AND (NOT (4d)(DEPENDENT(d)
AND e.Ssn=d.Essn) )}

Using the general transformation rule, we can rephrase Q6 as follows:

Q6A: —_{e.Fname, e.Lname | EMPLOYEE(e) AND ((Wd)(NOT(DEPENDENT(d))
OR NOT(e.Ssn=d.Essn)))}

Query 7. List the names of managers who have at least one dependent.

Q7?: {e.Fname, e.Lname | EMPLOYEE(e) AND ((4d)(4p)(DEPARTMENT(d)
AND DEPENDENT(p) AND e.Ssn=d.Mgr_ssn AND p.Essn=e.Ssn))}

This query is handled by interpreting managers who have at least one dependent as
managers for whom there exists some dependent.

6.6.8 Safe Expressions

Whenever we use universal quantifiers, existential quantifiers, or negation of predi-
cates in a calculus expression, we must make sure that the resulting expression
makes sense. A safe expression in relational calculus is one that is guaranteed to
yield a finite number of tuples as its result; otherwise, the expression is called unsafe.
For example, the expression

{t | NOT (EMPLOYEE(t))}

is unsafe because it yields all tuples in the universe that are not EMPLOYEE tuples,
which are infinitely numerous. If we follow the rules for Q3 discussed earlier, we will
get a safe expression when using universal quantifiers. We can define safe expres-
sions more precisely by introducing the concept of the domain of a tuple relational
calculus expression: This is the set of all values that either appear as constant values
in the expression or exist in any tuple in the relations referenced in the expression.
For example, the domain of {t | NOT(EMPLOYEE(t))} is the set of all attribute values
appearing in some tuple of the EMPLOYEE relation (for any attribute). The domain

=== Page 212 ===
6.7 The Domain Relational Calculus

of the expression Q3A would include all values appearing in EMPLOYEE, PROJECT,
and WORKS_ON (unioned with the value 5 appearing in the query itself).

An expression is said to be safe if all values in its result are from the domain of the
expression. Notice that the result of {t | NOT(EMPLOYEE(t))} is unsafe, since it will,
in general, include tuples (and hence values) from outside the EMPLOYEE relation;
such values are not in the domain of the expression. All of our other examples are
safe expressions.

6.7 The Domain Relational Calculus

There is another type of relational calculus called the domain relational calculus, or
simply, domain calculus. Historically, while SQL (see Chapters 4 and 5), which was
based on tuple relational calculus, was being developed by IBM Research at San
Jose, California, another language called QBE (Query-By-Example), which is
related to domain calculus, was being developed almost concurrently at the IBM T.J.
Watson Research Center in Yorktown Heights, New York. The formal specification
of the domain calculus was proposed after the development of the QBE language
and system.

Domain calculus differs from tuple calculus in the type of variables used in formu-
las: Rather than having variables range over tuples, the variables range over single
values from domains of attributes. To form a relation of degree n for a query result,
we must have n of these domain variables—one for each attribute. An expression of
the domain calculus is of the form

{X15 Xp 0+ X, | COND(X,, X55 -23 Xs Xp ys Xp uor o> Xpand t

where Xp Xp v9 Xp Xppp Xap oo Xp are domain variables that range over
domains (of attributes), and COND is a condition or formula of the domain rela-
tional calculus.

A formula is made up of atoms. The atoms of a formula are slightly different from
those for the tuple calculus and can be one of the following:

1. An atom of the form R(x,, x,, ...; x), where R is the name of a relation of
degree j and each x,, 1 <i $j, is a domain variable. This atom states that a list
of values of <x,, x5, ..., x.> must be a tuple in the relation whose name is R,
where x; is the value of the ith attribute value of the tuple. To make a domain
calculus expression more concise, we can drop the commas in a list of vari-
ables; thus, we can write:

{X}5 Xy5 000 X,, | R(x, x5 x3) AND ...}
instead of:
{X15 Xpy oe» X,, | R(x, Xy5 x3) AND ...}
2. An atom of the form x, op x, where op is one of the comparison operators in
the set {=, <, S, >, 2, #}, and x, and x, are domain variables.
3. An atom of the form x; op c or c op Xp where op is one of the comparison
operators in the set {=, <, S, >, 2, 4}, x, and x, are domain variables, and c is a
constant value.

183

=== Page 213 ===
184

Chapter 6 The Relational Algebra and Relational Calculus

As in tuple calculus, atoms evaluate to either TRUE or FALSE for a specific set of val-
ues, called the truth values of the atoms. In case 1, if the domain variables are
assigned values corresponding to a tuple of the specified relation R, then the atom is
TRUE. In cases 2 and 3, if the domain variables are assigned values that satisfy the
condition, then the atom is TRUE.

In a similar way to the tuple relational calculus, formulas are made up of atoms,
variables, and quantifiers, so we will not repeat the specifications for formulas here.
Some examples of queries specified in the domain calculus follow. We will use low-
ercase letters |, m,n, ..., x, y, z for domain variables.

Query 0. List the birth date and address of the employee whose name is ‘John
B. Smith.

Qo: {u, v | (Aq) (Ar) (As) (At) (Aw) (Ax) (Ay) (Az)
(EMPLOYEE (qrstuvwxyz) AND q=‘John’ AND r=‘B’ AND s=‘Smith’)}

We need ten variables for the EMPLOYEE relation, one to range over each of the
domains of attributes of EMPLOYEE in order. Of the ten variables q, 1, s, ..., z, only u
and v are free, because they appear to the left of the bar and hence should not be
bound to a quantifier. We first specify the requested attributes, Bdate and Address, by
the free domain variables u for BDATE and v for ADDRESS. Then we specify the con-
dition for selecting a tuple following the bar (|)—namely, that the sequence of val-
ues assigned to the variables qrstuvwxyz be a tuple of the EMPLOYEE relation and
that the values for q (Fname), r (Minit), and s (Lname) be equal to ‘John’, ‘B’
and ‘Smith’, respectively. For convenience, we will quantify only those variables
actually appearing in a condition (these would be gq, r, and s in QO) in the rest of our
examples.!4

An alternative shorthand notation, used in QBE, for writing this query is to assign
the constants ‘John’, ‘B; and ‘Smith’ directly as shown in QOA. Here, all variables not
appearing to the left of the bar are implicitly existentially quantified:!°

Q0A: = {u, v| EMPLOYEE(‘John;‘B;‘Smith)t,u,v,w,x,y,z) }

Query 1. Retrieve the name and address of all employees who work for the
‘Research’ department.

Q1: {q, s, v| (Az) (AD (Am) (EMPLOYEE(qrstuvwxyz) AND
DEPARTMENT(lmno) AND /=‘Research’ AND m=z)}

A condition relating two domain variables that range over attributes from two rela-
tions, such as m = z in Q1, is a join condition, whereas a condition that relates a
domain variable to a constant, such as | = ‘Research; is a selection condition.

 

'4Nlote that the notation of quantifying only the domain variables actually used in conditions and of
showing a predicate such as EMPLOYEE(qrstuvwxyz) without separating domain variables with commas
is an abbreviated notation used for convenience; it is not the correct formal notation.

'SAgain, this is not a formally accurate notation.

=== Page 214 ===
6.8 Summary

Query 2. For every project located in ‘Stafford’, list the project number, the
controlling department number, and the department manager’s last name,
birth date, and address.

Q2: {i, k, s, u, v | (Aj)(Am)(An)(At) (PROJECT (hijk) AND
EMPLOYEE (qrstuvwxyz) AND DEPARTMENT(/mno) AND k=m AND
n=t AND j=‘Stafford’)}

Query 6. List the names of employees who have no dependents.

Qé: {q, s | (At)(EMPLOYEE(qrstuvwxyz) AND
(NOT(4/)(DEPENDENT(Imnop) AND t=1)))}

Q6 can be restated using universal quantifiers instead of the existential quantifiers,
as shown in Q6A:

Q6A: = {q, s | (At)(EMPLOYEE(qrstuvwxyz) AND
((WD)(NOT(DEPENDENT(/mnop)) OR NOT(t=I))))}

Query 7. List the names of managers who have at least one dependent.

Q7: {s, q | (At)(Aj)(AD (EMPLOYEE (qrstuvwxyz) AND DEPARTMENT(hijk)
AND DEPENDENT(Imnop) AND t=j AND /=t)}

As we mentioned earlier, it can be shown that any query that can be expressed in the
basic relational algebra can also be expressed in the domain or tuple relational cal-
culus. Also, any safe expression in the domain or tuple relational calculus can be
expressed in the basic relational algebra.

The QBE language was based on the domain relational calculus, although this was
realized later, after the domain calculus was formalized. QBE was one of the first
graphical query languages with minimum syntax developed for database systems. It
was developed at IBM Research and is available as an IBM commercial product as
part of the Query Management Facility (QMF) interface option to DB2. The basic
ideas used in QBE have been applied in several other commercial products. Because
of its important place in the history of relational languages, we have included an
overview of QBE in Appendix C.

6.8 Summary

In this chapter we presented two formal languages for the relational model of data.
They are used to manipulate relations and produce new relations as answers to
queries. We discussed the relational algebra and its operations, which are used to
specify a sequence of operations to specify a query. Then we introduced two types of
relational calculi called tuple calculus and domain calculus.

In Sections 6.1 through 6.3, we introduced the basic relational algebra operations and
illustrated the types of queries for which each is used. First, we discussed the unary
relational operators SELECT and PROJECT, as well as the RENAME operation. Then,
we discussed binary set theoretic operations requiring that relations on which they

185

=== Page 215 ===
186

Chapter 6 The Relational Algebra and Relational Calculus

are applied be union (or type) compatible; these include UNION, INTERSECTION, and
SET DIFFERENCE. The CARTESIAN PRODUCT operation is a set operation that can
be used to combine tuples from two relations, producing all possible combinations. It
is rarely used in practice; however, we showed how CARTESIAN PRODUCT followed
by SELECT can be used to define matching tuples from two relations and leads to the
JOIN operation. Different JOIN operations called THETA JOIN, EQUUOIN, and
NATURAL JOIN were introduced. Query trees were introduced as a graphical represen-
tation of relational algebra queries, which can also be used as the basis for internal
data structures that the DBMS can use to represent a query.

We discussed some important types of queries that cannot be stated with the basic
relational algebra operations but are important for practical situations. We intro-
duced GENERALIZED PROJECTION to use functions of attributes in the projection
list and the AGGREGATE FUNCTION operation to deal with aggregate types of sta-
tistical requests that summarize the information in the tables. We discussed recur-
sive queries, for which there is no direct support in the algebra but which can be
handled in a step-by-step approach, as we demonstrated. Then we presented the
OUTER JOIN and OUTER UNION operations, which extend JOIN and UNION and
allow all information in source relations to be preserved in the result.

The last two sections described the basic concepts behind relational calculus, which
is based on the branch of mathematical logic called predicate calculus. There are
two types of relational calculi: (1) the tuple relational calculus, which uses tuple
variables that range over tuples (rows) of relations, and (2) the domain relational
calculus, which uses domain variables that range over domains (columns of rela-
tions). In relational calculus, a query is specified in a single declarative statement,
without specifying any order or method for retrieving the query result. Hence, rela-
tional calculus is often considered to be a higher-level declarative language than the
relational algebra, because a relational calculus expression states what we want to
retrieve regardless of how the query may be executed.

We discussed the syntax of relational calculus queries using both tuple and domain
variables. We introduced query graphs as an internal representation for queries in
relational calculus. We also discussed the existential quantifier (4) and the universal
quantifier (VW). We saw that relational calculus variables are bound by these quanti-
fiers. We described in detail how queries with universal quantification are written,
and we discussed the problem of specifying safe queries whose results are finite. We
also discussed rules for transforming universal into existential quantifiers, and vice
versa. It is the quantifiers that give expressive power to the relational calculus, mak-
ing it equivalent to the basic relational algebra. There is no analog to grouping and
aggregation functions in basic relational calculus, although some extensions have
been suggested.

Review Questions

6.1. List the operations of relational algebra and the purpose of each.

=== Page 216 ===
6.2.

6.3.

6.4.

6.5.

6.6.
6.7.

6.8.

6.9.
6.10.

6.11.

6.12.

6.13.
6.14.

What is union compatibility? Why do the UNION, INTERSECTION, and
DIFFERENCE operations require that the relations on which they are applied
be union compatible?

Discuss some types of queries for which renaming of attributes is necessary
in order to specify the query unambiguously.

Discuss the various types of inner join operations. Why is theta join
required?

What role does the concept of foreign key play when specifying the most
common types of meaningful join operations?

What is the FUNCTION operation? What is it used for?

How are the OUTER JOIN operations different from the INNER JOIN opera-
tions? How is the OUTER UNION operation different from UNION?

In what sense does relational calculus differ from relational algebra, and in
what sense are they similar?

How does tuple relational calculus differ from domain relational calculus?

Discuss the meanings of the existential quantifier (4) and the universal
quantifier (V).

Define the following terms with respect to the tuple calculus: tuple variable,
range relation, atom, formula, and expression.

Define the following terms with respect to the domain calculus: domain vari-
able, range relation, atom, formula, and expression.

What is meant by a safe expression in relational calculus?

When is a query language called relationally complete?

Exercises

6.15.

6.16.

Show the result of each of the sample queries in Section 6.5 as it would apply
to the database state in Figure 3.6.

Specify the following queries on the COMPANYrelational database schema

shown in Figure 5.5, using the relational operators discussed in this chapter.

Also show the result of each query as it would apply to the database state in

Figure 3.6.

a. Retrieve the names of all employees in department 5 who work more than
10 hours per week on the ProductX project.

b. List the names of all employees who have a dependent with the same first
name as themselves.

a

. Find the names of all employees who are directly supervised by ‘Franklin
Wong.

d. For each project, list the project name and the total hours per week (by all

employees) spent on that project.

Exercises

187

=== Page 217 ===
188

Chapter 6 The Relational Algebra and Relational Calculus

6.17.

+

. Retrieve the names of all employees who work on every project.
. Retrieve the names of all employees who do not work on any project.

. For each department, retrieve the department name and the average

salary of all employees working in that department.

. Retrieve the average salary of all female employees.
. Find the names and addresses of all employees who work on at least one

project located in Houston but whose department has no location in
Houston.

. List the last names of all department managers who have no dependents.

Consider the AIRLINE relational database schema shown in Figure 3.8, which
was described in Exercise 3.12. Specify the following queries in relational
algebra:

a.

For each flight, list the flight number, the departure airport for the first leg
of the flight, and the arrival airport for the last leg of the flight.

. List the flight numbers and weekdays of all flights or flight legs that

depart from Houston Intercontinental Airport (airport code ‘IAH’) and
arrive in Los Angeles International Airport (airport code ‘LAX’).

. List the flight number, departure airport code, scheduled departure time,

arrival airport code, scheduled arrival time, and weekdays of all flights or
flight legs that depart from some airport in the city of Houston and arrive
at some airport in the city of Los Angeles.

. List all fare information for flight number ‘CO197°.
. Retrieve the number of available seats for flight number ‘CO197’ on

“2009-10-09”.

. Consider the LIBRARY relational database schema shown in Figure 6.14,

which is used to keep track of books, borrowers, and book loans. Referential
integrity constraints are shown as directed arcs in Figure 6.14, as in the nota-
tion of Figure 3.7. Write down relational expressions for the following
queries:

a.

How many copies of the book titled The Lost Tribe are owned by the
library branch whose name is ‘Sharpstown’?

. How many copies of the book titled The Lost Tribe are owned by each

library branch?

. Retrieve the names of all borrowers who do not have any books checked

out.

. For each book that is loaned out from the Sharpstown branch and whose

Due_date is today, retrieve the book title, the borrower’s name, and the
borrower’s address.

. For each library branch, retrieve the branch name and the total number

of books loaned out from that branch.

=== Page 218 ===
Exercises 189

BOOK
Publisher_name

fA
BOOK_AUTHORS

PUBLISHER

AO

 

 
   

   
     
  
   
    

 
 

 

 

 

 

BOOK_COPIES
Book_id| Branch_id] No_of_copies

 

 

 

BOOK_LOANS
Book_id] Branch_id] Card_no | Date out | Due date

 

 

  
 
 
 
 
 
   
 

 

LIBRARY_BRANCH

Branch_id | Branch_name | Address

 

 

 

 

BORROWER

Card_no} Name | Address | Phone

Figure 6.14

A relational database
schema for a LIBRARY
database.

 

 

6.19.

f. Retrieve the names, addresses, and number of books checked out for all
borrowers who have more than five books checked out.

g. For each book authored (or coauthored) by Stephen King, retrieve the
title and the number of copies owned by the library branch whose name
is Central.

Specify the following queries in relational algebra on the database schema
given in Exercise 3.14:
a. List the Order# and Ship_date for all orders shipped from Warehouse# W2.

b. List the WAREHOUSE information from which the CUSTOMER named
Jose Lopez was supplied his orders. Produce a listing: Order#, Warehouse#.

=== Page 219 ===
190 Chapter 6 The Relational Algebra and Relational Calculus

6.20.

6.21.

6.22.

. Produce a listing Cname, No_of_orders, Avg_order_amt, where the middle

column is the total number of orders by the customer and the last column
is the average order amount for that customer.

. List the orders that were not shipped within 30 days of ordering.
. List the Order# for orders that were shipped from all warehouses that the

company has in New York.

Specify the following queries in relational algebra on the database schema
given in Exercise 3.15:

a.

b.

Cc.

Give the details (all attributes of trip relation) for trips that exceeded
$2,000 in expenses.

Print the Ssns of salespeople who took trips to Honolulu.

Print the total trip expenses incurred by the salesperson with SSN = ‘234-
56-7890.

Specify the following queries in relational algebra on the database schema
given in Exercise 3.16:

a.

List the number of courses taken by all students named John Smith in
Winter 2009 (i.e., Quarter-=W09).

. Produce a list of textbooks (include Course#, Book_isbn, Book_title) for

courses offered by the ‘CS’ department that have used more than two
books.

. List any department that has all its adopted books published by ‘Pearson

Publishing.

Consider the two tables Tl and T2 shown in Figure 6.15. Show the results of
the following operations:

4 09 A290 0

- Tl o4 T1.P=T2.A
. T1 4 T1.Q=T2.B T2
. TI

T2

4 TLP=T2.A T2

- Tl 9 m.9=17B 12
.TLUT2

- Tl 4 (T1.P = T2.A AND T1.R = T2.C) T2

 

Figure 6.15
A database state for the
relations 71 and T2,

 

 

 

 

 

 

 

 

 

 

 

 

TABLE T1 TABLE T2
P|/Q|R A| B/C
10 a 5 10 b 6
15 b 8 25 3
25 a 6 10 b 5

=== Page 220 ===
6.23.

6.24.

6.26.

6.27.

6.29.

Specify the following queries in relational algebra on the database schema in

Exercise 3.17:

a. For the salesperson named ‘Jane Doe’ list the following information for
all the cars she sold: Serial#, Manufacturer, Sale_price.

b. List the Serial# and Model of cars that have no options.

c. Consider the NATURAL JOIN operation between SALESPERSON and
SALE. What is the meaning of a left outer join for these tables (do not
change the order of relations)? Explain with an example.

d. Write a query in relational algebra involving selection and one set opera-
tion and say in words what the query does.

Specify queries a, b, c, e, f, i, and j of Exercise 6.16 in both tuple and domain
relational calculus.

. Specify queries a, b, c, and d of Exercise 6.17 in both tuple and domain rela-

tional calculus.

Specify queries c, d, and f of Exercise 6.18 in both tuple and domain rela-
tional calculus.

In a tuple relational calculus query with n tuple variables, what would be the
typical minimum number of join conditions? Why? What is the effect of
having a smaller number of join conditions?

. Rewrite the domain relational calculus queries that followed QO in Section

6.7 in the style of the abbreviated notation of QOA, where the objective is to
minimize the number of domain variables by writing constants in place of
variables wherever possible.

Consider this query: Retrieve the Ssns of employees who work on at least
those projects on which the employee with Ssn=123456789 works. This may
be stated as (FORALL x) (IF P THEN Q), where

= x isa tuple variable that ranges over the PROJECT relation.
=m P=EMPLOYEE with Ssn=123456789 works on PROJECT x.
™ Q=EMPLOYEE e works on PROJECT x.

Express the query in tuple relational calculus, using the rules
m (WV x)(P(x)) = NOT(Ax)(NOT(P(x))).

= (IF P THEN Q) = (NOT(P) OR Q).

. Show how you can specify the following relational algebra operations in

both tuple and domain relational calculus.
a. O4_ (RIA, B, C))

. Tea, ps (RIA, B, C))

_ R(A, B, C) * S(C, D, E)

. R(A, B, C) U S(A, B, C)

. R(A, B, C) A S(A, B, C)

oO

o Qa a

Exercises

191

=== Page 221 ===
192

Chapter 6 The Relational Algebra and Relational Calculus

6.31.

6.32.

6.33.

f. R(A, B, C) = S(A, B, C)
g. R(A, B, C) x S(D, E, F)
h. R(A, B) + S(A)
Suggest extensions to the relational calculus so that it may express the fol-
lowing types of operations that were discussed in Section 6.4: (a) aggregate

functions and grouping; (b) OUTER JOIN operations; (c) recursive closure
queries.

A nested query is a query within a query. More specifically, a nested query is

a parenthesized query whose result can be used as a value in a number of

places, such as instead of a relation. Specify the following queries on the

database specified in Figure 3.5 using the concept of nested queries and the

relational operators discussed in this chapter. Also show the result of each

query as it would apply to the database state in Figure 3.6.

a. List the names of all employees who work in the department that has the
employee with the highest salary among all employees.

b. List the names of all employees whose supervisor’s supervisor has
“888665555’ for Ssn.

c. List the names of employees who make at least $10,000 more than the
employee who is paid the least in the company.

State whether the following conclusions are true or false:
a. NOT (P(x) OR Q(x)) > (NOT (P(x)) AND (NOT (Q(x)))
b. NOT (Ax) (P(x)) WV x (NOT (P(x))

c. (Ax) (P(x)) > V x ((P(x))

Laboratory Exercises

6.34.

Specify and execute the following queries in relational algebra (RA) using
the RA interpreter on the COMPANY database schema in Figure 3.5.

a. List the names of all employees in department 5 who work more than 10
hours per week on the ProductX project.

b. List the names of all employees who have a dependent with the same first
name as themselves.

c. List the names of employees who are directly supervised by Franklin
Wong.

d. List the names of employees who work on every project.
e. List the names of employees who do not work on any project.

f. List the names and addresses of employees who work on at least one proj-
ect located in Houston but whose department has no location in
Houston.

g. List the names of department managers who have no dependents.

=== Page 222 ===
Laboratory Exercises

6.35. Consider the following MAILORDER relational schema describing the data

6.36.

for a mail order company.

PARTS(Pno, Pname, Qoh, Price, Olevel)
CUSTOMERS(Cno, Cname, Street, Zip, Phone)
EMPLOYEES(Eno, Ename, Zip, Hdate)
ZIP_CODES(Zip, City)

ORDERS(Ono, Cno, Eno, Received, Shipped)
ODETAILS(Ono, Pno, Qty)

 

 

 

Qoh stands for quantity on hand: the other attribute names are self-
explanatory. Specify and execute the following queries using the RA inter-
preter on the MAILORDER database schema.

a. Retrieve the names of parts that cost less than $20.00.

b. Retrieve the names and cities of employees who have taken orders for
parts costing more than $50.00.

c. Retrieve the pairs of customer number values of customers who live in
the same ZIP Code.

d. Retrieve the names of customers who have ordered parts from employees
living in Wichita.

e. Retrieve the names of customers who have ordered parts costing less than
$20.00.

. Retrieve the names of customers who have not placed an order.

a+

g. Retrieve the names of customers who have placed exactly two orders.

Consider the following GRADEBOOK relational schema describing the data
for a grade book of a particular instructor. (Note: The attributes A, B, C, and
D of COURSES store grade cutoffs.)

CATALOG (Cno, Ctitle)

STUDENTS(Sid, Fname, Lname, Minit)
COURSES(Term, Sec_no, Cno, A, B, C, D)
ENROLLS(Sid, Term, Sec_no)

 

 

Specify and execute the following queries using the RA interpreter on the
GRADEBOOK database schema.

a. Retrieve the names of students enrolled in the Automata class during the
fall 2009 term.

b. Retrieve the Sid values of students who have enrolled in CSc226 and
CSc227.

c. Retrieve the Sid values of students who have enrolled in CSc226 or
CSc227.

d. Retrieve the names of students who have not enrolled in any class.

e. Retrieve the names of students who have enrolled in all courses in the
CATALOG table.

193

=== Page 223 ===
194

Chapter 6 The Relational Algebra and Relational Calculus

6.37. Consider a database that consists of the following relations.

6.38.

SUPPLIER(Sno, Sname)
PART(Pno, Pname)
PROJECT(Jno, Jname)
SUPPLY(Sno, Pno, Jno)

 

 

The database records information about suppliers, parts, and projects and
includes a ternary relationship between suppliers, parts, and projects. This
relationship is a many-many-many relationship. Specify and execute the fol-
lowing queries using the RA interpreter.

a.

b.

Retrieve the part numbers that are supplied to exactly two projects.

Retrieve the names of suppliers who supply more than two parts to proj-
ect Jl’.

c. Retrieve the part numbers that are supplied by every supplier.

. Retrieve the project names that are supplied by supplier ‘SI’ only.
. Retrieve the names of suppliers who supply at least two different parts

each to at least two different projects.

Specify and execute the following queries for the database in Exercise 3.16
using the RA interpreter.

a.

oO

fe)

Retrieve the names of students who have enrolled in a course that uses a
textbook published by Addison-Wesley.

. Retrieve the names of courses in which the textbook has been changed at

least once.

. Retrieve the names of departments that adopt textbooks published by

Addison-Wesley only.

. Retrieve the names of departments that adopt textbooks written by

Navathe and published by Addison-Wesley.

. Retrieve the names of students who have never used a book (in a course)

written by Navathe and published by Addison-Wesley.

6.39. Repeat Laboratory Exercises 6.34 through 6.38 in domain relational calculus
(DRC) by using the DRC interpreter.

Selected Bibliography

Codd (1970) defined the basic relational algebra. Date (1983a) discusses outer joins.
Work on extending relational operations is discussed by Carlis (1986) and
Ozsoyoglu et al. (1985). Cammarata et al. (1989) extends the relational model
integrity constraints and joins.

Codd (1971) introduced the language Alpha, which is based on concepts of tuple
relational calculus. Alpha also includes the notion of aggregate functions, which
goes beyond relational calculus. The original formal definition of relational calculus

=== Page 224 ===
Selected Bibliography

was given by Codd (1972), which also provided an algorithm that transforms any
tuple relational calculus expression to relational algebra. The QUEL (Stonebraker et
al. 1976) is based on tuple relational calculus, with implicit existential quantifiers,
but no universal quantifiers, and was implemented in the INGRES system as a com-
mercially available language. Codd defined relational completeness of a query lan-
guage to mean at least as powerful as relational calculus. Ullman (1988) describes a
formal proof of the equivalence of relational algebra with the safe expressions of
tuple and domain relational calculus. Abiteboul et al. (1995) and Atzeni and
deAntonellis (1993) give a detailed treatment of formal relational languages.

Although ideas of domain relational calculus were initially proposed in the QBE
language (Zloof 1975), the concept was formally defined by Lacroix and Pirotte
(1977a). The experimental version of the Query-By-Example system is described in
Zloof (1975). The ILL (Lacroix and Pirotte 1977b) is based on domain relational
calculus. Whang et al. (1990) extends QBE with universal quantifiers. Visual query
languages, of which QBE is an example, are being proposed as a means of querying
databases; conferences such as the Visual Database Systems Working Conference
(e.g., Arisawa and Catarci (2000) or Zhou and Pu (2002)) have a number of propos-
als for such languages.

195

=== Page 225 ===
This page intentionally left blank

=== Page 226 ===
part 3

 
    
 

Concept
and Data

 

=== Page 227 ===
This page intentionally left blank

=== Page 228 ===
chapter vA

Data Modeling Using the
Entity-Relationship (ER) Model

onceptual modeling is a very important phase in
designing a successful database application.

Generally, the term database application refers to a particular database and the
associated programs that implement the database queries and updates. For exam-
ple, a BANK database application that keeps track of customer accounts would
include programs that implement database updates corresponding to customer
deposits and withdrawals. These programs provide user-friendly graphical user
interfaces (GUIs) utilizing forms and menus for the end users of the application—
the bank tellers, in this example. Hence, a major part of the database application will
require the design, implementation, and testing of these application programs.
Traditionally, the design and testing of application programs has been considered
to be part of software engineering rather than database design. In many software
design tools, the database design methodologies and software engineering method-
ologies are intertwined since these activities are strongly related.

In this chapter, we follow the traditional approach of concentrating on the database
structures and constraints during conceptual database design. The design of appli-
cation programs is typically covered in software engineering courses. We present the
modeling concepts of the Entity-Relationship (ER) model, which is a popular
high-level conceptual data model. This model and its variations are frequently used
for the conceptual design of database applications, and many database design tools
employ its concepts. We describe the basic data-structuring concepts and con-
straints of the ER model and discuss their use in the design of conceptual schemas
for database applications. We also present the diagrammatic notation associated
with the ER model, known as ER diagrams.

199

=== Page 229 ===
200

Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

Object modeling methodologies such as the Unified Modeling Language (UML)
are becoming increasingly popular in both database and software design. These
methodologies go beyond database design to specify detailed design of software
modules and their interactions using various types of diagrams. An important part
of these methodologies—namely, class diagrams'!—are similar in many ways to the
ER diagrams. In class diagrams, operations on objects are specified, in addition to
specifying the database schema structure. Operations can be used to specify the
functional requirements during database design, as we will discuss in Section 7.1. We
present some of the UML notation and concepts for class diagrams that are partic-
ularly relevant to database design in Section 7.8, and briefly compare these to ER
notation and concepts. Additional UML notation and concepts are presented in
Section 8.6 and in Chapter 10.

This chapter is organized as follows: Section 7.1 discusses the role of high-level con-
ceptual data models in database design. We introduce the requirements for a sample
database application in Section 7.2 to illustrate the use of concepts from the ER
model. This sample database is also used throughout the book. In Section 7.3 we
present the concepts of entities and attributes, and we gradually introduce the dia-
grammatic technique for displaying an ER schema. In Section 7.4 we introduce the
concepts of binary relationships and their roles and structural constraints. Section
7.5 introduces weak entity types. Section 7.6 shows how a schema design is refined
to include relationships. Section 7.7 reviews the notation for ER diagrams, summa-
rizes the issues and common pitfalls that occur in schema design, and discusses how
to choose the names for database schema constructs. Section 7.8 introduces some
UML class diagram concepts, compares them to ER model concepts, and applies
them to the same database example. Section 7.9 discusses more complex types of
relationships. Section 7.10 summarizes the chapter.

The material in Sections 7.8 and 7.9 may be excluded from an introductory course. If
a more thorough coverage of data modeling concepts and conceptual database design
is desired, the reader should continue to Chapter 8, where we describe extensions to
the ER model that lead to the Enhanced-ER (EER) model, which includes concepts
such as specialization, generalization, inheritance, and union types (categories). We
also introduce some additional UML concepts and notation in Chapter 8.

7.1 Using High-Level Conceptual Data Models
for Database Design

Figure 7.1 shows a simplified overview of the database design process. The first step
shown is requirements collection and analysis. During this step, the database
designers interview prospective database users to understand and document their
data requirements. The result of this step is a concisely written set of users’ require-
ments. These requirements should be specified in as detailed and complete a form
as possible. In parallel with specifying the data requirements, it is useful to specify

 

'A class is similar to an entity type in many ways.

=== Page 230 ===
7.1. Using High-Level Conceptual Data Models for Database Design 201

 

REQUIREMENTS

COLLECTION AND
eo ANALYSIS

 

 

 

 

 

 

 

 

 

 

 

 

Functional Requirements Data Requirements
FU ont ANALYSIS nome DESIGN
High-Level Transaction Conceptual Schema
Specification (In a high-level data model)
DBMS-independent a

 
    
  

DBMS-specific

 

 

(DATA MODEL MAPPING)

 

 

Logical (Conceptual) Schema

APPLICATION PROGRAM (In the data model of a specific DBMS)

 

 

 

 

 

 

 

 

DESIGN 1
PHYSICAL DESIGN
TRANSACTION = |g Internal Schema
IMPLEMENTATION

 

 

 

Figure 7.1
A simplified diagram to illustrate the

Application Programs main phases of database design.

 

the known functional requirements of the application. These consist of the user-
defined operations (or transactions) that will be applied to the database, including
both retrievals and updates. In software design, it is common to use data flow dia-
grams, sequence diagrams, scenarios, and other techniques to specify functional
requirements. We will not discuss any of these techniques here; they are usually
described in detail in software engineering texts. We give an overview of some of
these techniques in Chapter 10.

Once the requirements have been collected and analyzed, the next step is to create a
conceptual schema for the database, using a high-level conceptual data model. This
step is called conceptual design. The conceptual schema is a concise description of

=== Page 231 ===
202

Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

the data requirements of the users and includes detailed descriptions of the entity
types, relationships, and constraints; these are expressed using the concepts pro-
vided by the high-level data model. Because these concepts do not include imple-
mentation details, they are usually easier to understand and can be used to
communicate with nontechnical users. The high-level conceptual schema can also
be used as a reference to ensure that all users’ data requirements are met and that the
requirements do not conflict. This approach enables database designers to concen-
trate on specifying the properties of the data, without being concerned with storage
and implementation details. This makes it is easier to create a good conceptual data-
base design.

During or after the conceptual schema design, the basic data model operations can
be used to specify the high-level user queries and operations identified during func-
tional analysis. This also serves to confirm that the conceptual schema meets all the
identified functional requirements. Modifications to the conceptual schema can be
introduced if some functional requirements cannot be specified using the initial
schema.

The next step in database design is the actual implementation of the database, using
a commercial DBMS. Most current commercial DBMSs use an implementation
data model—such as the relational or the object-relational database model—so the
conceptual schema is transformed from the high-level data model into the imple-
mentation data model. This step is called logical design or data model mapping; its
result is a database schema in the implementation data model of the DBMS. Data
model mapping is often automated or semiautomated within the database design
tools.

The last step is the physical design phase, during which the internal storage struc-
tures, file organizations, indexes, access paths, and physical design parameters for
the database files are specified. In parallel with these activities, application programs
are designed and implemented as database transactions corresponding to the high-
level transaction specifications. We discuss the database design process in more
detail in Chapter 10.

We present only the basic ER model concepts for conceptual schema design in this
chapter. Additional modeling concepts are discussed in Chapter 8, when we intro-
duce the EER model.

7.2 A Sample Database Application

In this section we describe a sample database application, called COMPANY, which
serves to illustrate the basic ER model concepts and their use in schema design. We
list the data requirements for the database here, and then create its conceptual
schema step-by-step as we introduce the modeling concepts of the ER model. The
COMPANY database keeps track of a company’s employees, departments, and proj-
ects. Suppose that after the requirements collection and analysis phase, the database
designers provide the following description of the miniworld—the part of the com-
pany that will be represented in the database.

=== Page 232 ===
7.3 Entity Types, Entity Sets, Attributes, and Keys

= The company is organized into departments. Each department has a unique
name, a unique number, and a particular employee who manages the
department. We keep track of the start date when that employee began man-
aging the department. A department may have several locations.

= A department controls a number of projects, each of which has a unique
name, a unique number, and a single location.

m We store each employee’s name, Social Security number,” address, salary, sex
(gender), and birth date. An employee is assigned to one department, but
may work on several projects, which are not necessarily controlled by the
same department. We keep track of the current number of hours per week
that an employee works on each project. We also keep track of the direct
supervisor of each employee (who is another employee).

m We want to keep track of the dependents of each employee for insurance
purposes. We keep each dependent’s first name, sex, birth date, and relation-
ship to the employee.

Figure 7.2 shows how the schema for this database application can be displayed by
means of the graphical notation known as ER diagrams. This figure will be
explained gradually as the ER model concepts are presented. We describe the step-
by-step process of deriving this schema from the stated requirements—and explain
the ER diagrammatic notation—as we introduce the ER model concepts.

7.3 Entity Types, Entity Sets, Attributes,
and Keys

The ER model describes data as entities, relationships, and attributes. In Section 7.3.1
we introduce the concepts of entities and their attributes. We discuss entity types
and key attributes in Section 7.3.2. Then, in Section 7.3.3, we specify the initial con-
ceptual design of the entity types for the COMPANY database. Relationships are
described in Section 7.4.

7.3.1 Entities and Attributes

Entities and Their Attributes. The basic object that the ER model represents is
an entity, which is a thing in the real world with an independent existence. An entity
may be an object with a physical existence (for example, a particular person, car,
house, or employee) or it may be an object with a conceptual existence (for instance,
a company, a job, or a university course). Each entity has attributes—the particular
properties that describe it. For example, an EMPLOYEE entity may be described by
the employee’s name, age, address, salary, and job. A particular entity will have a

 

The Social Security number, or SSN, is a unique nine-digit identifier assigned to each individual in the
United States to keep track of his or her employment, benefits, and taxes. Other countries may have
similar identification schemes, such as personal identification card numbers.

203

=== Page 233 ===
204 Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

 

C8) y

WORKS_FOR

 

 

 

 

 

 

 

 

 

 

 

  
   
 
 
    

 

 

 

 

 

 

 

 

 

EMPLOYEE Start_date ~ Number_of_employees>— DEPARTMENT
1
MANAGES CONTROLS
Hours IN
M N
. . WORKS_ON PROJECT
Supervisor Supervisee 1
1 SUPERVISION > N
DEPENDENTS_OF Number >
N
DEPENDENT
CName > Sex Relationship
Figure 7.2

An ER schema diagram for the COMPANY database. The diagrammatic notation
is introduced gradually throughout this chapter and is summarized in Figure 7.14.

value for each of its attributes. The attribute values that describe each entity become
a major part of the data stored in the database.

Figure 7.3 shows two entities and the values of their attributes. The EMPLOYEE
entity e, has four attributes: Name, Address, Age, and Home_phone; their values are
‘John Smith, ‘2311 Kirby, Houston, Texas 770017, ‘55’, and ‘713-749-2630, respec-
tively. The COMPANY entity c, has three attributes: Name, Headquarters, and
President; their values are “Sunco Oil; “Houston; and ‘John Smith; respectively.

Several types of attributes occur in the ER model: simple versus composite, single-
valued versus multivalued, and stored versus derived. First we define these attribute

=== Page 234 ===
7.3 Entity Types, Entity Sets, Attributes, and Keys 205

Name = John Smith Name = Sunco Oil

Address = 2311 Kirby
Houston, Texas 77001
ey Cy Headquarters = Houston

Age = 55

Home_phone = 713-749-2630 President = John Smith

types and illustrate their use via examples. Then we discuss the concept of a NULL
value for an attribute.

Composite versus Simple (Atomic) Attributes. Composite attributes can be
divided into smaller subparts, which represent more basic attributes with indepen-
dent meanings. For example, the Address attribute of the EMPLOYEE entity shown
in Figure 7.3 can be subdivided into Street_address, City, State, and Zip,’ with the
values 2311 Kirby’, “Houston, “Texas, and “77001” Attributes that are not divisible
are called simple or atomic attributes. Composite attributes can form a hierarchy;
for example, Street_address can be further subdivided into three simple component
attributes: Number, Street, and Apartment_number, as shown in Figure 7.4. The value
of a composite attribute is the concatenation of the values of its component simple
attributes.

Composite attributes are useful to model situations in which a user sometimes
refers to the composite attribute as a unit but at other times refers specifically to its
components. If the composite attribute is referenced only as a whole, there is no

Figure 7.3

Two entities,
EMPLOYEE e,, and
COMPANY c,, and
their attributes.

 

Address Figure 7.4
A hierarchy of composite
attributes.
Street_address City State Zip
Number Street Apartment_number

 

3Zip Code is the name used in the United States for a five-digit postal code, such as 76019, which can
be extended to nine digits, such as 76019-0015. We use the five-digit Zip in our examples.

=== Page 235 ===
206

Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

need to subdivide it into component attributes. For example, if there is no need to
refer to the individual components of an address (Zip Code, street, and so on), then
the whole address can be designated as a simple attribute.

Single-Valued versus Multivalued Attributes. Most attributes have a single
value for a particular entity; such attributes are called single-valued. For example,
Age is a single-valued attribute of a person. In some cases an attribute can have a set
of values for the same entity—for instance, a Colors attribute for a car, or a
College_degrees attribute for a person. Cars with one color have a single value,
whereas two-tone cars have two color values. Similarly, one person may not have a
college degree, another person may have one, and a third person may have two or
more degrees; therefore, different people can have different numbers of values for
the College_degrees attribute. Such attributes are called multivalued. A multivalued
attribute may have lower and upper bounds to constrain the number of values
allowed for each individual entity. For example, the Colors attribute of a car may be
restricted to have between one and three values, if we assume that a car can have
three colors at most.

Stored versus Derived Attributes. In some cases, two (or more) attribute val-
ues are related—for example, the Age and Birth_date attributes of a person. For a
particular person entity, the value of Age can be determined from the current
(today’s) date and the value of that person’s Birth_date. The Age attribute is hence
called a derived attribute and is said to be derivable from the Birth_date attribute,
which is called a stored attribute. Some attribute values can be derived from
related entities; for example, an attribute Number_of_employees of a DEPARTMENT
entity can be derived by counting the number of employees related to (working
for) that department.

NULL Values. In some cases, a particular entity may not have an applicable value
for an attribute. For example, the Apartment_number attribute of an address applies
only to addresses that are in apartment buildings and not to other types of resi-
dences, such as single-family homes. Similarly, a College_degrees attribute applies
only to people with college degrees. For such situations, a special value called NULL
is created. An address of a single-family home would have NULL for its
Apartment_number attribute, and a person with no college degree would have NULL
for College_degrees. NULL can also be used if we do not know the value of an attrib-
ute for a particular entity—for example, if we do not know the home phone num-
ber of ‘John Smith’ in Figure 7.3. The meaning of the former type of NULL is not
applicable, whereas the meaning of the latter is unknown. The unknown category of
NULL can be further classified into two cases. The first case arises when it is known
that the attribute value exists but is missing—for instance, if the Height attribute of a
person is listed as NULL. The second case arises when it is not known whether the
attribute value exists—for example, if the Home_phone attribute of a person is NULL.

Complex Attributes. Notice that, in general, composite and multivalued attrib-
utes can be nested arbitrarily. We can represent arbitrary nesting by grouping com-

=== Page 236 ===
7.3 Entity Types, Entity Sets, Attributes, and Keys

ponents of a composite attribute between parentheses () and separating the compo-
nents with commas, and by displaying multivalued attributes between braces { }.
Such attributes are called complex attributes. For example, if a person can have
more than one residence and each residence can have a single address and multiple
phones, an attribute Address_phone for a person can be specified as shown in Figure
7.5.4 Both Phone and Address are themselves composite attributes.

7.3.2 Entity Types, Entity Sets, Keys, and Value Sets

Entity Types and Entity Sets. A database usually contains groups of entities that
are similar. For example, a company employing hundreds of employees may want to
store similar information concerning each of the employees. These employee entities
share the same attributes, but each entity has its own value(s) for each attribute. An
entity type defines a collection (or set) of entities that have the same attributes. Each
entity type in the database is described by its name and attributes. Figure 7.6 shows
two entity types: EMPLOYEE and COMPANY, and a list of some of the attributes for

207

 

{Address_phone( {Phone(Area_code,Phone_number)},Address(Street_address
(Number,Street,Apartment_number),City,State,Zip) )}

EMPLOYEE COMPANY

Figure 7.5
A complex attribute:
Address_phone.

Entity Type Name:

Name, Age, Salary Name, Headquarters, President

(— >)

 

(— >»

C1 e Cie

(John Smith, 55, 80k) (Sunco Oil, Houston, John Smith)

foe

(Fred Brown, 40, 30K)

Co e
Entity Set:

(Extension) (Fast Computer, Dallas, Bob King)

€3 @

(Judy Clark, 25, 20K)

 

 

 

 

NN

 

“For those familiar with XML, we should note that complex attributes are similar to complex elements in
XML (see Chapter 12).

Figure 7.6

Two entity types,
EMPLOYEE and
COMPANY, and some
member entities of
each.

=== Page 237 ===
208 Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

each. A few individual entities of each type are also illustrated, along with the values
of their attributes. The collection of all entities of a particular entity type in the data-
base at any point in time is called an entity set; the entity set is usually referred to
using the same name as the entity type. For example, EMPLOYEE refers to both a type
of entity as well as the current set of all employee entities in the database.

An entity type is represented in ER diagrams? (see Figure 7.2) as a rectangular box
enclosing the entity type name. Attribute names are enclosed in ovals and are
attached to their entity type by straight lines. Composite attributes are attached to
their component attributes by straight lines. Multivalued attributes are displayed in
double ovals. Figure 7.7(a) shows a CAR entity type in this notation.

An entity type describes the schema or intension for a set of entities that share the
same structure. The collection of entities of a particular entity type is grouped into
an entity set, which is also called the extension of the entity type.

Key Attributes of an Entity Type. An important constraint on the entities of an
entity type is the key or uniqueness constraint on attributes. An entity type usually

 

Figure 7.7 (a)
The CAR entity type

with two key attributes,
Registration and

Vehicle_id. (a) ER

diagram notation. (b)

Entity set with three

entities.

 

(b) CAR
Registration (Number, State), Vehicle_id, Make, Model, Year, {Color}

 

CAR;
((ABC 123, TEXAS), TK629, Ford Mustang, convertible, 2004 {red, black})

CAR»
((ABC 123, NEW YORK), WP9872, Nissan Maxima, 4-door, 2005, {blue})

CAR3
((VSY 720, TEXAS), TD729, Chrysler LeBaron, 4-door, 2002, {white, blue})

 

 

5We use a notation for ER diagrams that is close to the original proposed notation (Chen 1976). Many
other notations are in use; we illustrate some of them later in this chapter when we present UML class
diagrams and in Appendix A.

=== Page 238 ===
7.3 Entity Types, Entity Sets, Attributes, and Keys

has one or more attributes whose values are distinct for each individual entity in the
entity set. Such an attribute is called a key attribute, and its values can be used to
identify each entity uniquely. For example, the Name attribute is a key of the
COMPANY entity type in Figure 7.6 because no two companies are allowed to have
the same name. For the PERSON entity type, a typical key attribute is Ssn (Social
Security number). Sometimes several attributes together form a key, meaning that
the combination of the attribute values must be distinct for each entity. If a set of
attributes possesses this property, the proper way to represent this in the ER model
that we describe here is to define a composite attribute and designate it as a key
attribute of the entity type. Notice that such a composite key must be minimal; that
is, all component attributes must be included in the composite attribute to have the
uniqueness property. Superfluous attributes must not be included in a key. In ER
diagrammatic notation, each key attribute has its name underlined inside the oval,
as illustrated in Figure 7.7(a).

Specifying that an attribute is a key of an entity type means that the preceding
uniqueness property must hold for every entity set of the entity type. Hence, it is a
constraint that prohibits any two entities from having the same value for the key
attribute at the same time. It is not the property of a particular entity set; rather, it is
a constraint on any entity set of the entity type at any point in time. This key con-
straint (and other constraints we discuss later) is derived from the constraints of the
miniworld that the database represents.

Some entity types have more than one key attribute. For example, each of the
Vehicle_id and Registration attributes of the entity type CAR (Figure 7.7) is a key in its
own right. The Registration attribute is an example of a composite key formed from
two simple component attributes, State and Number, neither of which is a key on its
own. An entity type may also have no key, in which case it is called a weak entity type
(see Section 7.5).

In our diagrammatic notation, if two attributes are underlined separately, then each
is a key on its own. Unlike the relational model (see Section 3.2.2), there is no con-
cept of primary key in the ER model that we present here; the primary key will be
chosen during mapping to a relational schema (see Chapter 9).

Value Sets (Domains) of Attributes. Each simple attribute of an entity type is
associated with a value set (or domain of values), which specifies the set of values
that may be assigned to that attribute for each individual entity. In Figure 7.6, if the
range of ages allowed for employees is between 16 and 70, we can specify the value
set of the Age attribute of EMPLOYEE to be the set of integer numbers between 16
and 70. Similarly, we can specify the value set for the Name attribute to be the set of
strings of alphabetic characters separated by blank characters, and so on. Value sets
are not displayed in ER diagrams, and are typically specified using the basic data
types available in most programming languages, such as integer, string, Boolean,
float, enumerated type, subrange, and so on. Additional data types to represent
common database types such as date, time, and other concepts are also employed.

209

=== Page 239 ===
210

Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

Mathematically, an attribute A of entity set E whose value set is V can be defined as
a function from E to the power set® P(V) of V:

A:E—>P(V)

We refer to the value of attribute A for entity e as A(e). The previous definition cov-
ers both single-valued and multivalued attributes, as well as NULLs. A NULL value is
represented by the empty set. For single-valued attributes, A(e) is restricted to being
a singleton set for each entity e in E, whereas there is no restriction on multivalued
attributes.’ For a composite attribute A, the value set V is the power set of the
Cartesian product of P(V,), P(V;), .... P(V,,), where V,, V,,..., V,, are the value sets
of the simple component attributes that form A:

V = P(P(V,) x P(V,) x... x P(V,,))

The value set provides all possible values. Usually only a small number of these val-
ues exist in the database at a particular time. Those values represent the data from
the current state of the miniworld. They correspond to the data as it actually exists
in the miniworld.

7.3.3 Initial Conceptual Design of the COMPANY Database

We can now define the entity types for the COMPANY database, based on the
requirements described in Section 7.2. After defining several entity types and their
attributes here, we refine our design in Section 7.4 after we introduce the concept of
a relationship. According to the requirements listed in Section 7.2, we can identify
four entity types—one corresponding to each of the four items in the specification
(see Figure 7.8):

1. An entity type DEPARTMENT with attributes Name, Number, Locations,
Manager, and Manager_start_date. Locations is the only multivalued attribute.
We can specify that both Name and Number are (separate) key attributes
because each was specified to be unique.

2. An entity type PROJECT with attributes Name, Number, Location, and
Controlling_department. Both Name and Number are (separate) key attributes.

3. An entity type EMPLOYEE with attributes Name, Ssn, Sex, Address, Salary,
Birth_date, Department, and Supervisor. Both Name and Address may be com-
posite attributes; however, this was not specified in the requirements. We
must go back to the users to see if any of them will refer to the individual
components of Name—First_name, Middle_initial, Last_name—or of Address.

4. An entity type DEPENDENT with attributes Employee, Dependent_name, Sex,
Birth_date, and Relationship (to the employee).

 

SThe power set P(V) of a set Vis the set of all subsets of V.

7A singleton set is a set with only one element (value).

=== Page 240 ===
7.3 Entity Types, Entity Sets, Attributes, and Keys 211

 

Figure 7.8

Preliminary design of entity types
for the COMPANY database.
Some of the shown attributes will
be refined into relationships.

 
    

Relationship

 

DEPENDENT

 

So far, we have not represented the fact that an employee can work on several proj-
ects, nor have we represented the number of hours per week an employee works on
each project. This characteristic is listed as part of the third requirement in Section
7.2, and it can be represented by a multivalued composite attribute of EMPLOYEE
called Works_on with the simple components (Project, Hours). Alternatively, it can be
represented as a multivalued composite attribute of PROJECT called Workers with
the simple components (Employee, Hours). We choose the first alternative in Figure
7.8, which shows each of the entity types just described. The Name attribute of
EMPLOYEE is shown as a composite attribute, presumably after consultation with
the users.

=== Page 241 ===
212

Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

7.4 Relationship Types, Relationship Sets,
Roles, and Structural Constraints

In Figure 7.8 there are several implicit relationships among the various entity types.
In fact, whenever an attribute of one entity type refers to another entity type, some
relationship exists. For example, the attribute Manager of DEPARTMENT refers to an
employee who manages the department; the attribute Controlling_department of
PROJECT refers to the department that controls the project; the attribute Supervisor
of EMPLOYEE refers to another employee (the one who supervises this employee);
the attribute Department of EMPLOYEE refers to the department for which the
employee works; and so on. In the ER model, these references should not be repre-
sented as attributes but as relationships, which are discussed in this section. The
COMPANY database schema will be refined in Section 7.6 to represent relationships
explicitly. In the initial design of entity types, relationships are typically captured in
the form of attributes. As the design is refined, these attributes get converted into
relationships between entity types.

This section is organized as follows: Section 7.4.1 introduces the concepts of rela-
tionship types, relationship sets, and relationship instances. We define the concepts
of relationship degree, role names, and recursive relationships in Section 7.4.2, and
then we discuss structural constraints on relationships—such as cardinality ratios
and existence dependencies—in Section 7.4.3. Section 7.4.4 shows how relationship
types can also have attributes.

7.4.1 Relationship Types, Sets, and Instances

A relationship type R among n entity types E,, E,, ..., E,, defines a set of associa-
tions—or a relationship set—among entities from these entity types. As for the
case of entity types and entity sets, a relationship type and its corresponding rela-
tionship set are customarily referred to by the same name, R. Mathematically, the
relationship set R is a set of relationship instances r, where each r; associates n
individual entities (e,, e,, ..., €,,), and each entity e,in risa member of entity set E,
1 $j<n. Hence, a relationship set is a mathematical relation on E,, E,, ..., E,,; alter-
natively, it can be defined as a subset of the Cartesian product of the entity sets E, x
E, x... x E,. Each of the entity types E,, E ,, ..., E,, is said to participate in the rela-
tionship type R; similarly, each of the individual entities e,, e,, ..., e,, is said to
participate in the relationship instance r; = (e,, €), ...5 €,,)-

Informally, each relationship instance r, in R is an association of entities, where the
association includes exactly one entity from each participating entity type. Each
such relationship instance r; represents the fact that the entities participating in r;
are related in some way in the corresponding miniworld situation. For example,
consider a relationship type WORKS_FOR between the two entity types EMPLOYEE
and DEPARTMENT, which associates each employee with the department for which
the employee works in the corresponding entity set. Each relationship instance in
the relationship set WORKS_FOR associates one EMPLOYEE entity and one
DEPARTMENT entity. Figure 7.9 illustrates this example, where each relationship

=== Page 242 ===
7.4 Relationship Types, Relationship Sets, Roles, and Structural Constraints

EMPLOYEE WORKS_FOR DEPARTMENT

 

 

 

 

Figure 7.9

Some instances in the
WORKS_FOR relationship
set, which represents a
relationship type
WORKS_FOR between
EMPLOYEE and
DEPARTMENT.

213

 

instance r, is shown connected to the EMPLOYEE and DEPARTMENT entities that
participate in r;. In the miniworld represented by Figure 7.9, employees e,, e,, and é,
work for department d,; employees e, and e, work for department d,; and employ-
ees e, and e, work for department d,.

In ER diagrams, relationship types are displayed as diamond-shaped boxes, which
are connected by straight lines to the rectangular boxes representing the participat-
ing entity types. The relationship name is displayed in the diamond-shaped box (see
Figure 7.2).

74.2 Relationship Degree, Role Names,
and Recursive Relationships

Degree of a Relationship Type. The degree of a relationship type is the number
of participating entity types. Hence, the WORKS_FOR relationship is of degree two.
A relationship type of degree two is called binary, and one of degree three is called
ternary. An example of a ternary relationship is SUPPLY, shown in Figure 7.10,
where each relationship instance r, associates three entities—a supplier s, a part p,
and a project whenever s supplies part p to project j. Relationships can generally
be of any degree, but the ones most common are binary relationships. Higher-
degree relationships are generally more complex than binary relationships; we char-
acterize them further in Section 7.9.

=== Page 243 ===
214 = Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

Figure 7.10

Some relationship instances in
the SUPPLY ternary relationship

set.

SUPPLIER SUPPLY PROJECT

 

 

 

Relationships as Attributes. It is sometimes convenient to think of a binary
relationship type in terms of attributes, as we discussed in Section 7.3.3. Consider
the WORKS_FOR relationship type in Figure 7.9. One can think of an attribute
called Department of the EMPLOYEE entity type, where the value of Department for
each EMPLOYEE entity is (a reference to) the DEPARTMENT entity for which that
employee works. Hence, the value set for this Department attribute is the set of all
DEPARTMENT entities, which is the DEPARTMENT entity set. This is what we did in
Figure 7.8 when we specified the initial design of the entity type EMPLOYEE for the
COMPANY database. However, when we think of a binary relationship as an attrib-
ute, we always have two options. In this example, the alternative is to think of a mul-
tivalued attribute Employee of the entity type DEPARTMENT whose values for each
DEPARTMENT entity is the set of EMPLOYEE entities who work for that department.
The value set of this Employee attribute is the power set of the EMPLOYEE entity set.
Either of these two attributes—Department of EMPLOYEE or Employee of
DEPARTMENT—can represent the WORKS_FOR relationship type. If both are repre-
sented, they are constrained to be inverses of each other.®

 

8This concept of representing relationship types as attributes is used in a class of data models called
functional data models. In object databases (see Chapter 11), relationships can be represented by ref-
erence attributes, either in one direction or in both directions as inverses. In relational databases (see
Chapter 3), foreign keys are a type of reference attribute used to represent relationships.

=== Page 244 ===
7.4 Relationship Types, Relationship Sets, Roles, and Structural Constraints

Role Names and Recursive Relationships. Each entity type that participates
in a relationship type plays a particular role in the relationship. The role name sig-
nifies the role that a participating entity from the entity type plays in each relation-
ship instance, and helps to explain what the relationship means. For example, in the
WORKS_FOR relationship type, EMPLOYEE plays the role of employee or worker and
DEPARTMENT plays the role of department or employer.

Role names are not technically necessary in relationship types where all the partici-
pating entity types are distinct, since each participating entity type name can be
used as the role name. However, in some cases the same entity type participates
more than once in a relationship type in different roles. In such cases the role name
becomes essential for distinguishing the meaning of the role that each participating
entity plays. Such relationship types are called recursive relationships. Figure 7.11
shows an example. The SUPERVISION relationship type relates an employee to a
supervisor, where both employee and supervisor entities are members of the same
EMPLOYEE entity set. Hence, the EMPLOYEE entity type participates twice in
SUPERVISION: once in the role of supervisor (or boss), and once in the role of
supervisee (or subordinate). Each relationship instance r; in SUPERVISION associates
two employee entities e; and e,, one of which plays the role of supervisor and the
other the role of supervisee. In Figure 7.11, the lines marked ‘1’ represent the super-
visor role, and those marked ‘2’ represent the supervisee role; hence, e, supervises e,
and é;, €, supervises e, and e,, and e, supervises e, and e,. In this example, each rela-
tionship instance must be connected with two lines, one marked with ‘1’ (supervi-
sor) and the other with ‘2’ (supervisee).

215

 

EMPLOYEE SUPERVISION Figure 7.11

A recursive relationship

 

 

 

 

 

 

 

 

[6

 

ny
2
1
2 —# subordinate role (2).
1 2 [——_ '3
1 ° ‘4
} —s
1
2 "5
1
2

SUPERVISION between

EMPLOYEE in the

supervisor role (1) and
I EMPLOYEE in the

=== Page 245 ===
216 = Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

7.4.3 Constraints on Binary Relationship Types

Relationship types usually have certain constraints that limit the possible combina-
tions of entities that may participate in the corresponding relationship set. These
constraints are determined from the miniworld situation that the relationships rep-
resent. For example, in Figure 7.9, if the company has a rule that each employee
must work for exactly one department, then we would like to describe this con-
straint in the schema. We can distinguish two main types of binary relationship
constraints: cardinality ratio and participation.

Cardinality Ratios for Binary Relationships. The cardinality ratio for a binary
relationship specifies the maximum number of relationship instances that an entity
can participate in. For example, in the WORKS_FOR binary relationship type,
DEPARTMENT:EMPLOYEE is of cardinality ratio 1:N, meaning that each department
can be related to (that is, employs) any number of employees,’ but an employee can
be related to (work for) only one department. This means that for this particular
relationship WORKS_FOR, a particular department entity can be related to any
number of employees (N indicates there is no maximum number). On the other
hand, an employee can be related to a maximum of one department. The possible
cardinality ratios for binary relationship types are 1:1, 1:N, N:1, and M:N.

An example of a 1:1 binary relationship is MANAGES (Figure 7.12), which relates a
department entity to the employee who manages that department. This represents
the miniworld constraints that—at any point in time—an employee can manage
one department only and a department can have one manager only. The relation-
ship type WORKS_ON (Figure 7.13) is of cardinality ratio M:N, because the mini-

 

Figure 7.12
A 1:1 relationship,
MANAGES.

EMPLOYEE MANAGES DEPARTMENT

 

 

 

 

 

 

 

9N stands for any number of related entities (zero or more).

=== Page 246 ===
7.4 Relationship Types, Relationship Sets, Roles, and Structural Constraints 217

EMPLOYEE WORKS_ON PROJECT

 

 

Figure 7.13
An MiN relationship,
WORKS_ON.

 

world rule is that an employee can work on several projects and a project can have
several employees.

Cardinality ratios for binary relationships are represented on ER diagrams by dis-
playing 1, M, and N on the diamonds as shown in Figure 7.2. Notice that in this
notation, we can either specify no maximum (N) or a maximum of one (1) on par-
ticipation. An alternative notation (see Section 7.7.4) allows the designer to specify
a specific maximum number on participation, such as 4 or 5.

Participation Constraints and Existence Dependencies. The participation
constraint specifies whether the existence of an entity depends on its being related
to another entity via the relationship type. This constraint specifies the minimum
number of relationship instances that each entity can participate in, and is some-
times called the minimum cardinality constraint. There are two types of participa-
tion constraints—total and partial—that we illustrate by example. If a company
policy states that every employee must work for a department, then an employee
entity can exist only if it participates in at least one WORKS_FOR relationship
instance (Figure 7.9). Thus, the participation of EMPLOYEE in WORKS_FOR is
called total participation, meaning that every entity in the total set of employee
entities must be related to a department entity via WORKS_FOR. Total participation
is also called existence dependency. In Figure 7.12 we do not expect every employee
to manage a department, so the participation of EMPLOYEE in the MANAGES rela-
tionship type is partial, meaning that some or part of the set of employee entities are
related to some department entity via MANAGES, but not necessarily all. We will

=== Page 247 ===
218

Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

refer to the cardinality ratio and participation constraints, taken together, as the
structural constraints of a relationship type.

In ER diagrams, total participation (or existence dependency) is displayed as a
double line connecting the participating entity type to the relationship, whereas par-
tial participation is represented by a single line (see Figure 7.2). Notice that in this
notation, we can either specify no minimum (partial participation) or a minimum
of one (total participation). The alternative notation (see Section 7.7.4) allows the
designer to specify a specific minimum number on participation in the relationship,
such as 4 or 5.

We will discuss constraints on higher-degree relationships in Section 7.9.

7.4.4 Attributes of Relationship Types

Relationship types can also have attributes, similar to those of entity types. For
example, to record the number of hours per week that an employee works on a par-
ticular project, we can include an attribute Hours for the WORKS_ON relationship
type in Figure 7.13. Another example is to include the date on which a manager
started managing a department via an attribute Start_date for the MANAGES rela-
tionship type in Figure 7.12.

Notice that attributes of 1:1 or 1:N relationship types can be migrated to one of the
participating entity types. For example, the Start_date attribute for the MANAGES
relationship can be an attribute of either EMPLOYEE or DEPARTMENT, although
conceptually it belongs to MANAGES. This is because MANAGES is a 1:1 relation-
ship, so every department or employee entity participates in at most one relationship
instance. Hence, the value of the Start_date attribute can be determined separately,
either by the participating department entity or by the participating employee
(manager) entity.

For a 1:N relationship type, a relationship attribute can be migrated only to the
entity type on the N-side of the relationship. For example, in Figure 7.9, if the
WORKS_FOR relationship also has an attribute Start_date that indicates when an
employee started working for a department, this attribute can be included as an
attribute of EMPLOYEE. This is because each employee works for only one depart-
ment, and hence participates in at most one relationship instance in WORKS_FOR.
In both 1:1 and 1:N relationship types, the decision where to place a relationship
attribute—as a relationship type attribute or as an attribute of a participating entity
type—is determined subjectively by the schema designer.

For M:N relationship types, some attributes may be determined by the combination
of participating entities in a relationship instance, not by any single entity. Such
attributes must be specified as relationship attributes. An example is the Hours attrib-
ute of the M:N relationship WORKS_ON (Figure 7.13); the number of hours per
week an employee currently works on a project is determined by an employee-
project combination and not separately by either entity.

=== Page 248 ===
7.5 Weak Entity Types

7.5 Weak Entity Types

Entity types that do not have key attributes of their own are called weak entity
types. In contrast, regular entity types that do have a key attribute—which include
all the examples discussed so far—are called strong entity types. Entities belonging
to a weak entity type are identified by being related to specific entities from another
entity type in combination with one of their attribute values. We call this other
entity type the identifying or owner entity type,'° and we call the relationship type
that relates a weak entity type to its owner the identifying relationship of the weak
entity type.!! A weak entity type always has a total participation constraint (existence
dependency) with respect to its identifying relationship because a weak entity can-
not be identified without an owner entity. However, not every existence dependency
results in a weak entity type. For example, a DRIVER_LICENSE entity cannot exist
unless it is related to a PERSON entity, even though it has its own key
(License_number) and hence is not a weak entity.

Consider the entity type DEPENDENT, related to EMPLOYEE, which is used to keep
track of the dependents of each employee via a 1:N relationship (Figure 7.2). In our
example, the attributes of DEPENDENT are Name (the first name of the dependent),
Birth_date, Sex, and Relationship (to the employee). Two dependents of two distinct
employees may, by chance, have the same values for Name, Birth_date, Sex, and
Relationship, but they are still distinct entities. They are identified as distinct entities
only after determining the particular employee entity to which each dependent is
related. Each employee entity is said to own the dependent entities that are related
to it.

A weak entity type normally has a partial key, which is the attribute that can
uniquely identify weak entities that are related to the same owner entity.'* In our
example, if we assume that no two dependents of the same employee ever have the
same first name, the attribute Name of DEPENDENT is the partial key. In the worst
case, a composite attribute of all the weak entity’s attributes will be the partial key.

In ER diagrams, both a weak entity type and its identifying relationship are distin-
guished by surrounding their boxes and diamonds with double lines (see Figure
7.2). The partial key attribute is underlined with a dashed or dotted line.

Weak entity types can sometimes be represented as complex (composite, multival-
ued) attributes. In the preceding example, we could specify a multivalued attribute
Dependents for EMPLOYEE, which is a composite attribute with component attrib-
utes Name, Birth_date, Sex, and Relationship. The choice of which representation to
use is made by the database designer. One criterion that may be used is to choose the

'0The identifying entity type is also sometimes called the parent entity type or the dominant entity
type.

'IThe weak entity type is also sometimes called the child entity type or the subordinate entity type.

'2The partial key is sometimes called the discriminator.

219

=== Page 249 ===
220

Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

weak entity type representation if there are many attributes. If the weak entity par-
ticipates independently in relationship types other than its identifying relationship
type, then it should not be modeled as a complex attribute.

In general, any number of levels of weak entity types can be defined; an owner
entity type may itself be a weak entity type. In addition, a weak entity type may have
more than one identifying entity type and an identifying relationship type of degree
higher than two, as we illustrate in Section 7.9.

7.6 Refining the ER Design for the COMPANY
Database

We can now refine the database design in Figure 7.8 by changing the attributes that
represent relationships into relationship types. The cardinality ratio and participa-
tion constraint of each relationship type are determined from the requirements
listed in Section 7.2. If some cardinality ratio or dependency cannot be determined
from the requirements, the users must be questioned further to determine these
structural constraints.

In our example, we specify the following relationship types:

m™ MANAGES, a 1:1 relationship type between EMPLOYEE and DEPARTMENT.
EMPLOYEE participation is partial. DEPARTMENT participation is not clear
from the requirements. We question the users, who say that a department
must have a manager at all times, which implies total participation.!°’ The
attribute Start_date is assigned to this relationship type.

™ WORKS_FOR, a I:N relationship type between DEPARTMENT and
EMPLOYEE. Both participations are total.

=™ CONTROLS, a 1:N relationship type between DEPARTMENT and PROJECT.
The participation of PROJECT is total, whereas that of DEPARTMENT is
determined to be partial, after consultation with the users indicates that
some departments may control no projects.

=m SUPERVISION, a 1:N relationship type between EMPLOYEE (in the supervi-
sor role) and EMPLOYEE (in the supervisee role). Both participations are
determined to be partial, after the users indicate that not every employee is a
supervisor and not every employee has a supervisor.

™ WORKS_ON, determined to be an M:N relationship type with attribute
Hours, after the users indicate that a project can have several employees
working on it. Both participations are determined to be total.

m™ DEPENDENTS_OF, a 1:N relationship type between EMPLOYEE and
DEPENDENT, which is also the identifying relationship for the weak entity

 

'18The rules in the miniworld that determine the constraints are sometimes called the business rules,
since they are determined by the business or organization that will utilize the database.

=== Page 250 ===
7.7, ER Diagrams, Naming Conventions, and Design Issues

type DEPENDENT. The participation of EMPLOYEE is partial, whereas that of
DEPENDENT is total.

After specifying the above six relationship types, we remove from the entity types in
Figure 7.8 all attributes that have been refined into relationships. These include
Manager and Manager_start_date from DEPARTMENT; Controlling_department from
PROJECT; Department, Supervisor, and Works_on from EMPLOYEE; and Employee
from DEPENDENT. It is important to have the least possible redundancy when we
design the conceptual schema of a database. If some redundancy is desired at the
storage level or at the user view level, it can be introduced later, as discussed in
Section 1.6.1.

7.7 ER Diagrams, Naming Conventions,
and Design Issues

7.7.1 Summary of Notation for ER Diagrams

Figures 7.9 through 7.13 illustrate examples of the participation of entity types in
relationship types by displaying their sets or extensions—the individual entity
instances in an entity set and the individual relationship instances in a relationship
set. In ER diagrams the emphasis is on representing the schemas rather than the
instances. This is more useful in database design because a database schema changes
rarely, whereas the contents of the entity sets change frequently. In addition, the
schema is obviously easier to display, because it is much smaller.

Figure 7.2 displays the COMPANY ER database schema as an ER diagram. We now
review the full ER diagram notation. Entity types such as EMPLOYEE,
DEPARTMENT, and PROJECT are shown in rectangular boxes. Relationship types
such as WORKS_FOR, MANAGES, CONTROLS, and WORKS_ON are shown in
diamond-shaped boxes attached to the participating entity types with straight lines.
Attributes are shown in ovals, and each attribute is attached by a straight line to its
entity type or relationship type. Component attributes of a composite attribute are
attached to the oval representing the composite attribute, as illustrated by the Name
attribute of EMPLOYEE. Multivalued attributes are shown in double ovals, as illus-
trated by the Locations attribute of DEPARTMENT. Key attributes have their names
underlined. Derived attributes are shown in dotted ovals, as illustrated by the
Number_of_employees attribute of DEPARTMENT.

Weak entity types are distinguished by being placed in double rectangles and by
having their identifying relationship placed in double diamonds, as illustrated by
the DEPENDENT entity type and the DEPENDENTS_OF identifying relationship
type. The partial key of the weak entity type is underlined with a dotted line.

In Figure 7.2 the cardinality ratio of each binary relationship type is specified by
attaching a 1, M, or N on each participating edge. The cardinality ratio of
DEPARTMENT:EMPLOYEE in MANAGES is 1:1, whereas it is 1:N for DEPARTMENT:
EMPLOYEE in WORKS_FOR, and M:N for WORKS_ON. The participation

221

=== Page 251 ===
222

Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

constraint is specified by a single line for partial participation and by double lines
for total participation (existence dependency).

In Figure 7.2 we show the role names for the SUPERVISION relationship type
because the same EMPLOYEE entity type plays two distinct roles in that relationship.
Notice that the cardinality ratio is 1:N from supervisor to supervisee because each
employee in the role of supervisee has at most one direct supervisor, whereas an
employee in the role of supervisor can supervise zero or more employees.

Figure 7.14 summarizes the conventions for ER diagrams. It is important to note
that there are many other alternative diagrammatic notations (see Section 7.7.4 and
Appendix A).

7.7.2 Proper Naming of Schema Constructs

When designing a database schema, the choice of names for entity types, attributes,
relationship types, and (particularly) roles is not always straightforward. One
should choose names that convey, as much as possible, the meanings attached to the
different constructs in the schema. We choose to use singular names for entity types,
rather than plural ones, because the entity type name applies to each individual
entity belonging to that entity type. In our ER diagrams, we will use the convention
that entity type and relationship type names are uppercase letters, attribute names
have their initial letter capitalized, and role names are lowercase letters. We have
used this convention in Figure 7.2.

As a general practice, given a narrative description of the database requirements, the
nouns appearing in the narrative tend to give rise to entity type names, and the verbs
tend to indicate names of relationship types. Attribute names generally arise from
additional nouns that describe the nouns corresponding to entity types.

Another naming consideration involves choosing binary relationship names to
make the ER diagram of the schema readable from left to right and from top to bot-
tom. We have generally followed this guideline in Figure 7.2. To explain this naming
convention further, we have one exception to the convention in Figure 7.2—the
DEPENDENTS_OF relationship type, which reads from bottom to top. When we
describe this relationship, we can say that the DEPENDENT entities (bottom entity
type) are DEPENDENTS_OF (relationship name) an EMPLOYEE (top entity type).
To change this to read from top to bottom, we could rename the relationship type to
HAS_DEPENDENTS, which would then read as follows: An EMPLOYEE entity (top
entity type) HAS_DEPENDENTS (relationship name) of type DEPENDENT (bottom
entity type). Notice that this issue arises because each binary relationship can be
described starting from either of the two participating entity types, as discussed in
the beginning of Section 7.4.

7.73 Design Choices for ER Conceptual Design

It is occasionally difficult to decide whether a particular concept in the miniworld
should be modeled as an entity type, an attribute, or a relationship type. In this

=== Page 252 ===
7.7, ER Diagrams, Naming Conventions, and Design Issues 223

 

Symbol

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Ey <o E,
E, Hae E,
(min, max)

E

Meaning Figure 7.14
Summary of the notation

Entity for ER diagrams.

Weak Entity

Relationship

Indentifying Relationship

Attribute

Key Attribute

Multivalued Attribute

Composite Attribute

Derived Attribute

Total Participation of E, in R

Cardinality Ratio 1: N for E,:E, in R

Structural Constraint (min, max)
on Participation of Ein R

=== Page 253 ===
224

Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

section, we give some brief guidelines as to which construct should be chosen in
particular situations.

In general, the schema design process should be considered an iterative refinement
process, where an initial design is created and then iteratively refined until the most
suitable design is reached. Some of the refinements that are often used include the
following:

= A concept may be first modeled as an attribute and then refined into a rela-
tionship because it is determined that the attribute is a reference to another
entity type. It is often the case that a pair of such attributes that are inverses
of one another are refined into a binary relationship. We discussed this type
of refinement in detail in Section 7.6. It is important to note that in
our notation, once an attribute is replaced by a relationship, the attribute
itself should be removed from the entity type to avoid duplication and
redundancy.

= Similarly, an attribute that exists in several entity types may be elevated or
promoted to an independent entity type. For example, suppose that several
entity types in a UNIVERSITY database, such as STUDENT, INSTRUCTOR, and
COURSE, each has an attribute Department in the initial design; the designer
may then choose to create an entity type DEPARTMENT with a single attrib-
ute Dept_name and relate it to the three entity types (STUDENT,
INSTRUCTOR, and COURSE) via appropriate relationships. Other attrib-
utes/relationships of DEPARTMENT may be discovered later.

m An inverse refinement to the previous case may be applied—for example, if
an entity type DEPARTMENT exists in the initial design with a single attribute
Dept_name and is related to only one other entity type, STUDENT. In this
case, DEPARTMENT may be reduced or demoted to an attribute of STUDENT.

= Section 7.9 discusses choices concerning the degree of a relationship. In
Chapter 8, we discuss other refinements concerning specialization/general-
ization. Chapter 10 discusses additional top-down and bottom-up refine-
ments that are common in large-scale conceptual schema design.

7.74 Alternative Notations for ER Diagrams

There are many alternative diagrammatic notations for displaying ER diagrams.
Appendix A gives some of the more popular notations. In Section 7.8, we introduce
the Unified Modeling Language (UML) notation for class diagrams, which has been
proposed as a standard for conceptual object modeling.

In this section, we describe one alternative ER notation for specifying structural
constraints on relationships, which replaces the cardinality ratio (1:1, 1:N, M:N)
and single/double line notation for participation constraints. This notation involves
associating a pair of integer numbers (min, max) with each participation of an
entity type E in a relationship type R, where 0 < min < max and max 2 1. The num-
bers mean that for each entity e in E, e must participate in at least min and at most

=== Page 254 ===
7.7, ER Diagrams, Naming Conventions, and Design Issues 225

max relationship instances in R at any point in time. In this method, min = 0 implies partial participation,
whereas min > 0 implies total participation.

Figure 7.15 displays the COMPANY database schema using the (min, max) notation.! Usually, one uses
either the cardinality ratio/single-line/double-line notation or the (min, max) notation. The (min, max)

 

Figure 7.15
ER diagrams for the company schema, with structural con-
straints specified using (min, max) notation and role names.

 
 
  
   
       

 

WORKS_FOR (4,N)
Department »

EMPLOYEE ( 9 NO” © eee Tee =e DEPARTMENT

one Department (0,N) | Controlling
Manager Managed Department
CONTROLS
(1,N)
(ON) (0.1) Worker Controlled
Supervisor ° (1,1) | Project
upervisee j
WORKS_ON >! | BROJECT
(1,N)
(0,N)
Employee C Name >

Humber)

   
 

 

 

   
  
 

 

 

 

      
    
  

 

 

  

 

 

 

 

 

 

DEPENDENTS_OF

(1,1) | Dependent

 

 

DEPENDENT

'4In some notations, particularly those used in object modeling methodologies such as UML, the (min,
max) is placed on the opposite sides to the ones we have shown. For example, for the WORKS_FOR
relationship in Figure 7.15, the (1,1) would be on the DEPARTMENT side, and the (4,N) would be on the
EMPLOYEE side. Here we used the original notation from Abrial (1974).

 

 

 

 

 

 

   

 

=== Page 255 ===
226

Figure 7.16

Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

notation is more precise, and we can use it to specify some structural constraints for
relationship types of higher degree. However, it is not sufficient for specifying some
key constraints on higher-degree relationships, as discussed in Section 7.9.

Figure 7.15 also displays all the role names for the COMPANY database schema.

7.8 Example of Other Notation:
UML Class Diagrams

The UML methodology is being used extensively in software design and has many
types of diagrams for various software design purposes. We only briefly present the
basics of UML class diagrams here, and compare them with ER diagrams. In some
ways, class diagrams can be considered as an alternative notation to ER diagrams.
Additional UML notation and concepts are presented in Section 8.6, and in Chapter
10. Figure 7.16 shows how the COMPANY ER database schema in Figure 7.15 can be
displayed using UML class diagram notation. The entity types in Figure 7.15 are
modeled as classes in Figure 7.16. An entity in ER corresponds to an object in UML.

The COMPANY conceptual schema
in UML class diagram notation.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

EMPLOYEE 4* WORKS FOR 1.1 DEPARTMENT Multiplicity
Name: Name_dom ~ = — Name Notation in OMT:
Fname 14 0.1 Number —— 1.1
Minit - —] add_employee @ 0.
Lname number_of_employees 0 0.1

Ssn MANAGES change_manager 0.*
Bdate: Date Start dat
Sex: {M,F} ee
Address 14 1..1
Salary ~
age . 1%
change_department CONTROLS LOCATION
change_projects supervisee | |\WORKS_ON Name
Hours 14
Dependent_name || 0..1 1.5 * °
supervisor PROJECT
0.*
Name
DEPENDENT Number
Sex: {M,F} add_employee Aggregation
Birth_date: Date add_project Notation in UML:
Relationship change_manager
Whole K >—_ Part

 

 

 

 

 

 

 

 

 

 

 

 

 

=== Page 256 ===
7.8 Example of Other Notation: UML Class Diagrams

In UML class diagrams, a class (similar to an entity type in ER) is displayed as a box
(see Figure 7.16) that includes three sections: The top section gives the class name
(similar to entity type name); the middle section includes the attributes; and the
last section includes operations that can be applied to individual objects (similar to
individual entities in an entity set) of the class. Operations are not specified in ER
diagrams. Consider the EMPLOYEE class in Figure 7.16. Its attributes are Name, Ssn,
Bdate, Sex, Address, and Salary. The designer can optionally specify the domain of
an attribute if desired, by placing a colon (:) followed by the domain name or
description, as illustrated by the Name, Sex, and Bdate attributes of EMPLOYEE in
Figure 7.16. A composite attribute is modeled as a structured domain, as illustrated
by the Name attribute of EMPLOYEE. A multivalued attribute will generally be mod-
eled as a separate class, as illustrated by the LOCATION class in Figure 7.16.

Relationship types are called associations in UML terminology, and relationship
instances are called links. A binary association (binary relationship type) is repre-
sented as a line connecting the participating classes (entity types), and may option-
ally have a name. A relationship attribute, called a link attribute, is placed in a box
that is connected to the association’s line by a dashed line. The (min, max) notation
described in Section 7.7.4 is used to specify relationship constraints, which are
called multiplicities in UML terminology. Multiplicities are specified in the form
min..max, and an asterisk (*) indicates no maximum limit on participation.
However, the multiplicities are placed on the opposite ends of the relationship when
compared with the notation discussed in Section 7.7.4 (compare Figures 7.15 and
7.16). In UML, a single asterisk indicates a multiplicity of 0..*, and a single 1 indi-
cates a multiplicity of 1..1. A recursive relationship (see Section 7.4.2) is called a
reflexive association in UML, and the role names—like the multiplicities—are
placed at the opposite ends of an association when compared with the placing of
role names in Figure 7.15.

In UML, there are two types of relationships: association and aggregation.
Aggregation is meant to represent a relationship between a whole object and its
component parts, and it has a distinct diagrammatic notation. In Figure 7.16, we
modeled the locations of a department and the single location of a project as aggre-
gations. However, aggregation and association do not have different structural
properties, and the choice as to which type of relationship to use is somewhat sub-
jective. In the ER model, both are represented as relationships.

UML also distinguishes between unidirectional and bidirectional associations (or
aggregations). In the unidirectional case, the line connecting the classes is displayed
with an arrow to indicate that only one direction for accessing related objects is
needed. If no arrow is displayed, the bidirectional case is assumed, which is the
default. For example, if we always expect to access the manager of a department
starting from a DEPARTMENT object, we would draw the association line represent-
ing the MANAGES association with an arrow from DEPARTMENT to EMPLOYEE. In
addition, relationship instances may be specified to be ordered. For example, we
could specify that the employee objects related to each department through the
WORKS_FOR association (relationship) should be ordered by their Salary attribute

227

=== Page 257 ===
228

Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

value. Association (relationship) names are optional in UML, and relationship
attributes are displayed in a box attached with a dashed line to the line representing
the association/aggregation (see Start_date and Hours in Figure 7.16).

The operations given in each class are derived from the functional requirements of
the application, as we discussed in Section 7.1. It is generally sufficient to specify the
operation names initially for the logical operations that are expected to be applied
to individual objects of a class, as shown in Figure 7.16. As the design is refined,
more details are added, such as the exact argument types (parameters) for each
operation, plus a functional description of each operation. UML has function
descriptions and sequence diagrams to specify some of the operation details, but
these are beyond the scope of our discussion. Chapter 10 will introduce some of
these diagrams.

Weak entities can be modeled using the construct called qualified association (or
qualified aggregation) in UML; this can represent both the identifying relationship
and the partial key, which is placed in a box attached to the owner class. This is illus-
trated by the DEPENDENT class and its qualified aggregation to EMPLOYEE in
Figure 7.16. The partial key Dependent_name is called the discriminator in UML ter-
minology, since its value distinguishes the objects associated with (related to) the
same EMPLOYEE. Qualified associations are not restricted to modeling weak enti-
ties, and they can be used to model other situations in UML.

This section is not meant to be a complete description of UML class diagrams, but
rather to illustrate one popular type of alternative diagrammatic notation that can
be used for representing ER modeling concepts.

7.9 Relationship Types of Degree
Higher than Two

In Section 7.4.2 we defined the degree of a relationship type as the number of par-
ticipating entity types and called a relationship type of degree two binary and a rela-
tionship type of degree three ternary. In this section, we elaborate on the differences
between binary and higher-degree relationships, when to choose higher-degree ver-
sus binary relationships, and how to specify constraints on higher-degree relation-
ships.

7.9.1 Choosing between Binary and Ternary
(or Higher-Degree) Relationships

The ER diagram notation for a ternary relationship type is shown in Figure 7.17(a),
which displays the schema for the SUPPLY relationship type that was displayed at
the entity set/relationship set or instance level in Figure 7.10. Recall that the rela-
tionship set of SUPPLY is a set of relationship instances (s, j, p), where s is a
SUPPLIER who is currently supplying a PART p to a PROJECT j. In general, a rela-
tionship type R of degree n will have n edges in an ER diagram, one connecting R to
each participating entity type.

=== Page 258 ===
7.9 Relationship Types of Degree Higher than Two

 

 

229

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

(a) SUPPLIER PROJECT
PART
Sname (Proj name)
(b) SUPPLIER M N PROJECT
M M
CAN_SUPPLY USES
N Fat N
PART

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

(c)
N 1
SUPPLIER | > SUPPLY
N

Figure 7.17

Ternary relationship types. (a) The SUPPLY
relationship. (b) Three binary relationships
not equivalent to SUPPLY. (c) SUPPLY
represented as a weak entity type.

®

 

Couey N
PART

 

 

 

PROJECT

 

 

 

 

 

 

Figure 7.17(b) shows an ER diagram for three binary relationship types
CAN_SUPPLY, USES, and SUPPLIES. In general, a ternary relationship type repre-
sents different information than do three binary relationship types. Consider the
three binary relationship types CAN_SUPPLY, USES, and SUPPLIES. Suppose that
CAN_SUPPLY, between SUPPLIER and PART, includes an instance (s, p) whenever
supplier s can supply part p (to any project); USES, between PROJECT and PART,
includes an instance (j, p) whenever project j uses part p; and SUPPLIES, between
SUPPLIER and PROJECT, includes an instance (s, j) whenever supplier s supplies

=== Page 259 ===
230 Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

some part to project j. The existence of three relationship instances (s, p), (j, p), and
(s, 7) in CAN_SUPPLY, USES, and SUPPLIES, respectively, does not necessarily imply
that an instance (s, j, p) exists in the ternary relationship SUPPLY, because the
meaning is different. It is often tricky to decide whether a particular relationship
should be represented as a relationship type of degree n or should be broken down
into several relationship types of smaller degrees. The designer must base this
decision on the semantics or meaning of the particular situation being represented.
The typical solution is to include the ternary relationship plus one or more of the
binary relationships, if they represent different meanings and if all are needed by the
application.

Some database design tools are based on variations of the ER model that permit
only binary relationships. In this case, a ternary relationship such as SUPPLY must
be represented as a weak entity type, with no partial key and with three identifying
relationships. The three participating entity types SUPPLIER, PART, and PROJECT
are together the owner entity types (see Figure 7.17(c)). Hence, an entity in the weak
entity type SUPPLY in Figure 7.17(c) is identified by the combination of its three
owner entities from SUPPLIER, PART, and PROJECT.

It is also possible to represent the ternary relationship as a regular entity type by
introducing an artificial or surrogate key. In this example, a key attribute Supply_id
could be used for the supply entity type, converting it into a regular entity type.
Three binary N:1 relationships relate SUPPLY to the three participating entity types.

Another example is shown in Figure 7.18. The ternary relationship type OFFERS
represents information on instructors offering courses during particular semesters;
hence it includes a relationship instance (i, s, c) whenever INSTRUCTOR i offers
COURSE c during SEMESTER s. The three binary relationship types shown in
Figure 7.18 have the following meanings: CAN_TEACH relates a course to the
instructors who can teach that course, AUGHT_DURING relates a semester to the
instructors who taught some course during that semester, and OFFERED_DURING

 

Figure 7.18

Another example of ternary versus (Semester) C Year)

binary relationship types. TAUGHT_DURING

CAname >) Sem_year

INSTRUCTOR SEMESTER

 

 

 

 

 

 

 

 

 

 

 
 

CAN_TEACH OFFERED_DURING

   

Cnumber

 

COURSE

 

 

 

=== Page 260 ===
7.9 Relationship Types of Degree Higher than Two

relates a semester to the courses offered during that semester by any instructor.
These ternary and binary relationships represent different information, but certain
constraints should hold among the relationships. For example, a relationship
instance (i, s, c) should not exist in OFFERS unless an instance (i, s) exists in
TAUGHT_DURING, an instance (s, c) exists in OFFERED_DURING, and an instance (i,
c) exists in CAN_TEACH. However, the reverse is not always true; we may have
instances (i, s), (s, c), and (i, c) in the three binary relationship types with no corre-
sponding instance (i, s, c) in OFFERS. Note that in this example, based on the mean-
ings of the relationships, we can infer the instances of TAUGHT_DURING and
OFFERED_DURING from the instances in OFFERS, but we cannot infer the
instances of CAN_TEACH; therefore, TAUGHT_DURING and OFFERED_DURING are
redundant and can be left out.

Although in general three binary relationships cannot replace a ternary relationship,
they may do so under certain additional constraints. In our example, if the
CAN_TEACH relationship is 1:1 (an instructor can teach one course, and a course
can be taught by only one instructor), then the ternary relationship OFFERS can be
left out because it can be inferred from the three binary relationships CAN_TEACH,
TAUGHT_DURING, and OFFERED_DURING. The schema designer must analyze the
meaning of each specific situation to decide which of the binary and ternary rela-
tionship types are needed.

Notice that it is possible to have a weak entity type with a ternary (or n-ary) identi-
fying relationship type. In this case, the weak entity type can have several owner
entity types. An example is shown in Figure 7.19. This example shows part of a data-
base that keeps track of candidates interviewing for jobs at various companies, and
may be part of an employment agency database, for example. In the requirements, a
candidate can have multiple interviews with the same company (for example, with
different company departments or on separate dates), but a job offer is made based
on one of the interviews. Here, INTERVIEW is represented as a weak entity with two
owners CANDIDATE and COMPANY, and with the partial key Dept_date. An
INTERVIEW entity is uniquely identified by a candidate, a company, and the combi-
nation of the date and department of the interview.

231

 

<> (name>) Figure 7.19

A weak entity type INTERVIEW
with a ternary identifying rela-

COMPANY tionship type.

  
 
 
    

 

 

 

 

CANDIDATE

 

 

 

 

 

 

Department

 

 

 

 

 

 

INTERVIEW JOB_OFFER

 

 

 

 

 

 

 

=== Page 261 ===
232

Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

7.9.2 Constraints on Ternary (or Higher-Degree)
Relationships

There are two notations for specifying structural constraints on n-ary relationships,
and they specify different constraints. They should thus both be used if it is impor-
tant to fully specify the structural constraints on a ternary or higher-degree rela-
tionship. The first notation is based on the cardinality ratio notation of binary
relationships displayed in Figure 7.2. Here, a 1, M, or N is specified on each partici-
pation arc (both M and N symbols stand for many or any number).'> Let us illus-
trate this constraint using the SUPPLY relationship in Figure 7.17.

Recall that the relationship set of SUPPLY is a set of relationship instances (s, j, p),
where s is a SUPPLIER, j is a PROJECT, and p is a PART. Suppose that the constraint
exists that for a particular project-part combination, only one supplier will be used
(only one supplier supplies a particular part to a particular project). In this case, we
place 1 on the SUPPLIER participation, and M, N on the PROJECT, PART participa-
tions in Figure 7.17. This specifies the constraint that a particular (j, p) combination
can appear at most once in the relationship set because each such (PROJECT, PART)
combination uniquely determines a single supplier. Hence, any relationship
instance (s, j, p) is uniquely identified in the relationship set by its (j, p) combina-
tion, which makes (j, p) a key for the relationship set. In this notation, the participa-
tions that have a 1 specified on them are not required to be part of the identifying
key for the relationship set.!¢ If all three cardinalities are M or N, then the key will
be the combination of all three participants.

The second notation is based on the (min, max) notation displayed in Figure 7.15
for binary relationships. A (min, max) on a participation here specifies that each
entity is related to at least min and at most max relationship instances in the relation-
ship set. These constraints have no bearing on determining the key of an n-ary rela-
tionship, where n > 2,!7 but specify a different type of constraint that places
restrictions on how many relationship instances each entity can participate in.

7.10 Summary

In this chapter we presented the modeling concepts of a high-level conceptual data
model, the Entity-Relationship (ER) model. We started by discussing the role that a
high-level data model plays in the database design process, and then we presented a
sample set of database requirements for the COMPANY database, which is one of the
examples that is used throughout this book. We defined the basic ER model con-
cepts of entities and their attributes. Then we discussed NULL values and presented

 

'SThis notation allows us to determine the key of the relationship relation, as we discuss in Chapter 9.
‘This is also true for cardinality ratios of binary relationships.

'7The (min, max) constraints can determine the keys for binary relationships, though.

=== Page 262 ===
7.10 Summary 233

the various types of attributes, which can be nested arbitrarily to produce complex
attributes:

= Simple or atomic
= Composite
= Multivalued

We also briefly discussed stored versus derived attributes. Then we discussed the ER
model concepts at the schema or “intension” level:

Entity types and their corresponding entity sets
Key attributes of entity types

=
=

m Value sets (domains) of attributes

= Relationship types and their corresponding relationship sets
=

Participation roles of entity types in relationship types

We presented two methods for specifying the structural constraints on relationship
types. The first method distinguished two types of structural constraints:

= Cardinality ratios (1:1, 1:N, M:N for binary relationships)
= Participation constraints (total, partial)

We noted that, alternatively, another method of specifying structural constraints is
to specify minimum and maximum numbers (min, max) on the participation of
each entity type in a relationship type. We discussed weak entity types and the
related concepts of owner entity types, identifying relationship types, and partial
key attributes.

Entity-Relationship schemas can be represented diagrammatically as ER diagrams.
We showed how to design an ER schema for the COMPANY database by first defin-
ing the entity types and their attributes and then refining the design to include rela-
tionship types. We displayed the ER diagram for the COMPANY database schema.
We discussed some of the basic concepts of UML class diagrams and how they relate
to ER modeling concepts. We also described ternary and higher-degree relationship
types in more detail, and discussed the circumstances under which they are distin-
guished from binary relationships.

The ER modeling concepts we have presented thus far—entity types, relationship
types, attributes, keys, and structural constraints—can model many database appli-
cations. However, more complex applications—such as engineering design, medical
information systems, and telecommunications—require additional concepts if we
want to model them with greater accuracy. We discuss some advanced modeling
concepts in Chapter 8 and revisit further advanced data modeling techniques in
Chapter 26.

=== Page 263 ===
234

Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

Review Questions

7.1,

7.2.

7.3.

7.4.

7.5.
7.6.

7.7.

7.8.

7.9.

7.10.

7.11.

7.12.

7.13.

7.14.

7.15.

Discuss the role of a high-level data model in the database design process.
List the various cases where use of a NULL value would be appropriate.

Define the following terms: entity, attribute, attribute value, relationship
instance, composite attribute, multivalued attribute, derived attribute, complex
attribute, key attribute, and value set (domain).

What is an entity type? What is an entity set? Explain the differences among
an entity, an entity type, and an entity set.

Explain the difference between an attribute and a value set.

What is a relationship type? Explain the differences among a relationship
instance, a relationship type, and a relationship set.

What is a participation role? When is it necessary to use role names in the
description of relationship types?

Describe the two alternatives for specifying structural constraints on rela-
tionship types. What are the advantages and disadvantages of each?

Under what conditions can an attribute of a binary relationship type be
migrated to become an attribute of one of the participating entity types?

When we think of relationships as attributes, what are the value sets of these
attributes? What class of data models is based on this concept?

What is meant by a recursive relationship type? Give some examples of
recursive relationship types.

When is the concept of a weak entity used in data modeling? Define the
terms owner entity type, weak entity type, identifying relationship type, and
partial key.

Can an identifying relationship of a weak entity type be of a degree greater
than two? Give examples to illustrate your answer.

Discuss the conventions for displaying an ER schema as an ER diagram.

Discuss the naming conventions used for ER schema diagrams.

Exercises

7.16.

Consider the following set of requirements for a UNIVERSITY database that is
used to keep track of students’ transcripts. This is similar but not identical to
the database shown in Figure 1.2:

a. The university keeps track of each student’s name, student number, Social
Security number, current address and phone number, permanent address
and phone number, birth date, sex, class (freshman, sophomore, ..., grad-
uate), major department, minor department (if any), and degree program

=== Page 264 ===
7.17.

7.18.

7.19.

7.20.

(B.A., B.S., ..., Ph.D.). Some user applications need to refer to the city,
state, and ZIP Code of the student’s permanent address and to the stu-
dent’s last name. Both Social Security number and student number have
unique values for each student.

b. Each department is described by a name, department code, office num-
ber, office phone number, and college. Both name and code have unique
values for each department.

c. Each course has a course name, description, course number, number of
semester hours, level, and offering department. The value of the course
number is unique for each course.

d. Each section has an instructor, semester, year, course, and section num-
ber. The section number distinguishes sections of the same course that are
taught during the same semester/year; its values are 1, 2, 3, ..., up to the
number of sections taught during each semester.

e. A grade report has a student, section, letter grade, and numeric grade (0,
1, 2, 3, or 4).

Design an ER schema for this application, and draw an ER diagram for the
schema. Specify key attributes of each entity type, and structural constraints
on each relationship type. Note any unspecified requirements, and make
appropriate assumptions to make the specification complete.

Composite and multivalued attributes can be nested to any number of levels.
Suppose we want to design an attribute for a STUDENT entity type to keep
track of previous college education. Such an attribute will have one entry for
each college previously attended, and each such entry will be composed of
college name, start and end dates, degree entries (degrees awarded at that
college, if any), and transcript entries (courses completed at that college, if
any). Each degree entry contains the degree name and the month and year
the degree was awarded, and each transcript entry contains a course name,
semester, year, and grade. Design an attribute to hold this information. Use
the conventions in Figure 7.5.

Show an alternative design for the attribute described in Exercise 7.17 that
uses only entity types (including weak entity types, if needed) and relation-
ship types.

Consider the ER diagram in Figure 7.20, which shows a simplified schema
for an airline reservations system. Extract from the ER diagram the require-
ments and constraints that produced this schema. Try to be as precise as pos-
sible in your requirements and constraints specification.

In Chapters 1 and 2, we discussed the database environment and database
users. We can consider many entity types to describe such an environment,
such as DBMS, stored database, DBA, and catalog/data dictionary. Try to
specify all the entity types that can fully describe a database system and its
environment; then specify the relationship types among them, and draw an
ER diagram to describe such a general database environment.

Exercises

235

=== Page 265 ===
236 = Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

Figure 7.20
An ER diagram for an AIRLINE database schema.

Ripon code) (iy) Stato) (Name) _~GeparTuRE>

 

 

 

 

 

 

 

 

 

 

 

 

 
 
   

1 AIRPORT N [eg.nd
AIRPORT Scheduled_dep_time Scheduled_arr_time FLIGHT _LEG
N

 

M
1 ARRIVAL_
CAN_ AIRPORT Instances
LAND
N Number)
Type_name Max_seats)
AIRPLANE _ 1 N
Weekdays

 

 

 

 

 

Arr_time

 

 

 

 

 

DEPARTS 1
, N ARRIVES
Dep_time
TYPE N N

 

 

N FARE

Airplane_id CTotal_no_of_seats> No_of_avail_seatS>
1 N
AIRPLANE LEG_INSTANCE

Customer_name

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

   
   

 

Notes:

A LEG (segment) is a nonstop portion of a flight
A LEG_INSTANCE is a particular occurrence
of aLEG on a particular date.

 

 

 

 

 

 

 

 

7.21. Design an ER schema for keeping track of information about votes taken in
the U.S. House of Representatives during the current two-year congressional
session. The database needs to keep track of each U.S. STATE’s Name (e.g.,
“Texas, ‘New York’, ‘California’) and include the Region of the state (whose
domain is {‘Northeast’, ‘Midwest’, ‘Southeast’, ‘Southwest’, “West’}). Each

=== Page 266 ===
7.22.

7.23.

7.24,

7.25.

CONGRESS_PERSON in the House of Representatives is described by his or
her Name, plus the District represented, the Start_date when the congressper-
son was first elected, and the political Party to which he or she belongs
(whose domain is {‘Republican’, ‘Democrat’, ‘Independent’ “Other’}). The
database keeps track of each BILL (i.e., proposed law), including the
Bill_name, the Date_of_vote on the bill, whether the bill Passed_or_failed
(whose domain is {Yes} ‘No’}), and the Sponsor (the congressperson(s) who
sponsored—that is, proposed—the bill). The database also keeps track of
how each congressperson voted on each bill (domain of Vote attribute is
{"Yes’ ‘No’ ‘Abstain’ ‘Absent’}). Draw an ER schema diagram for this applica-
tion. State clearly any assumptions you make.

A database is being constructed to keep track of the teams and games of a
sports league. A team has a number of players, not all of whom participate in
each game. It is desired to keep track of the players participating in each
game for each team, the positions they played in that game, and the result of
the game. Design an ER schema diagram for this application, stating any
assumptions you make. Choose your favorite sport (e.g., soccer, baseball,
football).

Consider the ER diagram shown in Figure 7.21 for part of a BANK database.
Each bank can have multiple branches, and each branch can have multiple
accounts and loans.

a. List the strong (nonweak) entity types in the ER diagram.

b. Is there a weak entity type? If so, give its name, partial key, and identifying
relationship.

c. What constraints do the partial key and the identifying relationship of the
weak entity type specify in this diagram?

d. List the names of all relationship types, and specify the (min, max) con-
straint on each participation of an entity type in a relationship type.
Justify your choices.

e. List concisely the user requirements that led to this ER schema design.

f. Suppose that every customer must have at least one account but is
restricted to at most two loans at a time, and that a bank branch cannot
have more than 1,000 loans. How does this show up on the (min, max)
constraints?

Consider the ER diagram in Figure 7.22. Assume that an employee may work
in up to two departments or may not be assigned to any department. Assume
that each department must have one and may have up to three phone num-
bers. Supply (min, max) constraints on this diagram. State clearly any addi-
tional assumptions you make. Under what conditions would the relationship
HAS_PHONE be redundant in this example?

Consider the ER diagram in Figure 7.23. Assume that a course may or may
not use a textbook, but that a text by definition is a book that is used in some
course. A course may not use more than five books. Instructors teach from

Exercises

237

=== Page 267 ===
238 = Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

 

 

 

 

 

1 N
BANK BRANCHES BANK_BRANCH

 

 

 

 

 

 

 

 

e
l

Branch_no

ACCTS LOANS

N

ACCOUNT LOAN

Amount

ip
i

fC

 

 

 

 

 

 

 

 

 

 

 

 

<=
=

Figure 7.21
CUSTOMER An ER diagram for a BANK
Figure 7.22

database schema.
EMPLOYEE oan DEPARTMENT
Part of an ER diagram

for a COMPANY data-
PHONE

base,

 

 

 

 

 

 

 

 

 

 

 

 

=== Page 268 ===
 

INSTRUCTOR COURSE

 

 

 

 

TEXT

Exercises 239

Figure 7.23

Part of an ER diagram
for a COURSES data-
base.

 

7.26.

7.27.

two to four courses. Supply (min, max) constraints on this diagram. State
clearly any additional assumptions you make. If we add the relationship
ADOPTS, to indicate the textbook(s) that an instructor uses for a course,
should it be a binary relationship between INSTRUCTOR and TEXT, or a ter-
nary relationship between all three entity types? What (min, max) con-
straints would you put on it? Why?

Consider an entity type SECTION in a UNIVERSITY database, which describes
the section offerings of courses. The attributes of SECTION are
Section_number, Semester, Year, Course_number, Instructor, Room_no (where
section is taught), Building (where section is taught), Weekdays (domain is
the possible combinations of weekdays in which a section can be offered
{‘MWF; ‘MW, ‘TT? and so on}), and Hours (domain is all possible time peri-
ods during which sections are offered {*9-9:50 A.M’, “10-10:50 A.M, ...,
“3:30-4:50 P.M.) “5:30-6:20 P.M., and so on}). Assume that Section_number is
unique for each course within a particular semester/year combination (that
is, if a course is offered multiple times during a particular semester, its sec-
tion offerings are numbered 1, 2, 3, and so on). There are several composite
keys for section, and some attributes are components of more than one key.
Identify three composite keys, and show how they can be represented in an
ER schema diagram.

Cardinality ratios often dictate the detailed design of a database. The cardi-
nality ratio depends on the real-world meaning of the entity types involved
and is defined by the specific application. For the following binary relation-
ships, suggest cardinality ratios based on the common-sense meaning of the
entity types. Clearly state any assumptions you make.

Entity 1 Cardinality Ratio Entity 2
STUDENT SOCIAL_SECURITY_CARD
STUDENT TEACHER

CLASSROOM WALL

=== Page 269 ===
240 Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

4. COUNTRY CURRENT_PRESIDENT
5. COURSE TEXTBOOK

6. ITEM (that can
be found in an

order) ORDER
STUDENT CLASS
8. CLASS INSTRUCTOR
INSTRUCTOR OFFICE
10. EBAY_AUCTION
_ITEM EBAY_BID

7.28. Consider the ER schema for the MOVIES database in Figure 7.24.

Assume that MOVIES is a populated database. ACTOR is used as a generic
term and includes actresses. Given the constraints shown in the ER schema,
respond to the following statements with True, False, or Maybe. Assign a
response of Maybe to statements that, while not explicitly shown to be True,
cannot be proven False based on the schema as shown. Justify each answer.

 

Figure 7.24
An ER diagram for a MOVIES
database schema.

   
    
  
 
  

PERFORMS_IN

LEAD_ROLE

     
 
 

DIRECTOR

 

ACTOR_
PRODUCER

 

DIRECTOR

    
 

PRODUCER

PRODUCES

=== Page 270 ===
7.29.

7.30.

+ 2 20 5 wp

=> a

m.

Laboratory Exercises

. There are no actors in this database that have been in no movies.
. There are some actors who have acted in more than ten movies.

. Some actors have done a lead role in multiple movies.

. A movie can have only a maximum of two lead actors.

. Every director has been an actor in some movie.

No producer has ever been an actor.

. A producer cannot be an actor in some other movie.

. There are movies with more than a dozen actors.

. Some producers have been a director as well.

. Most movies have one director and one producer.

. Some movies have one director but several producers.

. There are some actors who have done a lead role, directed a movie, and

produced some movie.
No movie has a director who also acted in that movie.

Given the ER schema for the MOVIES database in Figure 7.24, draw an
instance diagram using three movies that have been released recently. Draw
instances of each entity type: MOVIES, ACTORS, PRODUCERS, DIRECTORS
involved; make up instances of the relationships as they exist in reality for
those movies.

Illustrate the UML Diagram for Exercise 7.16. Your UML design should
observe the following requirements:

a.

b.

Cc.

A student should have the ability to compute his/her GPA and add or
drop majors and minors.

Each department should be to able add or delete courses and hire or ter-
minate faculty.

Each instructor should be able to assign or change a student’s grade for a
course.

Note: Some of these functions may be spread over multiple classes.

Laboratory Exercises

7.31. Consider the UNIVERSITY database described in Exercise 7.16. Build the ER
schema for this database using a data modeling tool such as ERwin or
Rational Rose.

7.32.

Consider a MAIL_ORDER database in which employees take orders for parts
from customers. The data requirements are summarized as follows:

The mail order company has employees, each identified by a unique
employee number, first and last name, and Zip Code.

Each customer of the company is identified by a unique customer num-
ber, first and last name, and Zip Code.

241

=== Page 271 ===
242

Chapter 7 Data Modeling Using the Entity-Relationship (ER) Model

7.33.

7.34.

= Each part sold by the company is identified by a unique part number, a
part name, price, and quantity in stock.

m Each order placed by a customer is taken by an employee and is given a
unique order number. Each order contains specified quantities of one or
more parts. Each order has a date of receipt as well as an expected ship
date. The actual ship date is also recorded.

Design an Entity-Relationship diagram for the mail order database and
build the design using a data modeling tool such as ERwin or Rational Rose.

Consider a MOVIE database in which data is recorded about the movie indus-
try. The data requirements are summarized as follows:

= Each movie is identified by title and year of release. Each movie has a
length in minutes. Each has a production company, and each is classified
under one or more genres (such as horror, action, drama, and so forth).
Each movie has one or more directors and one or more actors appear in
it. Each movie also has a plot outline. Finally, each movie has zero or more
quotable quotes, each of which is spoken by a particular actor appearing
in the movie.

= Actors are identified by name and date of birth and appear in one or more
movies. Each actor has a role in the movie.

= Directors are also identified by name and date of birth and direct one or
more movies. It is possible for a director to act in a movie (including one
that he or she may also direct).

= Production companies are identified by name and each has an address. A
production company produces one or more movies.

Design an Entity-Relationship diagram for the movie database and enter the
design using a data modeling tool such as ERwin or Rational Rose.

Consider a CONFERENCE_REVIEW database in which researchers submit

their research papers for consideration. Reviews by reviewers are recorded

for use in the paper selection process. The database system caters primarily

to reviewers who record answers to evaluation questions for each paper they

review and make recommendations regarding whether to accept or reject the

paper. The data requirements are summarized as follows:

m Authors of papers are uniquely identified by e-mail id. First and last
names are also recorded.

= Each paper is assigned a unique identifier by the system and is described
by a title, abstract, and the name of the electronic file containing the
paper.

m A paper may have multiple authors, but one of the authors is designated
as the contact author.

m Reviewers of papers are uniquely identified by e-mail address. Each
reviewer's first name, last name, phone number, affiliation, and topics of
interest are also recorded.

=== Page 272 ===
Selected Bibliography

= Each paper is assigned between two and four reviewers. A reviewer rates
each paper assigned to him or her on a scale of 1 to 10 in four categories:
technical merit, readability, originality, and relevance to the conference.
Finally, each reviewer provides an overall recommendation regarding
each paper.

= Each review contains two types of written comments: one to be seen by
the review committee only and the other as feedback to the author(s).

Design an Entity-Relationship diagram for the CONFERENCE_REVIEW
database and build the design using a data modeling tool such as ERwin or
Rational Rose.

7.35. Consider the ER diagram for the AIRLINE database shown in Figure 7.20.
Build this design using a data modeling tool such as ERwin or Rational Rose.

Selected Bibliography

The Entity-Relationship model was introduced by Chen (1976), and related work
appears in Schmidt and Swenson (1975), Wiederhold and Elmasri (1979), and
Senko (1975). Since then, numerous modifications to the ER model have been sug-
gested. We have incorporated some of these in our presentation. Structural con-
straints on relationships are discussed in Abrial (1974), Elmasri and Wiederhold
(1980), and Lenzerini and Santucci (1983). Multivalued and composite attributes
are incorporated in the ER model in Elmasri et al. (1985). Although we did not dis-
cuss languages for the ER model and its extensions, there have been several propos-
als for such languages. Elmasri and Wiederhold (1981) proposed the GORDAS
query language for the ER model. Another ER query language was proposed by
Markowitz and Raz (1983). Senko (1980) presented a query language for Senko’s
DIAM model. A formal set of operations called the ER algebra was presented by
Parent and Spaccapietra (1985). Gogolla and Hohenstein (1991) presented another
formal language for the ER model. Campbell et al. (1985) presented a set of ER
operations and showed that they are relationally complete. A conference for the dis-
semination of research results related to the ER model has been held regularly since
1979. The conference, now known as the International Conference on Conceptual
Modeling, has been held in Los Angeles (ER 1979, ER 1983, ER 1997), Washington,
D.C. (ER 1981), Chicago (ER 1985), Dijon, France (ER 1986), New York City (ER
1987), Rome (ER 1988), Toronto (ER 1989), Lausanne, Switzerland (ER 1990), San
Mateo, California (ER 1991), Karlsruhe, Germany (ER 1992), Arlington, Texas (ER
1993), Manchester, England (ER 1994), Brisbane, Australia (ER 1995), Cottbus,
Germany (ER 1996), Singapore (ER 1998), Paris, France (ER 1999), Salt Lake City,
Utah (ER 2000), Yokohama, Japan (ER 2001), Tampere, Finland (ER 2002),
Chicago, Illinois (ER 2003), Shanghai, China (ER 2004), Klagenfurt, Austria (ER
2005), Tucson, Arizona (ER 2006), Auckland, New Zealand (ER 2007), Barcelona,
Catalonia, Spain (ER 2008), and Gramado, RS, Brazil (ER 2009). The 2010 confer-
ence is to be held in Vancouver, BC, Canada.

243

=== Page 273 ===
This page intentionally left blank


=== Page 772 ===
chapter —4

Introduction to Transaction
Processing Concepts
and Theory

‘Ti concept of transaction provides a mechanism
for describing logical units of database processing.
Transaction processing systems are systems with large databases and hundreds of
concurrent users executing database transactions. Examples of such systems include
airline reservations, banking, credit card processing, online retail purchasing, stock
markets, supermarket checkouts, and many other applications. These systems
require high availability and fast response time for hundreds of concurrent users. In
this chapter we present the concepts that are needed in transaction processing sys-
tems. We define the concept of a transaction, which is used to represent a logical
unit of database processing that must be completed in its entirety to ensure correct-
ness. A transaction is typically implemented by a computer program, which
includes database commands such as retrievals, insertions, deletions, and updates.
We introduced some of the basic techniques for database programming in Chapters
13 and 14.

In this chapter, we focus on the basic concepts and theory that are needed to ensure
the correct executions of transactions. We discuss the concurrency control problem,
which occurs when multiple transactions submitted by various users interfere with
one another in a way that produces incorrect results. We also discuss the problems
that can occur when transactions fail, and how the database system can recover
from various types of failures.

This chapter is organized as follows. Section 21.1 informally discusses why concur-
rency control and recovery are necessary in a database system. Section 21.2 defines
the term transaction and discusses additional concepts related to transaction pro-
cessing in database systems. Section 21.3 presents the important properties of atom-
icity, consistency preservation, isolation, and durability or permanency—called the

743

=== Page 773 ===
744

Chapter 21 Introduction to Transaction Processing Concepts and Theory

ACID properties—that are considered desirable in transaction processing systems.
Section 21.4 introduces the concept of schedules (or histories) of executing transac-
tions and characterizes the recoverability of schedules. Section 21.5 discusses the
notion of serializability of concurrent transaction execution, which can be used to
define correct execution sequences (or schedules) of concurrent transactions. In
Section 21.6, we present some of the commands that support the transaction con-
cept in SQL. Section 21.7 summarizes the chapter.

The two following chapters continue with more details on the actual methods and
techniques used to support transaction processing. Chapter 22 gives an overview
of the basic concurrency control protocols and Chapter 23 introduces recovery
techniques.

21.1 Introduction to Transaction Processing

In this section we discuss the concepts of concurrent execution of transactions and
recovery from transaction failures. Section 21.1.1 compares single-user and multi-
user database systems and demonstrates how concurrent execution of transactions
can take place in multiuser systems. Section 21.1.2 defines the concept of transac-
tion and presents a simple model of transaction execution based on read and write
database operations. This model is used as the basis for defining and formalizing
concurrency control and recovery concepts. Section 21.1.3 uses informal examples
to show why concurrency control techniques are needed in multiuser systems.
Finally, Section 21.1.4 discusses why techniques are needed to handle recovery from
system and transaction failures by discussing the different ways in which transac-
tions can fail while executing.

21.1.1 Single-User versus Multiuser Systems

One criterion for classifying a database system is according to the number of users
who can use the system concurrently. A DBMS is single-user if at most one user at
a time can use the system, and it is multiuser if many users can use the system—and
hence access the database—concurrently. Single-user DBMSs are mostly restricted
to personal computer systems; most other DBMSs are multiuser. For example, an
airline reservations system is used by hundreds of travel agents and reservation
clerks concurrently. Database systems used in banks, insurance agencies, stock
exchanges, supermarkets, and many other applications are multiuser systems. In
these systems, hundreds or thousands of users are typically operating on the data-
base by submitting transactions concurrently to the system.

Multiple users can access databases—and use computer systems—simultaneously
because of the concept of multiprogramming, which allows the operating system
of the computer to execute multiple programs—or processes—at the same time. A
single central processing unit (CPU) can only execute at most one process at a time.
However, multiprogramming operating systems execute some commands from
one process, then suspend that process and execute some commands from the next

=== Page 774 ===
21.1 Introduction to Transaction Processing 745

 

 

 

 

 

 

 

A A
| |
oe 8 | :
| | | | Cc : CPU,
[oo
D 1 CPU,
{>
f f f {oo
Time
ty ty ts ty

Figure 21.1
Interleaved process-
ing versus parallel
processing of con-
current transactions.

 

process, and so on. A process is resumed at the point where it was suspended when-
ever it gets its turn to use the CPU again. Hence, concurrent execution of processes
is actually interleaved, as illustrated in Figure 21.1, which shows two processes, A
and B, executing concurrently in an interleaved fashion. Interleaving keeps the CPU
busy when a process requires an input or output (I/O) operation, such as reading a
block from disk. The CPU is switched to execute another process rather than
remaining idle during I/O time. Interleaving also prevents a long process from
delaying other processes.

If the computer system has multiple hardware processors (CPUs), parallel process-
ing of multiple processes is possible, as illustrated by processes C and D in Figure
21.1. Most of the theory concerning concurrency control in databases is developed in
terms of interleaved concurrency, so for the remainder of this chapter we assume
this model. In a multiuser DBMS, the stored data items are the primary resources
that may be accessed concurrently by interactive users or application programs,
which are constantly retrieving information from and modifying the database.

21.1.2 Transactions, Database Items, Read
and Write Operations, and DBMS Buffers

A transaction is an executing program that forms a logical unit of database process-
ing. A transaction includes one or more database access operations—these can
include insertion, deletion, modification, or retrieval operations. The database
operations that form a transaction can either be embedded within an application
program or they can be specified interactively via a high-level query language such
as SQL. One way of specifying the transaction boundaries is by specifying explicit
begin transaction and end transaction statements in an application program; in
this case, all database access operations between the two are considered as forming
one transaction. A single application program may contain more than one transac-
tion if it contains several transaction boundaries. If the database operations in a
transaction do not update the database but only retrieve data, the transaction is
called a read-only transaction; otherwise it is known as a read-write transaction.

=== Page 775 ===
746

Chapter 21 Introduction to Transaction Processing Concepts and Theory

The database model that is used to present transaction processing concepts is quite
simple when compared to the data models that we discussed earlier in the book,
such as the relational model or the object model. A database is basically represented
as a collection of named data items. The size of a data item is called its granularity.
A data item can be a database record, but it can also be a larger unit such as a whole
disk block, or even a smaller unit such as an individual field (attribute) value of some
record in the database. The transaction processing concepts we discuss are inde-
pendent of the data item granularity (size) and apply to data items in general. Each
data item has a unique name, but this name is not typically used by the programmer;
rather, it is just a means to uniquely identify each data item. For example, if the data
item granularity is one disk block, then the disk block address can be used as the
data item name. Using this simplified database model, the basic database access
operations that a transaction can include are as follows:

m read_item(X). Reads a database item named X into a program variable. To
simplify our notation, we assume that the program variable is also named X.

= write_item(X). Writes the value of program variable X into the database
item named X.

As we discussed in Chapter 17, the basic unit of data transfer from disk to main
memory is one block. Executing a read_item(X) command includes the following
steps:

1. Find the address of the disk block that contains item X.

2. Copy that disk block into a buffer in main memory (if that disk block is not
already in some main memory buffer).

3. Copy item X from the buffer to the program variable named X.
Executing a write_item(X) command includes the following steps:

. Find the address of the disk block that contains item X.

. Copy that disk block into a buffer in main memory (if that disk block is not
already in some main memory buffer).

Ny =

o

. Copy item X from the program variable named X into its correct location in
the buffer.

. Store the updated block from the buffer back to disk (either immediately or
at some later point in time).

ASS

It is step 4 that actually updates the database on disk. In some cases the buffer is not
immediately stored to disk, in case additional changes are to be made to the buffer.
Usually, the decision about when to store a modified disk block whose contents are
in a main memory buffer is handled by the recovery manager of the DBMS in coop-
eration with the underlying operating system. The DBMS will maintain in the
database cache a number of data buffers in main memory. Each buffer typically
holds the contents of one database disk block, which contains some of the database
items being processed. When these buffers are all occupied, and additional database
disk blocks must be copied into memory, some buffer replacement policy is used to

=== Page 776 ===
21.1 Introduction to Transaction Processing 747

choose which of the current buffers is to be replaced. If the chosen buffer has been
modified, it must be written back to disk before it is reused.!

A transaction includes read_item and write_item operations to access and update the
database. Figure 21.2 shows examples of two very simple transactions. The read-set
of a transaction is the set of all items that the transaction reads, and the write-set is
the set of all items that the transaction writes. For example, the read-set of T, in
Figure 21.2 is {X, Y} and its write-set is also {X, Y}.

Concurrency control and recovery mechanisms are mainly concerned with the
database commands in a transaction. Transactions submitted by the various users
may execute concurrently and may access and update the same database items. If
this concurrent execution is uncontrolled, it may lead to problems, such as an incon-
sistent database. In the next section we informally introduce some of the problems
that may occur.

21.1.3 Why Concurrency Control Is Needed

Several problems can occur when concurrent transactions execute in an uncon-
trolled manner. We illustrate some of these problems by referring to a much simpli-
fied airline reservations database in which a record is stored for each airline flight.
Each record includes the number of reserved seats on that flight as a named (uniquely
identifiable) data item, among other information. Figure 21.2(a) shows a transac-
tion T, that transfers N reservations from one flight whose number of reserved seats
is stored in the database item named X to another flight whose number of reserved
seats is stored in the database item named Y. Figure 21.2(b) shows a simpler trans-
action T’, that just reserves M seats on the first flight (X) referenced in transaction
T,.” To simplify our example, we do not show additional portions of the transac-
tions, such as checking whether a flight has enough seats available before reserving
additional seats.

 

 

 

(a) T, (b) T, Figure 21.2
Two sample transac-
read_item(X); read_item(X); tions. (a) Transaction
X:=X-N; X:=X+M;

write_item(X); write_item(X);
read_item(Y);
Y=VY+N;

write_item(Y);

 

 

 

 

 

 

'We will not discuss buffer replacement policies here because they are typically discussed in operating
systems textbooks.

2A similar, more commonly used example assumes a bank database, with one transaction doing a trans-
fer of funds from account X to account Y and the other transaction doing a deposit to account X.

T,. (b) Transaction To.

=== Page 777 ===
748

Chapter 21 Introduction to Transaction Processing Concepts and Theory

When a database access program is written, it has the flight number, flight date, and
the number of seats to be booked as parameters; hence, the same program can be
used to execute many different transactions, each with a different flight number,
date, and number of seats to be booked. For concurrency control purposes, a trans-
action is a particular execution of a program on a specific date, flight, and number of
seats. In Figure 21.2(a) and (b), the transactions T, and T, are specific executions of
the programs that refer to the specific flights whose numbers of seats are stored in
data items X and Y in the database. Next we discuss the types of problems we may
encounter with these two simple transactions if they run concurrently.

The Lost Update Problem. This problem occurs when two transactions that
access the same database items have their operations interleaved in a way that makes
the value of some database items incorrect. Suppose that transactions T, and T, are
submitted at approximately the same time, and suppose that their operations are
interleaved as shown in Figure 21.3(a); then the final value of item X is incorrect
because T,, reads the value of X before T, changes it in the database, and hence the
updated value resulting from T, is lost. For example, if X = 80 at the start (originally
there were 80 reservations on the flight), N = 5 (T, transfers 5 seat reservations from
the flight corresponding to X to the flight corresponding to Y), and M = 4 (T,
reserves 4 seats on X), the final result should be X = 79. However, in the interleaving
of operations shown in Figure 21.3(a), it is X = 84 because the update in T, that
removed the five seats from X was lost.

The Temporary Update (or Dirty Read) Problem. This problem occurs when
one transaction updates a database item and then the transaction fails for some rea-
son (see Section 21.1.4). Meanwhile, the updated item is accessed (read) by another
transaction before it is changed back to its original value. Figure 21.3(b) shows an
example where T, updates item X and then fails before completion, so the system
must change X back to its original value. Before it can do so, however, transaction T,
reads the temporary value of X, which will not be recorded permanently in the data-
base because of the failure of T,. The value of item X that is read by T, is called dirty
data because it has been created by a transaction that has not completed and com-
mitted yet; hence, this problem is also known as the dirty read problem.

The Incorrect Summary Problem. If one transaction is calculating an aggregate
summary function on a number of database items while other transactions are
updating some of these items, the aggregate function may calculate some values
before they are updated and others after they are updated. For example, suppose
that a transaction T; is calculating the total number of reservations on all the flights;
meanwhile, transaction T, is executing. If the interleaving of operations shown in
Figure 21.3(c) occurs, the result of T; will be off by an amount N because T; reads
the value of X after N seats have been subtracted from it but reads the value of Y
before those N seats have been added to it.

=== Page 778 ===
21.1 Introduction to Transaction Processing 749

 

(a)

(b)

(c)

Time

Time

 

T,

 

read_item(X);
X:=X-N;

write_item(X);
read_item(Y);

Y=Y+N;
write_item(Y);

read_item(X);
X:=X+M,;

write_item(X);

 

 

T,
read_item(X);

X:=X-N;
write_item(X);

read_item(Y);

read_item(X);
X:=X+M;
write_item(X);

 

 

Ts;

 

 

read_item(X);
X:=X-N;
write_item(X);

read_item(Y);
Y=Y+N;
write_item(Y);

 

sum = 0;
read_item(A);
sum :=sum+A;

read_item(X);
sum = sum + X;
read_item(Y);
sum ‘= sum + Y;

 

 

Figure 21.3

Some problems that occur when concurrent
execution is uncontrolled. (a) The lost update
problem. (b) The temporary update problem.
(c) The incorrect summary problem.

Item X has an incorrect value because
its update by T, is /ost (overwritten).

Transaction T, fails and must change
the value of X back to its old value;
meanwhile 7, has read the temporary
incorrect value of X.

T, reads X after N is subtracted and reads
~t— Y before N is added; a wrong summary
is the result (off by NV).

=== Page 779 ===
750 Chapter 21 Introduction to Transaction Processing Concepts and Theory

The Unrepeatable Read Problem. Another problem that may occur is called
unrepeatable read, where a transaction T reads the same item twice and the item is
changed by another transaction T’ between the two reads. Hence, T receives
different values for its two reads of the same item. This may occur, for example, if
during an airline reservation transaction, a customer inquires about seat availability
on several flights. When the customer decides on a particular flight, the transaction
then reads the number of seats on that flight a second time before completing the
reservation, and it may end up reading a different value for the item.

21.1.4 Why Recovery Is Needed

Whenever a transaction is submitted to a DBMS for execution, the system is respon-
sible for making sure that either all the operations in the transaction are completed
successfully and their effect is recorded permanently in the database, or that the
transaction does not have any effect on the database or any other transactions. In
the first case, the transaction is said to be committed, whereas in the second case,
the transaction is aborted. The DBMS must not permit some operations of a trans-
action T to be applied to the database while other operations of T are not, because
the whole transaction is a logical unit of database processing. If a transaction fails
after executing some of its operations but before executing all of them, the opera-
tions already executed must be undone and have no lasting effect.

Types of Failures. Failures are generally classified as transaction, system, and
media failures. There are several possible reasons for a transaction to fail in the mid-
dle of execution:

1. A computer failure (system crash). A hardware, software, or network error
occurs in the computer system during transaction execution. Hardware
crashes are usually media failures—for example, main memory failure.

2. A transaction or system error. Some operation in the transaction may cause
it to fail, such as integer overflow or division by zero. Transaction failure may
also occur because of erroneous parameter values or because of a logical
programming error.° Additionally, the user may interrupt the transaction
during its execution.

3. Local errors or exception conditions detected by the transaction. During
transaction execution, certain conditions may occur that necessitate cancel-
lation of the transaction. For example, data for the transaction may not be
found. An exception condition,’ such as insufficient account balance in a
banking database, may cause a transaction, such as a fund withdrawal, to be
canceled. This exception could be programmed in the transaction itself, and
in such a case would not be considered as a transaction failure.

 

3In general, a transaction should be thoroughly tested to ensure that it does not have any bugs (logical
programming errors).

“Exception conditions, if programmed correctly, do not constitute transaction failures.

=== Page 780 ===
21.2 Transaction and System Concepts

4. Concurrency control enforcement. The concurrency control method (see
Chapter 22) may decide to abort a transaction because it violates serializabil-
ity (see Section 21.5), or it may abort one or more transactions to resolve a
state of deadlock among several transactions (see Section 22.1.3).
Transactions aborted because of serializability violations or deadlocks are
typically restarted automatically at a later time.

5. Disk failure. Some disk blocks may lose their data because of a read or write
malfunction or because of a disk read/write head crash. This may happen
during a read or a write operation of the transaction.

6. Physical problems and catastrophes. This refers to an endless list of prob-
lems that includes power or air-conditioning failure, fire, theft, sabotage,
overwriting disks or tapes by mistake, and mounting of a wrong tape by the
operator.

Failures of types 1, 2, 3, and 4 are more common than those of types 5 or 6.
Whenever a failure of type 1 through 4 occurs, the system must keep sufficient
information to quickly recover from the failure. Disk failure or other catastrophic
failures of type 5 or 6 do not happen frequently; if they do occur, recovery is a major
task. We discuss recovery from failure in Chapter 23.

The concept of transaction is fundamental to many techniques for concurrency
control and recovery from failures.

21.2 Transaction and System Concepts

In this section we discuss additional concepts relevant to transaction processing.
Section 21.2.1 describes the various states a transaction can be in, and discusses
other operations needed in transaction processing. Section 21.2.2 discusses the sys-
tem log, which keeps information about transactions and data items that will be
needed for recovery. Section 21.2.3 describes the concept of commit points of trans-
actions, and why they are important in transaction processing.

21.2.1 Transaction States and Additional Operations

A transaction is an atomic unit of work that should either be completed in its
entirety or not done at all. For recovery purposes, the system needs to keep track of
when each transaction starts, terminates, and commits or aborts (see Section
21.2.3). Therefore, the recovery manager of the DBMS needs to keep track of the
following operations:

= BEGIN_TRANSACTION. This marks the beginning of transaction execution.
= READ or WRITE. These specify read or write operations on the database
items that are executed as part of a transaction.

=m END_TRANSACTION. This specifies that READ and WRITE transaction oper-
ations have ended and marks the end of transaction execution. However, at
this point it may be necessary to check whether the changes introduced by

751

=== Page 781 ===
752 Chapter 21 Introduction to Transaction Processing Concepts and Theory

the transaction can be permanently applied to the database (committed) or
whether the transaction has to be aborted because it violates serializability
(see Section 21.5) or for some other reason.

= COMMIT_TRANSACTION. This signals a successful end of the transaction so
that any changes (updates) executed by the transaction can be safely
committed to the database and will not be undone.

m™ ROLLBACK (or ABORT). This signals that the transaction has ended unsuc-
cessfully, so that any changes or effects that the transaction may have applied
to the database must be undone.

Figure 21.4 shows a state transition diagram that illustrates how a transaction moves
through its execution states. A transaction goes into an active state immediately after
it starts execution, where it can execute its READ and WRITE operations. When the
transaction ends, it moves to the partially committed state. At this point, some
recovery protocols need to ensure that a system failure will not result in an inability
to record the changes of the transaction permanently (usually by recording changes
in the system log, discussed in the next section).> Once this check is successful, the
transaction is said to have reached its commit point and enters the committed state.
Commit points are discussed in more detail in Section 21.2.3. When a transaction is
committed, it has concluded its execution successfully and all its changes must be
recorded permanently in the database, even if a system failure occurs.

However, a transaction can go to the failed state if one of the checks fails or if the
transaction is aborted during its active state. The transaction may then have to be
rolled back to undo the effect of its WRITE operations on the database. The
terminated state corresponds to the transaction leaving the system. The transaction
information that is maintained in system tables while the transaction has been run-
ning is removed when the transaction terminates. Failed or aborted transactions
may be restarted later—either automatically or after being resubmitted by the
user—as brand new transactions.

 

Figure 21.4

State transition diagram illustrating the states for

transaction execution.

Read, Write

Begin 1] End

transaction transaction ; , Commit
dt —— C Partially committed _»>———

Abort Abort

Fated) ——> Crinsod>

5Optimistic concurrency control (see Section 22.4) also requires that certain checks are made at this
point to ensure that the transaction did not interfere with other executing transactions.

 

=== Page 782 ===
21.2 Transaction and System Concepts

21.2.2 The System Log

To be able to recover from failures that affect transactions, the system maintains a
log® to keep track of all transaction operations that affect the values of database
items, as well as other transaction information that may be needed to permit recov-
ery from failures. The log is a sequential, append-only file that is kept on disk, so it
is not affected by any type of failure except for disk or catastrophic failure. Typically,
one (or more) main memory buffers hold the last part of the log file, so that log
entries are first added to the main memory buffer. When the log buffer is filled, or
when certain other conditions occur, the log buffer is appended to the end of the log
file on disk. In addition, the log file from disk is periodically backed up to archival
storage (tape) to guard against catastrophic failures. The following are the types of
entries—called log records—that are written to the log file and the corresponding
action for each log record. In these entries, T refers to a unique transaction-id that
is generated automatically by the system for each transaction and that is used to
identify each transaction:

1. [start_transaction, T]. Indicates that transaction T has started execution.

2. [write_item, T, X, old_value, new_value]. Indicates that transaction T has
changed the value of database item X from old_value to new_value.

3. [read_item, T, X]. Indicates that transaction T has read the value of database
item X.

4. [commit, T]. Indicates that transaction T has completed successfully, and
affirms that its effect can be committed (recorded permanently) to the data-
base.

5. [abort, T]. Indicates that transaction T has been aborted.

Protocols for recovery that avoid cascading rollbacks (see Section 21.4.2)—-which
include nearly all practical protocols—do not require that READ operations are writ-
ten to the system log. However, if the log is also used for other purposes—such as
auditing (keeping track of all database operations)—then such entries can be
included. Additionally, some recovery protocols require simpler WRITE entries only
include one of new_value and old_value instead of including both (see Section
21.4.2).

Notice that we are assuming that all permanent changes to the database occur
within transactions, so the notion of recovery from a transaction failure amounts to
either undoing or redoing transaction operations individually from the log. If the
system crashes, we can recover to a consistent database state by examining the log
and using one of the techniques described in Chapter 23. Because the log contains a
record of every WRITE operation that changes the value of some database item, it is
possible to undo the effect of these WRITE operations of a transaction T by tracing
backward through the log and resetting all items changed by a WRITE operation of
T to their old_values. Redo of an operation may also be necessary if a transaction has
its updates recorded in the log but a failure occurs before the system can be sure that

 

The log has sometimes been called the DBMS journal.

753

=== Page 783 ===
754

Chapter 21 Introduction to Transaction Processing Concepts and Theory

all these new_values have been written to the actual database on disk from the main
memory buffers.”

21.2.3 Commit Point of a Transaction

A transaction T reaches its commit point when all its operations that access the
database have been executed successfully and the effect of all the transaction opera-
tions on the database have been recorded in the log. Beyond the commit point, the
transaction is said to be committed, and its effect must be permanently recorded in
the database. The transaction then writes a commit record [commit, T] into the log.
If a system failure occurs, we can search back in the log for all transactions T that
have written a [start_transaction, T] record into the log but have not written their
[commit, T] record yet; these transactions may have to be rolled back to undo their
effect on the database during the recovery process. Transactions that have written
their commit record in the log must also have recorded all their WRITE operations in
the log, so their effect on the database can be redone from the log records.

Notice that the log file must be kept on disk. As discussed in Chapter 17, updating a
disk file involves copying the appropriate block of the file from disk to a buffer in
main memory, updating the buffer in main memory, and copying the buffer to disk.
It is common to keep one or more blocks of the log file in main memory buffers,
called the log buffer, until they are filled with log entries and then to write them
back to disk only once, rather than writing to disk every time a log entry is added.
This saves the overhead of multiple disk writes of the same log file buffer. At the
time of a system crash, only the log entries that have been written back to disk are
considered in the recovery process because the contents of main memory may be
lost. Hence, before a transaction reaches its commit point, any portion of the log
that has not been written to the disk yet must now be written to the disk. This
process is called force-writing the log buffer before committing a transaction.

21.3 Desirable Properties of Transactions

Transactions should possess several properties, often called the ACID properties;
they should be enforced by the concurrency control and recovery methods of the
DBMS. The following are the ACID properties:

= Atomicity. A transaction is an atomic unit of processing; it should either be
performed in its entirety or not performed at all.

= Consistency preservation. A transaction should be consistency preserving,
meaning that if it is completely executed from beginning to end without
interference from other transactions, it should take the database from one
consistent state to another.

= Isolation. A transaction should appear as though it is being executed in iso-
lation from other transactions, even though many transactions are executing

 

7Undo and redo are discussed more fully in Chapter 23.

=== Page 784 ===
21.4 Characterizing Schedules Based on Recoverability

concurrently. That is, the execution of a transaction should not be interfered
with by any other transactions executing concurrently.

= Durability or permanency. The changes applied to the database by a com-
mitted transaction must persist in the database. These changes must not be
lost because of any failure.

The atomicity property requires that we execute a transaction to completion. It is the
responsibility of the transaction recovery subsystem of a DBMS to ensure atomicity.
If a transaction fails to complete for some reason, such as a system crash in the
midst of transaction execution, the recovery technique must undo any effects of the
transaction on the database. On the other hand, write operations of a committed
transaction must be eventually written to disk.

The preservation of consistency is generally considered to be the responsibility of the
programmers who write the database programs or of the DBMS module that
enforces integrity constraints. Recall that a database state is a collection of all the
stored data items (values) in the database at a given point in time. A consistent state
of the database satisfies the constraints specified in the schema as well as any other
constraints on the database that should hold. A database program should be written
in a way that guarantees that, if the database is in a consistent state before executing
the transaction, it will be in a consistent state after the complete execution of the
transaction, assuming that no interference with other transactions occurs.

The isolation property is enforced by the concurrency control subsystem of the
DBMS.3 If every transaction does not make its updates (write operations) visible to
other transactions until it is committed, one form of isolation is enforced that solves
the temporary update problem and eliminates cascading rollbacks (see Chapter 23)
but does not eliminate all other problems. There have been attempts to define the
level of isolation of a transaction. A transaction is said to have level 0 (zero) isola-
tion if it does not overwrite the dirty reads of higher-level transactions. Level 1
(one) isolation has no lost updates, and level 2 isolation has no lost updates and no
dirty reads. Finally, level 3 isolation (also called true isolation) has, in addition to
level 2 properties, repeatable reads.’

And last, the durability property is the responsibility of the recovery subsystem of the
DBMS. We will introduce how recovery protocols enforce durability and atomicity
in the next section and then discuss this in more detail in Chapter 23.

21.4 Characterizing Schedules Based
on Recoverability

When transactions are executing concurrently in an interleaved fashion, then the
order of execution of operations from all the various transactions is known as a
schedule (or history). In this section, first we define the concept of schedules, and

 

8We will discuss concurrency control protocols in Chapter 22.

°The SQL syntax for isolation level discussed later in Section 21.6 is closely related to these levels.

755

=== Page 785 ===
756

Chapter 21 Introduction to Transaction Processing Concepts and Theory

then we characterize the types of schedules that facilitate recovery when failures
occur. In Section 21.5, we characterize schedules in terms of the interference of par-
ticipating transactions, leading to the concepts of serializability and serializable
schedules.

21.4.1 Schedules (Histories) of Transactions

A schedule (or history) S of n transactions T,, T,, ..., T,, is an ordering of the oper-
ations of the transactions. Operations from different transactions can be interleaved
in the schedule S. However, for each transaction T, that participates in the schedule
5, the operations of T, in S must appear in the same order in which they occur in T,,.
The order of operations in S is considered to be a total ordering, meaning that for
any two operations in the schedule, one must occur before the other. It is possible
theoretically to deal with schedules whose operations form partial orders (as we
discuss later), but we will assume for now total ordering of the operations in a
schedule.

For the purpose of recovery and concurrency control, we are mainly interested in
the read_item and write_item operations of the transactions, as well as the commit and
abort operations. A shorthand notation for describing a schedule uses the symbols b,
r, w, e, c, and a for the operations begin_transaction, read_item, write_item, end_transac-
tion, commit, and abort, respectively, and appends as a subscript the transaction id
(transaction number) to each operation in the schedule. In this notation, the data-
base item X that is read or written follows the r and w operations in parentheses. In
some schedules, we will only show the read and write operations, whereas in other
schedules, we will show all the operations. For example, the schedule in Figure
21.3(a), which we shall call S_, can be written as follows in this notation:

Sai F(X)3 14(X)3 w (X)3 7 (Y)s wy(X)s w,(Y)s

Similarly, the schedule for Figure 21.3(b), which we call S,, can be written as follows,
if we assume that transaction T, aborted after its read_item(Y) operation:

Sp 7 (Xs w(X)5 14(X)3 w3(X)3 7 (Y)5 a3

Two operations in a schedule are said to conflict if they satisfy all three of the fol-
lowing conditions: (1) they belong to different transactions; (2) they access the same
item X; and (3) at least one of the operations is a write_item(X). For example, in
schedule S_, the operations r,(X) and w,(X) conflict, as do the operations r,(X) and
w,(X), and the operations w,(X) and w,(X). However, the operations r,(X) and
r,(X) do not conflict, since they are both read operations; the operations w,(X)
and w,(Y) do not conflict because they operate on distinct data items X and Y; and
the operations r,(X) and w,(X) do not conflict because they belong to the same
transaction.

Intuitively, two operations are conflicting if changing their order can result in a dif-
ferent outcome. For example, if we change the order of the two operations r,(X);
w,(X) to w,(X); r,(X), then the value of X that is read by transaction T, changes,
because in the second order the value of X is changed by w,(X) before it is read by

=== Page 786 ===
21.4 Characterizing Schedules Based on Recoverability

r,(X), whereas in the first order the value is read before it is changed. This is called a
read-write conflict. The other type is called a write-write conflict, and is illustrated
by the case where we change the order of two operations such as w,(X); w,(X) to
w,(X); w,(X). For a write-write conflict, the last value of X will differ because in one
case it is written by T, and in the other case by T,. Notice that two read operations
are not conflicting because changing their order makes no difference in outcome.

The rest of this section covers some theoretical definitions concerning schedules. A
schedule S of n transactions T,, T,, ..., T,, is said to be a complete schedule if the
following conditions hold:

1. The operations in S are exactly those operations in T), T,, ..., T,,, including a
commit or abort operation as the last operation for each transaction in the
schedule.

2. For any pair of operations from the same transaction T,, their relative order
of appearance in S is the same as their order of appearance in T..

3. For any two conflicting operations, one of the two must occur before the
other in the schedule.!°

The preceding condition (3) allows for two nonconflicting operations to occur in the
schedule without defining which occurs first, thus leading to the definition of a
schedule as a partial order of the operations in the n transactions.!! However, a
total order must be specified in the schedule for any pair of conflicting operations
(condition 3) and for any pair of operations from the same transaction (condition
2). Condition 1 simply states that all operations in the transactions must appear in
the complete schedule. Since every transaction has either committed or aborted, a
complete schedule will not contain any active transactions at the end of the schedule.

In general, it is difficult to encounter complete schedules in a transaction processing
system because new transactions are continually being submitted to the system.
Hence, it is useful to define the concept of the committed projection C(S) of a
schedule S, which includes only the operations in S that belong to committed trans-
actions—that is, transactions T; whose commit operation ¢; is in S.

21.4.2 Characterizing Schedules Based on Recoverability

For some schedules it is easy to recover from transaction and system failures,
whereas for other schedules the recovery process can be quite involved. In some
cases, it is even not possible to recover correctly after a failure. Hence, it is important
to characterize the types of schedules for which recovery is possible, as well as those
for which recovery is relatively simple. These characterizations do not actually pro-
vide the recovery algorithm; they only attempt to theoretically characterize the dif-
ferent types of schedules.

 

'0Theoretically, it is not necessary to determine an order between pairs of nonconflicting operations.

‘ln practice, most schedules have a total order of operations. If parallel processing is employed, it is
theoretically possible to have schedules with partially ordered nonconflicting operations.

757

=== Page 787 ===
758

Chapter 21 Introduction to Transaction Processing Concepts and Theory

First, we would like to ensure that, once a transaction T is committed, it should
never be necessary to roll back T. This ensures that the durability property of trans-
actions is not violated (see Section 21.3). The schedules that theoretically meet this
criterion are called recoverable schedules; those that do not are called
nonrecoverable and hence should not be permitted by the DBMS. The definition of
recoverable schedule is as follows: A schedule S is recoverable if no transaction T in
S commits until all transactions T’ that have written some item X that T reads have
committed. A transaction T reads from transaction T’ in a schedule S if some item
X is first written by T’ and later read by T. In addition, T’ should not have been
aborted before T reads item X, and there should be no transactions that write X after
T’ writes it and before T reads it (unless those transactions, if any, have aborted
before T reads X).

Some recoverable schedules may require a complex recovery process as we shall see,
but if sufficient information is kept (in the log), a recovery algorithm can be devised
for any recoverable schedule. The (partial) schedules S, and S, from the preceding
section are both recoverable, since they satisfy the above definition. Consider the
schedule S_’ given below, which is the same as schedule S, except that two commit
operations have been added to S_:

Sat 1 (X)5 74(X)3 wy (X)5 17 (Y)s wy(X)3 3 wy (Y)s ¢3

S,' is recoverable, even though it suffers from the lost update problem; this problem
is handled by serializability theory (see Section 21.5). However, consider the two
(partial) schedules S. and S,, that follow:

Se (X)3 w(X)5 1,(X)3 7 (Y)3 wy(X)5 €55 ay3
Sgt (X)3 wy (X)5 17(X)5 17) (Y)5 wy(X)s w, (V5 €13 €55
Soi 1 (X)3 wy (X)5 15(X)5 7) (Y)3 w(X)3 w,(Y)5 4,3 a5

S.is not recoverable because T,, reads item X from T,, but T, commits before T,
commits. The problem occurs if T, aborts after the c, operation in S., then the value
of X that T, read is no longer valid and T, must be aborted after it is committed,
leading to a schedule that is not recoverable. For the schedule to be recoverable, the c,
operation in S. must be postponed until after T, commits, as shown in S,. If T,
aborts instead of committing, then T, should also abort as shown in S,, because the
value of X it read is no longer valid. In S,, aborting T, is acceptable since it has not
committed yet, which is not the case for the nonrecoverable schedule S..

In a recoverable schedule, no committed transaction ever needs to be rolled back,
and so the definition of committed transaction as durable is not violated. However,
it is possible for a phenomenon known as cascading rollback (or cascading abort)
to occur in some recoverable schedules, where an uncommitted transaction has to be
rolled back because it read an item from a transaction that failed. This is illustrated
in schedule S,, where transaction T, has to be rolled back because it read item X
from T,, and T, then aborted.

Because cascading rollback can be quite time-consuming—since numerous transac-
tions can be rolled back (see Chapter 23)—it is important to characterize the sched-

=== Page 788 ===
21.5 Characterizing Schedules Based on Serializability

ules where this phenomenon is guaranteed not to occur. A schedule is said to be
cascadeless, or to avoid cascading rollback, if every transaction in the schedule reads
only items that were written by committed transactions. In this case, all items read
will not be discarded, so no cascading rollback will occur. To satisfy this criterion, the
r,(X) command in schedules S, and S, must be postponed until after T, has commit-
ted (or aborted), thus delaying T, but ensuring no cascading rollback if T, aborts.

Finally, there is a third, more restrictive type of schedule, called a strict schedule, in
which transactions can neither read nor write an item X until the last transaction that
wrote X has committed (or aborted). Strict schedules simplify the recovery process.
In a strict schedule, the process of undoing a write_item(X) operation of an aborted
transaction is simply to restore the before image (old_value or BFIM) of data item X.
This simple procedure always works correctly for strict schedules, but it may not
work for recoverable or cascadeless schedules. For example, consider schedule Sp

Sp: w (X, 5); w,(X, 8); a3

Suppose that the value of X was originally 9, which is the before image stored in the
system log along with the w, (X, 5) operation. If T, aborts, as in Sp the recovery pro-
cedure that restores the before image of an aborted write operation will restore the
value of X to 9, even though it has already been changed to 8 by transaction T,, thus
leading to potentially incorrect results. Although schedule S,is cascadeless, it is not
a strict schedule, since it permits T., to write item X even though the transaction T,
that last wrote X had not yet committed (or aborted). A strict schedule does not
have this problem.

It is important to note that any strict schedule is also cascadeless, and any cascade-
less schedule is also recoverable. Suppose we have i transactions T,, T,, ..., T;, and
their number of operations are 1, 1, ..., N, respectively. If we make a set of all pos-
sible schedules of these transactions, we can divide the schedules into two disjoint
subsets: recoverable and nonrecoverable. The cascadeless schedules will be a subset
of the recoverable schedules, and the strict schedules will be a subset of the cascade-
less schedules. Thus, all strict schedules are cascadeless, and all cascadeless schedules
are recoverable.

21.5 Characterizing Schedules Based
on Serializability

In the previous section, we characterized schedules based on their recoverability
properties. Now we characterize the types of schedules that are always considered to
be correct when concurrent transactions are executing. Such schedules are known as
serializable schedules. Suppose that two users—for example, two airline reservations
agents—submit to the DBMS transactions T, and T, in Figure 21.2 at approxi-
mately the same time. If no interleaving of operations is permitted, there are only
two possible outcomes:

1. Execute all the operations of transaction T, (in sequence) followed by all the
operations of transaction T, (in sequence).

759

=== Page 789 ===
760

Chapter 21 Introduction to Transaction Processing Concepts and Theory

2. Execute all the operations of transaction T, (in sequence) followed by all the
operations of transaction T, (in sequence).

These two schedules—called serial schedules—are shown in Figure 21.5(a) and (b),
respectively. If interleaving of operations is allowed, there will be many possible
orders in which the system can execute the individual operations of the transac-
tions. Two possible schedules are shown in Figure 21.5(c). The concept of
serializability of schedules is used to identify which schedules are correct when
transaction executions have interleaving of their operations in the schedules. This

section defines serializability and discusses how it may be used in practice.

 

Figure 21.5

Examples of serial and nonserial schedules involving transactions T, and To. (a)
Serial schedule A: T, followed by 7p. (b) Serial schedule B: T, followed by 7).
(c) Two nonserial schedules C and D with interleaving of operations.

(a)

(c)

Time

Time

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Tt, Ty (b) T, T,
read_item(X); read_item(X);
X=X-N; X=X+M;
write_item(X); write_item(X);
read_item(Y); Tj read_item(X);

ime
Y=Y+N; X=X-N;
write_item(Y); write_item(X);
read_item(X); read_item(Y);
X:=X+M; Y=Y+N;
write_item(X); write_item(Y);
Schedule A Schedule B
T, Ty T, T,
read_item(X); read_item(X);
=X-N: X =X-N;
MEAN read_item(X); write item(X):
X=X+M; ~ ,
write_item(X); Time read_item(X);

read_item(Y);

Y=Y+N;
write_item(Y);

 

write_item(X);

 

 

Schedule C

 

read_item(Y);
Y=Y+N;
write_item(Y);

 

X:=X+M;
write_item(X);

 

Schedule D

 

 

=== Page 790 ===
21.5 Characterizing Schedules Based on Serializability

21.5.1 Serial, Nonserial, and Conflict-Serializable Schedules

Schedules A and B in Figure 21.5(a) and (b) are called serial because the operations
of each transaction are executed consecutively, without any interleaved operations
from the other transaction. In a serial schedule, entire transactions are performed in
serial order: T, and then T, in Figure 21.5(a), and T, and then T, in Figure 21.5(b).
Schedules C and D in Figure 21.5(c) are called nonserial because each sequence
interleaves operations from the two transactions.

Formally, a schedule S is serial if, for every transaction T participating in the sched-
ule, all the operations of T are executed consecutively in the schedule; otherwise, the
schedule is called nonserial. Therefore, in a serial schedule, only one transaction at
a time is active—the commit (or abort) of the active transaction initiates execution
of the next transaction. No interleaving occurs in a serial schedule. One reasonable
assumption we can make, if we consider the transactions to be independent, is that
every serial schedule is considered correct. We can assume this because every transac-
tion is assumed to be correct if executed on its own (according to the consistency
preservation property of Section 21.3). Hence, it does not matter which transaction
is executed first. As long as every transaction is executed from beginning to end in
isolation from the operations of other transactions, we get a correct end result on
the database.

The problem with serial schedules is that they limit concurrency by prohibiting
interleaving of operations. In a serial schedule, if a transaction waits for an I/O
operation to complete, we cannot switch the CPU processor to another transaction,
thus wasting valuable CPU processing time. Additionally, if some transaction T is
quite long, the other transactions must wait for T to complete all its operations
before starting. Hence, serial schedules are considered unacceptable in practice.
However, if we can determine which other schedules are equivalent to a serial sched-
ule, we can allow these schedules to occur.

To illustrate our discussion, consider the schedules in Figure 21.5, and assume that
the initial values of database items are X = 90 and Y= 90 and that N = 3 and M =2.
After executing transactions T, and T,, we would expect the database values to be X
= 89 and Y = 93, according to the meaning of the transactions. Sure enough, execut-
ing either of the serial schedules A or B gives the correct results. Now consider the
nonserial schedules C and D. Schedule C (which is the same as Figure 21.3(a)) gives
the results X = 92 and Y = 93, in which the X value is erroneous, whereas schedule D
gives the correct results.

Schedule C gives an erroneous result because of the lost update problem discussed in
Section 21.1.3; transaction T, reads the value of X before it is changed by transac-
tion T,, so only the effect of T, on X is reflected in the database. The effect of T, on
X is lost, overwritten by T,, leading to the incorrect result for item X. However, some
nonserial schedules give the correct expected result, such as schedule D. We would
like to determine which of the nonserial schedules always give a correct result and
which may give erroneous results. The concept used to characterize schedules in this

manner is that of serializability of a schedule.

761

=== Page 791 ===
762

Chapter 21 Introduction to Transaction Processing Concepts and Theory

The definition of serializable schedule is as follows: A schedule S of n transactions is
serializable if it is equivalent to some serial schedule of the same n transactions. We
will define the concept of equivalence of schedules shortly. Notice that there are n!
possible serial schedules of n transactions and many more possible nonserial sched-
ules. We can form two disjoint groups of the nonserial schedules—those that are
equivalent to one (or more) of the serial schedules and hence are serializable, and
those that are not equivalent to any serial schedule and hence are not serializable.

Saying that a nonserial schedule S is serializable is equivalent to saying that it is cor-
rect, because it is equivalent to a serial schedule, which is considered correct. The
remaining question is: When are two schedules considered equivalent?

There are several ways to define schedule equivalence. The simplest but least satis-
factory definition involves comparing the effects of the schedules on the database.
Two schedules are called result equivalent if they produce the same final state of the
database. However, two different schedules may accidentally produce the same final
state. For example, in Figure 21.6, schedules S, and S, will produce the same final
database state if they execute on a database with an initial value of X = 100; however,
for other initial values of X, the schedules are not result equivalent. Additionally,
these schedules execute different transactions, so they definitely should not be con-
sidered equivalent. Hence, result equivalence alone cannot be used to define equiv-
alence of schedules. The safest and most general approach to defining schedule
equivalence is not to make any assumptions about the types of operations included
in the transactions. For two schedules to be equivalent, the operations applied to
each data item affected by the schedules should be applied to that item in both
schedules in the same order. Two definitions of equivalence of schedules are gener-
ally used: conflict equivalence and view equivalence. We discuss conflict equivalence
next, which is the more commonly used definition.

The definition of conflict equivalence of schedules is as follows: Two schedules are
said to be conflict equivalent if the order of any two conflicting operations is the
same in both schedules. Recall from Section 21.4.1 that two operations in a schedule
are said to conflict if they belong to different transactions, access the same database
item, and either both are write_item operations or one is a write_item and the other a
read_item. If two conflicting operations are applied in different orders in two sched-
ules, the effect can be different on the database or on the transactions in the sched-
ule, and hence the schedules are not conflict equivalent. For example, as we
discussed in Section 21.4.1, if a read and write operation occur in the order r,(X),
w,(X) in schedule S,, and in the reverse order w,(X), r,(X) in schedule S,, the value
read by r,(X) can be different in the two schedules. Similarly, if two write operations

 

Figure 21.6
Two schedules that are result
equivalent for the initial value read_item(X); read_item(X);

of X= 100 but are not result X =X+10; X=X* 1.1;
equivalent in general.

 

S, S>

 

 

write_item(X); write_item (X);

 

 

 

 

 

 

=== Page 792 ===
21.5 Characterizing Schedules Based on Serializability

occur in the order w,(X), w,(X) in S,, and in the reverse order w,(X), w,(X) in S,,
the next r(X) operation in the two schedules will read potentially different values; or
if these are the last operations writing item X in the schedules, the final value of item
X in the database will be different.

Using the notion of conflict equivalence, we define a schedule S to be conflict seri-
alizable!’ if it is (conflict) equivalent to some serial schedule S’. In such a case, we
can reorder the nonconflicting operations in S until we form the equivalent serial
schedule S’. According to this definition, schedule D in Figure 21.5(c) is equivalent
to the serial schedule A in Figure 21.5(a). In both schedules, the read_item(X) of T,,
reads the value of X written by T,, while the other read_item operations read the
database values from the initial database state. Additionally, T, is the last transaction
to write Y, and T, is the last transaction to write X in both schedules. Because A is a
serial schedule and schedule D is equivalent to A, D is a serializable schedule. Notice
that the operations r,(Y) and w,(Y) of schedule D do not conflict with the opera-
tions r,(X) and w,(X), since they access different data items. Therefore, we can move
r,(Y), w,(Y) before r,(X), w,(X), leading to the equivalent serial schedule T,, T,.

Schedule C in Figure 21.5(c) is not equivalent to either of the two possible serial
schedules A and B, and hence is not serializable. Trying to reorder the operations of
schedule C to find an equivalent serial schedule fails because r,(X) and w,(X) con-
flict, which means that we cannot move r,(X) down to get the equivalent serial
schedule T,, T,. Similarly, because w,(X) and w,(X) conflict, we cannot move w, (X)
down to get the equivalent serial schedule T,, T,.

Another, more complex definition of equivalence—called view equivalence, which
leads to the concept of view serializability—is discussed in Section 21.5.4.

21.5.2 Testing for Conflict Serializability of a Schedule

There is a simple algorithm for determining whether a particular schedule is con-
flict serializable or not. Most concurrency control methods do not actually test for
serializability. Rather protocols, or rules, are developed that guarantee that any
schedule that follows these rules will be serializable. We discuss the algorithm for
testing conflict serializability of schedules here to gain a better understanding of
these concurrency control protocols, which are discussed in Chapter 22.

Algorithm 21.1 can be used to test a schedule for conflict serializability. The algo-
rithm looks at only the read_item and write_item operations in a schedule to construct
a precedence graph (or serialization graph), which is a directed graph G = (N, E)
that consists of a set of nodes N= {T,, T,,..., T,, } anda set of directed edges E = {e,,
C5, «++» €,, }» There is one node in the graph for each transaction T; in the schedule.
Each edge e; in the graph is of the form (T;— T, ), 1 Sj<n,1<k<n, where Tis the
starting node of e, and T, is the ending node of e,. Such an edge from node T; to

 

'2We will use serializable to mean conflict serializable. Another definition of serializable used in practice
(see Section 21.6) is to have repeatable reads, no dirty reads, and no phantom records (see Section
22.7.1 for a discussion on phantoms).

763

=== Page 793 ===
764 Chapter 21 Introduction to Transaction Processing Concepts and Theory

node T, is created by the algorithm if one of the operations in T; appears in the
schedule before some conflicting operation in T,.

Algorithm 21.1. Testing Conflict Serializability of a Schedule S

1. For each transaction T, participating in schedule S, create a node labeled T,
in the precedence graph.

Nb

. For each case in S where T, executes a read_item(X) after T; executes a
write_item(X), create an edge (T; > T)) in the precedence graph.

o

. For each case in S where T. executes a write_item(X) after T; executes a
read_item(X), create an edge (T; > T;) in the precedence graph.

ASS

. For each case in S where T; executes a write_item(X) after T; executes a
write_item(X), create an edge (T; > T)) in the precedence graph.

ol

. The schedule S is serializable if and only if the precedence graph has no
cycles.

The precedence graph is constructed as described in Algorithm 21.1. If there is a
cycle in the precedence graph, schedule S is not (conflict) serializable; if there is no
cycle, S is serializable. A cycle in a directed graph is a sequence of edges C = (7; >
T,) (T, 2 T. p> »(T,> T;)) with the property that the starting node of each
edge—except ‘the first edge—is the same as the ending node of the previous edge,
and the starting node of the first edge is the same as the ending node of the last edge
(the sequence starts and ends at the same node).

In the precedence graph, an edge from T; to T; means that transaction T; must come
before transaction T, in any serial schedule that is equivalent to S, because two con-
flicting operations appear in the schedule in that order. If there is no cycle in the
precedence graph, we can create an equivalent serial schedule S’ that is equivalent
to S, by ordering the transactions that participate in S as follows: Whenever an edge
exists in the precedence graph from T; to T., T, must appear before T. in the equiva-
lent serial schedule S'.'3 Notice that the edges (T; > T.) in a precedence graph can
optionally be labeled by the name(s) of the data item(s) that led to creating the
edge. Figure 21.7 shows such labels on the edges.

In general, several serial schedules can be equivalent to S if the precedence graph for
S has no cycle. However, if the precedence graph has a cycle, it is easy to show that
we cannot create any equivalent serial schedule, so S is not serializable. The prece-
dence graphs created for schedules A to D, respectively, in Figure 21.5 appear in
Figure 21.7(a) to (d). The graph for schedule C has a cycle, so it is not serializable.
The graph for schedule D has no cycle, so it is serializable, and the equivalent serial
schedule is T, followed by T,. The graphs for schedules A and B have no cycles, as
expected, because the schedules are serial and hence serializable.

Another example, in which three transactions participate, is shown in Figure 21.8.
Figure 21.8(a) shows the read_item and write_item operations in each transaction.
Two schedules E and F for these transactions are shown in Figure 21.8(b) and (c),

 

'3This process of ordering the nodes of an acrylic graph is known as topological sorting.

=== Page 794 ===
21.5 Characterizing Schedules Based on Serializability

Xx
°QO @® °&
x
x
(c) (d) (7)
x Xx
Figure 21.7

Constructing the precedence graphs for schedules A to D from Figure 21.5 to test
for conflict serializability. (a) Precedence graph for serial schedule A. (b) Precedence
graph for serial schedule B. (c) Precedence graph for schedule C (not serializable).
(d) Precedence graph for schedule D (serializable, equivalent to schedule A).

765

 

respectively, and the precedence graphs for schedules E and F are shown in parts (d)
and (e). Schedule E is not serializable because the corresponding precedence graph
has cycles. Schedule F is serializable, and the serial schedule equivalent to F is shown
in Figure 21.8(e). Although only one equivalent serial schedule exists for F, in gen-
eral there may be more than one equivalent serial schedule for a serializable sched-
ule. Figure 21.8(f) shows a precedence graph representing a schedule that has two
equivalent serial schedules. To find an equivalent serial schedule, start with a node
that does not have any incoming edges, and then make sure that the node order for
every edge is not violated.

21.5.3 How Serializability ls Used for Concurrency Control

As we discussed earlier, saying that a schedule S is (conflict) serializable—that is, S is
(conflict) equivalent to a serial schedule—is tantamount to saying that S is correct.
Being serializable is distinct from being serial, however. A serial schedule represents
inefficient processing because no interleaving of operations from different transac-
tions is permitted. This can lead to low CPU utilization while a transaction waits for
disk I/O, or for another transaction to terminate, thus slowing down processing
considerably. A serializable schedule gives the benefits of concurrent execution
without giving up any correctness. In practice, it is quite difficult to test for the seri-
alizability of a schedule. The interleaving of operations from concurrent transac-
tions—which are usually executed as processes by the operating system—is
typically determined by the operating system scheduler, which allocates resources to

=== Page 795 ===
766 Chapter 21 Introduction to Transaction Processing Concepts and Theory

(a)

(b)

Time

(c)

Time
Figure 21.8
Another example of
serializability testing.
(a) The read and write
operations of three
transactions T,, To,
and T,. (b) Schedule
E. (c) Schedule F.

 

Transaction T,

 

Transaction T,

 

Transaction T,

 

 

read_item(X);
write_item(X);
read_item(Y);

write_item(Y);

 

 

 

 

read_item(Z);
read_item(Y);
write_item(Y);
read_item(X);

write_item(X);

 

 

read_item(Y);
read_item(Z);
Y)
Z)

write_item(Y);
(Z);

write_item

 

 

 

 

Transaction 7,

Transaction T,

Transaction T,

 

 

read_item(X);
write_item(X);

read_item(Y);
write_item(Y);

 

read_item(Z);
read_item(Y);
write_item(Y);

read_item(X);

write_item(X);

 

read_item(Y);
read_item(Z);

write_item(Y);
write_item(Z);

 

Schedule E

 

Transaction T,

Transaction T,

Transaction T,

 

 

read_item(X);
write_item(X);

read_item(Y);
write_item(Y);

 

read_item(Z);

read_item(Y);
write_item(Y);
read_item(X);
write_item(X);

 

read_item(Y);
read_item(Z);

write_item(Y);
write_item(Z);

 

Schedule F

 

 

 

 

all processes. Factors such as system load, time of transaction submission, and pri-
orities of processes contribute to the ordering of operations in a schedule. Hence, it
is difficult to determine how the operations of a schedule will be interleaved before-
hand to ensure serializability.

=== Page 796 ===
21.5 Characterizing Schedules Based on Serializability 767

(d) Y Equivalent serial schedules

© @ 7
Reason
[x 4

y yz Cycle X(T, -& T,),Y(T, > T,)
@ ’ Cycle X(T, -& T,), YZ (Ty -~ Ts), Y(Tz > T;)

(e) XY Equivalent serial schedules

© Oxy wees

(f) Equivalent serial schedules

© Ox, venen

Tz eT, 7; Figure 21.8 (continued)

Another example of serializability testing.
(73) (d) Precedence graph for schedule E.

(e) Precedence graph for schedule F.

(f) Precedence graph with two equivalent

serial schedules.

 

If transactions are executed at will and then the resulting schedule is tested for seri-
alizability, we must cancel the effect of the schedule if it turns out not to be serializ-
able. This is a serious problem that makes this approach impractical. Hence, the
approach taken in most practical systems is to determine methods or protocols that
ensure serializability, without having to test the schedules themselves. The approach
taken in most commercial DBMSs is to design protocols (sets of rules) that—if fol-
lowed by every individual transaction or if enforced by a DBMS concurrency con-
trol subsystem—will ensure serializability of all schedules in which the transactions
participate.

Another problem appears here: When transactions are submitted continuously to
the system, it is difficult to determine when a schedule begins and when it ends.
Serializability theory can be adapted to deal with this problem by considering only
the committed projection of a schedule S. Recall from Section 21.4.1 that the
committed projection C(S) of a schedule S includes only the operations in S that
belong to committed transactions. We can theoretically define a schedule S to be
serializable if its committed projection C(S) is equivalent to some serial schedule,
since only committed transactions are guaranteed by the DBMS.

=== Page 797 ===
768

Chapter 21 Introduction to Transaction Processing Concepts and Theory

In Chapter 22, we discuss a number of different concurrency control protocols that
guarantee serializability. The most common technique, called two-phase locking, is
based on locking data items to prevent concurrent transactions from interfering
with one another, and enforcing an additional condition that guarantees serializ-
ability. This is used in the majority of commercial DBMSs. Other protocols have
been proposed;!* these include timestamp ordering, where each transaction is
assigned a unique timestamp and the protocol ensures that any conflicting opera-
tions are executed in the order of the transaction timestamps; multiversion protocols,
which are based on maintaining multiple versions of data items; and optimistic (also
called certification or validation) protocols, which check for possible serializability
violations after the transactions terminate but before they are permitted to commit.

21.5.4 View Equivalence and View Serializability

In Section 21.5.1 we defined the concepts of conflict equivalence of schedules and
conflict serializability. Another less restrictive definition of equivalence of schedules
is called view equivalence. This leads to another definition of serializability called
view serializability. Two schedules S and S’ are said to be view equivalent if the fol-
lowing three conditions hold:

1. The same set of transactions participates in S and S’, and S and S’ include the
same operations of those transactions.

2. For any operation r,(X) of T; in S, if the value of X read by the operation has
been written by an operation w.(X) of T. (or if it is the original value of X
before the schedule started), the same condition must hold for the value of X
read by operation r,(X) of T; in S’.

3. If the operation w,(Y) of T;, is the last operation to write item Y in S, then
w,(Y) of T;, must also be the last operation to write item Y in S’.

The idea behind view equivalence is that, as long as each read operation of a trans-
action reads the result of the same write operation in both schedules, the write
operations of each transaction must produce the same results. The read operations
are hence said to see the same view in both schedules. Condition 3 ensures that the
final write operation on each data item is the same in both schedules, so the data-
base state should be the same at the end of both schedules. A schedule S is said to be
view serializable if it is view equivalent to a serial schedule.

The definitions of conflict serializability and view serializability are similar if a con-
dition known as the constrained write assumption (or no blind writes) holds on
all transactions in the schedule. This condition states that any write operation w,(X)
in T, is preceded by a r,(X) in T, and that the value written by w,(X) in T, depends
only on the value of X read by r,(X). This assumes that computation of the new
value of X is a function f(X) based on the old value of X read from the database. A
blind write is a write operation in a transaction T on an item X that is not depen-
dent on the value of X, so it is not preceded by a read of X in the transaction T.

 

'4These other protocols have not been incorporated much into commercial systems; most relational
DBMSs use some variation of the two-phase locking protocol.

=== Page 798 ===
21.5 Characterizing Schedules Based on Serializability

The definition of view serializability is less restrictive than that of conflict serializ-
ability under the unconstrained write assumption, where the value written by an
operation w;,(X) in T; can be independent of its old value from the database. This is
possible when blind writes are allowed, and it is illustrated by the following schedule
Se of three transactions T,: r,(X); w,(X); T,: w,(X); and T;: w,(X):

Soi 1 (X)5 wo(X)3 1 (X)5 w3(X)5 C13 C5 C33

In S, the operations w,(X) and w,(X) are blind writes, since T, and T, do not read
the value of X. The schedule S, is view serializable, since it is view equivalent to the
serial schedule T,, T,, T;. However, S, is not conflict serializable, since it is not
conflict equivalent to any serial schedule. It has been shown that any conflict-
serializable schedule is also view serializable but not vice versa, as illustrated by the
preceding example. There is an algorithm to test whether a schedule S is view serial-
izable or not. However, the problem of testing for view serializability has been
shown to be NP-hard, meaning that finding an efficient polynomial time algorithm
for this problem is highly unlikely.

21.5.5 Other Types of Equivalence of Schedules

Serializability of schedules is sometimes considered to be too restrictive as a condi-
tion for ensuring the correctness of concurrent executions. Some applications can
produce schedules that are correct by satisfying conditions less stringent than either
conflict serializability or view serializability. An example is the type of transactions
known as debit-credit transactions—for example, those that apply deposits and
withdrawals to a data item whose value is the current balance of a bank account.
The semantics of debit-credit operations is that they update the value of a data item
X by either subtracting from or adding to the value of the data item. Because addi-
tion and subtraction operations are commutative—that is, they can be applied in
any order—it is possible to produce correct schedules that are not serializable. For
example, consider the following transactions, each of which may be used to transfer
an amount of money between two bank accounts:

T,: r,(X); X = X— 10; w,(X); 17, (Y); Y:= Y + 10; w,(Y)s
T,: 7,(Y); Y:= Y— 20; w,(Y); r,(X); X = X + 20; w,(X);

Consider the following nonserializable schedule S, for the two transactions:
Spt Ty(X)3 wy (X)5 14(Y); w,(Y)s 7(Y)s w(Y)s 17(X); w(X)5

With the additional knowledge, or semantics, that the operations between each r,(J)
and w,(I) are commutative, we know that the order of executing the sequences con-
sisting of (read, update, write) is not important as long as each (read, update, write)
sequence by a particular transaction T; on a particular item I is not interrupted by
conflicting operations. Hence, the schedule S, is considered to be correct even
though it is not serializable. Researchers have been working on extending concur-
rency control theory to deal with cases where serializability is considered to be too
restrictive as a condition for correctness of schedules. Also, in certain domains of
applications such as computer aided design (CAD) of complex systems like aircraft,

769

=== Page 799 ===
770

Chapter 21 Introduction to Transaction Processing Concepts and Theory

design transactions last over a long time period. In such applications, more relaxed
schemes of concurrency control have been proposed to maintain consistency of the
database.

21.6 Transaction Support in SQL

In this section, we give a brief introduction to transaction support in SQL. There are
many more details, and the newer standards have more commands for transaction
processing. The basic definition of an SQL transaction is similar to our already
defined concept of a transaction. That is, it is a logical unit of work and is guaran-
teed to be atomic. A single SQL statement is always considered to be atomic—either
it completes execution without an error or it fails and leaves the database
unchanged.

With SQL, there is no explicit Begin_Transaction statement. Transaction initiation is
done implicitly when particular SQL statements are encountered. However, every
transaction must have an explicit end statement, which is either a COMMIT or a
ROLLBACK. Every transaction has certain characteristics attributed to it. These
characteristics are specified by a SET TRANSACTION statement in SQL. The charac-
teristics are the access mode, the diagnostic area size, and the isolation level.

The access mode can be specified as READ ONLY or READ WRITE. The default is
READ WRITE, unless the isolation level of READ UNCOMMITTED is specified (see
below), in which case READ ONLY is assumed. A mode of READ WRITE allows select,
update, insert, delete, and create commands to be executed. A mode of READ ONLY,
as the name implies, is simply for data retrieval.

The diagnostic area size option, DIAGNOSTIC SIZE n, specifies an integer value n,
which indicates the number of conditions that can be held simultaneously in the
diagnostic area. These conditions supply feedback information (errors or excep-
tions) to the user or program on the n most recently executed SQL statement.

The isolation level option is specified using the statement ISOLATION LEVEL
<isolation>, where the value for <isolation> can be READ UNCOMMITTED, READ
COMMITTED, REPEATABLE READ, or SERIALIZABLE.!° The default isolation level is
SERIALIZABLE, although some systems use READ COMMITTED as their default. The
use of the term SERIALIZABLE here is based on not allowing violations that cause
dirty read, unrepeatable read, and phantoms,'° and it is thus not identical to the way
serializability was defined earlier in Section 21.5. If a transaction executes at a lower
isolation level than SERIALIZABLE, then one or more of the following three viola-
tions may occur:

1. Dirty read. A transaction T, may read the update of a transaction T,, which
has not yet committed. If T, fails and is aborted, then T, would have read a
value that does not exist and is incorrect.

 

'SThese are similar to the isolation levels discussed briefly at the end of Section 21.3.

'8The dirty read and unrepeatable read problems were discussed in Section 21.1.3. Phantoms are dis-
cussed in Section 22.7.1.

=== Page 800 ===
21.6 Transaction Support in SQL

2. Nonrepeatable read. A transaction T, may read a given value from a table. If
another transaction T,, later updates that value and T, reads that value again,
T, will see a different value.

3. Phantoms. A transaction T, may read a set of rows from a table, perhaps
based on some condition specified in the SQL WHERE-clause. Now suppose
that a transaction T, inserts a new row that also satisfies the WHERE-clause
condition used in T,, into the table used by T,. If T, is repeated, then T, will

see a phantom, a row that previously did not exist.

Table 21.1 summarizes the possible violations for the different isolation levels. An
entry of Yes indicates that a violation is possible and an entry of No indicates that it
is not possible. READ UNCOMMITTED is the most forgiving, and SERIALIZABLE is
the most restrictive in that it avoids all three of the problems mentioned above.

A sample SQL transaction might look like the following:

EXEC SQL WHENEVER SQLERROR GOTO UNDO;
EXEC SQL SET TRANSACTION
READ WRITE
DIAGNOSTIC SIZE 5
ISOLATION LEVEL SERIALIZABLE;
EXEC SQL INSERT INTO EMPLOYEE (Fname, Lname, Ssn, Dno, Salary)
VALUES ('Robert', 'Smith', '991004321', 2, 35000);
EXEC SQL UPDATE EMPLOYEE
SET Salary = Salary * 1.1 WHERE Dno = 2;
EXEC SQL COMMIT;
GOTO THE END;
UNDO: EXEC SQL ROLLBACK;
THE END: ... ;

The above transaction consists of first inserting a new row in the EMPLOYEE table
and then updating the salary of all employees who work in department 2. If an error
occurs on any of the SQL statements, the entire transaction is rolled back. This
implies that any updated salary (by this transaction) would be restored to its previ-
ous value and that the newly inserted row would be removed.

As we have seen, SQL provides a number of transaction-oriented features. The DBA
or database programmers can take advantage of these options to try improving

Table 21.1 Possible Violations Based on Isolation Levels as Defined in SOL

 

Type of Violation

Isolation Level Dirty Read Nonrepeatable Read Phantom
READ UNCOMMITTED Yes Yes Yes
READ COMMITTED No Yes Yes
REPEATABLE READ No No Yes

SERIALIZABLE No No No

 

771

=== Page 801 ===
772

Chapter 21 Introduction to Transaction Processing Concepts and Theory

transaction performance by relaxing serializability if that is acceptable for their
applications.

21.7 Summary

In this chapter we discussed DBMS concepts for transaction processing. We intro-
duced the concept of a database transaction and the operations relevant to transac-
tion processing. We compared single-user systems to multiuser systems and then
presented examples of how uncontrolled execution of concurrent transactions in a
multiuser system can lead to incorrect results and database values. We also discussed
the various types of failures that may occur during transaction execution.

Next we introduced the typical states that a transaction passes through during execu-
tion, and discussed several concepts that are used in recovery and concurrency con-
trol methods. The system log keeps track of database accesses, and the system uses
this information to recover from failures. A transaction either succeeds and reaches
its commit point or it fails and has to be rolled back. A committed transaction has its
changes permanently recorded in the database. We presented an overview of the
desirable properties of transactions—atomicity, consistency preservation, isolation,
and durability—which are often referred to as the ACID properties.

Then we defined a schedule (or history) as an execution sequence of the operations
of several transactions with possible interleaving. We characterized schedules in
terms of their recoverability. Recoverable schedules ensure that, once a transaction
commits, it never needs to be undone. Cascadeless schedules add an additional con-
dition to ensure that no aborted transaction requires the cascading abort of other
transactions. Strict schedules provide an even stronger condition that allows a sim-
ple recovery scheme consisting of restoring the old values of items that have been
changed by an aborted transaction.

We defined equivalence of schedules and saw that a serializable schedule is equiva-
lent to some serial schedule. We defined the concepts of conflict equivalence and
view equivalence, which led to definitions for conflict serializability and view serial-
izability. A serializable schedule is considered correct. We presented an algorithm
for testing the (conflict) serializability of a schedule. We discussed why testing for
serializability is impractical in a real system, although it can be used to define and
verify concurrency control protocols, and we briefly mentioned less restrictive defi-
nitions of schedule equivalence. Finally, we gave a brief overview of how transaction
concepts are used in practice within SQL.

Review Questions

21.1. What is meant by the concurrent execution of database transactions in a
multiuser system? Discuss why concurrency control is needed, and give
informal examples.

=== Page 802 ===
21.2.

21.3.

21.4.

21.5.

21.6.

21.8.

21.9.

21.10.

21.11.

21.12.

21.13.

Discuss the different types of failures. What is meant by catastrophic failure?

Discuss the actions taken by the read_item and write_item operations on a
database.

Draw a state diagram and discuss the typical states that a transaction goes
through during execution.

What is the system log used for? What are the typical kinds of records in a
system log? What are transaction commit points, and why are they impor-
tant?

Discuss the atomicity, durability, isolation, and consistency preservation
properties of a database transaction.

. What is a schedule (history)? Define the concepts of recoverable, cascadeless,

and strict schedules, and compare them in terms of their recoverability.

Discuss the different measures of transaction equivalence. What is the differ-
ence between conflict equivalence and view equivalence?

What is a serial schedule? What is a serializable schedule? Why is a serial
schedule considered correct? Why is a serializable schedule considered cor-
rect?

What is the difference between the constrained write and the unconstrained
write assumptions? Which is more realistic?

Discuss how serializability is used to enforce concurrency control in a data-
base system. Why is serializability sometimes considered too restrictive as a
measure of correctness for schedules?

Describe the four levels of isolation in SQL.

Define the violations caused by each of the following: dirty read, nonrepeat-
able read, and phantoms.

Exercises

21.14.

21.15.

Change transaction T, in Figure 21.2(b) to read

read_item(X);

X :=X+M;

if X > 90 then exit

else write_item(X);
Discuss the final result of the different schedules in Figure 21.3(a) and (b),
where M = 2 and N = 2, with respect to the following questions: Does adding
the above condition change the final outcome? Does the outcome obey the
implied consistency rule (that the capacity of X is 90)?

Repeat Exercise 21.14, adding a check in T, so that Y does not exceed 90.

Exercises

773

=== Page 803 ===
774

Chapter 21 Introduction to Transaction Processing Concepts and Theory

21.16.

21.17.

21.18.

21.19.

21.20.

21.21.

21.22.

21.23.

21.24.

Add the operation commit at the end of each of the transactions T, and T, in
Figure 21.2, and then list all possible schedules for the modified transactions.
Determine which of the schedules are recoverable, which are cascadeless,
and which are strict.

List all possible schedules for transactions T, and T, in Figure 21.2, and
determine which are conflict serializable (correct) and which are not.

How many serial schedules exist for the three transactions in Figure 21.8(a)?
What are they? What is the total number of possible schedules?

Write a program to create all possible schedules for the three transactions in
Figure 21.8(a), and to determine which of those schedules are conflict serial-
izable and which are not. For each conflict-serializable schedule, your pro-
gram should print the schedule and list all equivalent serial schedules.

Why is an explicit transaction end statement needed in SQL but not an
explicit begin statement?

Describe situations where each of the different isolation levels would be use-
ful for transaction processing.

Which of the following schedules is (conflict) serializable? For each serializ-
able schedule, determine the equivalent serial schedules.

a. 1 (X); 7,(X)3 w(X)5 1,(X)5 w3(X)5
b. 1,(X)3 7,(X); w3(X); w, (X)5 1,(X)s

c. 73(X)5 r4(X); w3(X)5 17 (X)3 W(X);
d. r,(X); 1,(X)5 7, (X)3 w3(X); w,(X);

Consider the three transactions T,, T,, and T;, and the schedules S, and S,
given below. Draw the serializability (precedence) graphs for S, and S,, and
state whether each schedule is serializable or not. If a schedule is serializable,
write down the equivalent serial schedule(s).
Ty: 1, (X)3 1, (Z)3 w, (X)5

r, (Z); r, (Y); w, (Z); w, (VY);

1; (X)3 7; (Y)3 w, (Y);
Sut, (X)5 7, (Z)3 7, (2)5. 7, (Xs 7, (Y)s w, (X)s w; (Y)s 1, (Y)s wy (Z)3 wy (Y)5
55:1, (X)5 1, (Z)3 75 (X)3 7, (2). 7, (Y)5 15 (Y)s w, (X)s wy (Z)3 w; (Y)3 wy (Y)5

Consider schedules S,, S,, and S, below. Determine whether each schedule is

strict, cascadeless, recoverable, or nonrecoverable. (Determine the strictest

recoverability condition that each schedule satisfies.)

S3: 1 (X)3 ry (Z)3 ry (Z)3 73 (X)3 75 (Y)3 wy (Xs 3 wy (Y)5 €53 7 (VY) wy (Z)5
Wy (Y)3 5

Sg ty (X)3 1 (Z)3 7 (Z)3 175 (X37 (V3 wy, 25 wy (Y)5 ry (V3 wy (Z)3 Wy (V3 03
C5} C33

S5: 1) (X)3 1 (Z)3 73 3 1) (Z)3 ry (W375 Ys wy (XY 3 wy (Z)3 3 (Y)3 wy (Y)5

C33 C53

=== Page 804 ===
Selected Bibliography

Selected Bibliography

The concept of serializability and related ideas to maintain consistency in a database
were introduced in Gray et al. (1975). The concept of the database transaction was
first discussed in Gray (1981). Gray won the coveted ACM Turing Award in 1998 for
his work on database transactions and implementation of transactions in relational
DBMSs. Bernstein, Hadzilacos, and Goodman (1988) focus on concurrency control
and recovery techniques in both centralized and distributed database systems; it is
an excellent reference. Papadimitriou (1986) offers a more theoretical perspective. A
large reference book of more than a thousand pages by Gray and Reuter (1993)
offers a more practical perspective of transaction processing concepts and tech-
niques. Elmagarmid (1992) offers collections of research papers on transaction pro-
cessing for advanced applications. Transaction support in SQL is described in Date
and Darwen (1997). View serializability is defined in Yannakakis (1984).
Recoverability of schedules and reliability in databases is discussed in Hadzilacos
(1983, 1988).

775

=== Page 805 ===
This page intentionally left blank

=== Page 806 ===
chapter 4 —

Concurrency Control
Techniques

n this chapter we discuss a number of concurrency

control techniques that are used to ensure the nonin-
terference or isolation property of concurrently executing transactions. Most of
these techniques ensure serializability of schedules—which we defined in Section
21.5—using concurrency control protocols (sets of rules) that guarantee serializ-
ability. One important set of protocols—known as two-phase locking protocols—
employ the technique of locking data items to prevent multiple transactions from
accessing the items concurrently; a number of locking protocols are described in
Sections 22.1 and 22.3.2. Locking protocols are used in most commercial DBMSs.
Another set of concurrency control protocols use timestamps. A timestamp is a
unique identifier for each transaction, generated by the system. Timestamps values
are generated in the same order as the transaction start times. Concurrency control
protocols that use timestamp ordering to ensure serializability are introduced in
Section 22.2. In Section 22.3 we discuss multiversion concurrency control proto-
cols that use multiple versions of a data item. One multiversion protocol extends
timestamp order to multiversion timestamp ordering (Section 22.3.1), and another
extends two-phase locking (Section 22.3.2). In Section 22.4 we present a protocol
based on the concept of validation or certification of a transaction after it executes
its operations; these are sometimes called optimistic protocols, and also assume
that multiple versions of a data item can exist.

Another factor that affects concurrency control is the granularity of the data
items—that is, what portion of the database a data item represents. An item can be
as small as a single attribute (field) value or as large as a disk block, or even a whole
file or the entire database. We discuss granularity of items and a multiple granular-
ity concurrency control protocol, which is an extension of two-phase locking, in
Section 22.5. In Section 22.6 we describe concurrency control issues that arise when

777

